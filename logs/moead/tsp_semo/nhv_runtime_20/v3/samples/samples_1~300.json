[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9032423157374491,
            0.20829319953918457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9032423157374491,
            0.20829319953918457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9032423157374491,
            0.20829319953918457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by combining dominance-based selection with a novel hybrid local search that dynamically adapts between edge-swapping and segment-reversing operations, guided by multi-objective fitness criteria, while ensuring feasibility through careful validation of all generated moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge swapping and segment reversing\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between edge swap and segment reverse\n    if np.random.random() < 0.5:  # Edge swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Segment reverse\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the new solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if segment reverse causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic adaptation: if the new solution is worse, try a different operator\n    new_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if (new_obj1 > current_obj[0] and new_obj2 > current_obj[1]):\n        # Revert to the original solution if the new one is worse in both objectives\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.837846564567307,
            0.6439372301101685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge swapping and segment reversing\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly choose between edge swap and segment reverse\n    if np.random.random() < 0.5:  # Edge swap\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # Segment reverse\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the new solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if segment reverse causes duplicates\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic adaptation: if the new solution is worse, try a different operator\n    new_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if (new_obj1 > current_obj[0] and new_obj2 > current_obj[1]):\n        # Revert to the original solution if the new one is worse in both objectives\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment and reverse it\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a novel swap strategy based on distance matrices\n    # Find the most \"improving\" swap between two nodes in the segment\n    best_improvement = 0\n    best_swap = (0, 0)\n    for a in range(i, j+1):\n        for b in range(i, j+1):\n            if a == b:\n                continue\n            # Calculate improvement in both objectives\n            delta_1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_1[new_solution[b], new_solution[(b+1)%N]])\n            delta_2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_2[new_solution[b], new_solution[(b+1)%N]])\n            improvement = -delta_1 - delta_2  # Maximize combined improvement\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n    if best_improvement > 0:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9298400218398453,
            0.51887446641922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment and reverse it\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a novel swap strategy based on distance matrices\n    # Find the most \"improving\" swap between two nodes in the segment\n    best_improvement = 0\n    best_swap = (0, 0)\n    for a in range(i, j+1):\n        for b in range(i, j+1):\n            if a == b:\n                continue\n            # Calculate improvement in both objectives\n            delta_1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_1[new_solution[b], new_solution[(b+1)%N]])\n            delta_2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_2[new_solution[b], new_solution[(b+1)%N]])\n            improvement = -delta_1 - delta_2  # Maximize combined improvement\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n    if best_improvement > 0:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment and reverse it\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a novel swap strategy based on distance matrices\n    # Find the most \"improving\" swap between two nodes in the segment\n    best_improvement = 0\n    best_swap = (0, 0)\n    for a in range(i, j+1):\n        for b in range(i, j+1):\n            if a == b:\n                continue\n            # Calculate improvement in both objectives\n            delta_1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_1[new_solution[b], new_solution[(b+1)%N]])\n            delta_2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_2[new_solution[b], new_solution[(b+1)%N]])\n            improvement = -delta_1 - delta_2  # Maximize combined improvement\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n    if best_improvement > 0:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9298400218398453,
            0.51887446641922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment reversal and swap strategy\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a segment and reverse it\n    i, j = sorted(random.sample(range(N), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a novel swap strategy based on distance matrices\n    # Find the most \"improving\" swap between two nodes in the segment\n    best_improvement = 0\n    best_swap = (0, 0)\n    for a in range(i, j+1):\n        for b in range(i, j+1):\n            if a == b:\n                continue\n            # Calculate improvement in both objectives\n            delta_1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_1[new_solution[b], new_solution[(b+1)%N]])\n            delta_2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b], new_solution[(a+1)%N]] -\n                       distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                       distance_matrix_2[new_solution[b], new_solution[(b+1)%N]])\n            improvement = -delta_1 - delta_2  # Maximize combined improvement\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n    if best_improvement > 0:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.981765734008441,
            0.20783603191375732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.981765734008441,
            0.20783603191375732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.981765734008441,
            0.20783603191375732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel hybrid local search algorithm that intelligently combines a biased random walk with a multi-objective-aware edge swap to explore high-quality solutions while ensuring feasibility, leveraging both distance matrices to guide improvements across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) == 0:\n        return archive[0][0].copy()\n\n    # Normalize costs to avoid division by zero and create a probability distribution\n    min_cost = np.min(costs)\n    max_cost = np.max(costs)\n    if max_cost == min_cost:\n        probabilities = np.ones(len(costs)) / len(costs)\n    else:\n        normalized_costs = (costs - min_cost) / (max_cost - min_cost)\n        probabilities = 1 - normalized_costs\n        probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: biased random walk + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Biased random walk: move towards nodes that reduce the total cost in either objective\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    # Try to find a better segment by evaluating nearby nodes\n    best_segment = None\n    best_improvement = 0\n\n    for i in range(segment_start, segment_start + segment_length):\n        for j in range(i + 1, min(i + segment_length, n)):\n            if j - i + 1 < 2:\n                continue\n\n            # Evaluate the segment\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate the change in cost\n            delta_cost1 = 0\n            delta_cost2 = 0\n\n            if i > 0:\n                delta_cost1 += distance_matrix_1[new_solution[i-1], reversed_segment[0]] - distance_matrix_1[new_solution[i-1], segment[0]]\n                delta_cost2 += distance_matrix_2[new_solution[i-1], reversed_segment[0]] - distance_matrix_2[new_solution[i-1], segment[0]]\n            if j < n - 1:\n                delta_cost1 += distance_matrix_1[reversed_segment[-1], new_solution[j+1]] - distance_matrix_1[segment[-1], new_solution[j+1]]\n                delta_cost2 += distance_matrix_2[reversed_segment[-1], new_solution[j+1]] - distance_matrix_2[segment[-1], new_solution[j+1]]\n\n            # If the segment is at the end, connect the last node to the first\n            if j == n - 1:\n                delta_cost1 += distance_matrix_1[reversed_segment[-1], new_solution[0]] - distance_matrix_1[segment[-1], new_solution[0]]\n                delta_cost2 += distance_matrix_2[reversed_segment[-1], new_solution[0]] - distance_matrix_2[segment[-1], new_solution[0]]\n\n            # Accept if it improves either objective\n            if delta_cost1 < 0 or delta_cost2 < 0:\n                if delta_cost1 + delta_cost2 < best_improvement:\n                    best_improvement = delta_cost1 + delta_cost2\n                    best_segment = (i, j)\n\n    if best_segment is not None:\n        i, j = best_segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a random swap to escape local optima\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7510550765081526,
            1.519423484802246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for (sol, obj) in archive]\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(costs) == 0:\n        return archive[0][0].copy()\n\n    # Normalize costs to avoid division by zero and create a probability distribution\n    min_cost = np.min(costs)\n    max_cost = np.max(costs)\n    if max_cost == min_cost:\n        probabilities = np.ones(len(costs)) / len(costs)\n    else:\n        normalized_costs = (costs - min_cost) / (max_cost - min_cost)\n        probabilities = 1 - normalized_costs\n        probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: biased random walk + edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Biased random walk: move towards nodes that reduce the total cost in either objective\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a segment to perturb\n    segment_start = random.randint(0, n-3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    # Try to find a better segment by evaluating nearby nodes\n    best_segment = None\n    best_improvement = 0\n\n    for i in range(segment_start, segment_start + segment_length):\n        for j in range(i + 1, min(i + segment_length, n)):\n            if j - i + 1 < 2:\n                continue\n\n            # Evaluate the segment\n            segment = new_solution[i:j+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate the change in cost\n            delta_cost1 = 0\n            delta_cost2 = 0\n\n            if i > 0:\n                delta_cost1 += distance_matrix_1[new_solution[i-1], reversed_segment[0]] - distance_matrix_1[new_solution[i-1], segment[0]]\n                delta_cost2 += distance_matrix_2[new_solution[i-1], reversed_segment[0]] - distance_matrix_2[new_solution[i-1], segment[0]]\n            if j < n - 1:\n                delta_cost1 += distance_matrix_1[reversed_segment[-1], new_solution[j+1]] - distance_matrix_1[segment[-1], new_solution[j+1]]\n                delta_cost2 += distance_matrix_2[reversed_segment[-1], new_solution[j+1]] - distance_matrix_2[segment[-1], new_solution[j+1]]\n\n            # If the segment is at the end, connect the last node to the first\n            if j == n - 1:\n                delta_cost1 += distance_matrix_1[reversed_segment[-1], new_solution[0]] - distance_matrix_1[segment[-1], new_solution[0]]\n                delta_cost2 += distance_matrix_2[reversed_segment[-1], new_solution[0]] - distance_matrix_2[segment[-1], new_solution[0]]\n\n            # Accept if it improves either objective\n            if delta_cost1 < 0 or delta_cost2 < 0:\n                if delta_cost1 + delta_cost2 < best_improvement:\n                    best_improvement = delta_cost1 + delta_cost2\n                    best_segment = (i, j)\n\n    if best_segment is not None:\n        i, j = best_segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a random swap to escape local optima\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a novel local search operator that combines segment reversal with a dynamic edge reordering strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search operator: Dynamic segment reversal with edge reordering\n    # Step 1: Identify critical segments based on both objective distances\n    segment_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[selected_solution[i], selected_solution[j]]\n        cost2 = distance_matrix_2[selected_solution[i], selected_solution[j]]\n        segment_scores.append(cost1 + cost2)\n\n    # Step 2: Select top 3 worst segments to potentially reverse\n    worst_segments = sorted(range(n), key=lambda i: segment_scores[i])[:3]\n\n    # Step 3: Apply dynamic reversal with edge reordering\n    for i in worst_segments:\n        j = (i + 1) % n\n        # Reverse segment and reorder edges based on combined cost\n        segment = new_solution[i:j+1] if i < j else np.concatenate([new_solution[i:], new_solution[:j+1]])\n        reversed_segment = np.flip(segment)\n\n        # Evaluate all possible edge orderings in the reversed segment\n        best_order = None\n        min_cost = float('inf')\n\n        for k in range(len(reversed_segment)):\n            ordered_segment = np.roll(reversed_segment, k)\n            # Calculate combined cost of the new segment\n            cost1 = distance_matrix_1[new_solution[i-1], ordered_segment[0]] + distance_matrix_1[ordered_segment[-1], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i-1], ordered_segment[0]] + distance_matrix_2[ordered_segment[-1], new_solution[j]]\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_order = ordered_segment\n\n        # Apply the best ordering\n        if best_order is not None:\n            if i < j:\n                new_solution[i:j+1] = best_order\n            else:\n                new_solution[i:] = best_order[:n-i]\n                new_solution[:j+1] = best_order[n-i:]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9814224602521628,
            0.3090527057647705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search operator: Dynamic segment reversal with edge reordering\n    # Step 1: Identify critical segments based on both objective distances\n    segment_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[selected_solution[i], selected_solution[j]]\n        cost2 = distance_matrix_2[selected_solution[i], selected_solution[j]]\n        segment_scores.append(cost1 + cost2)\n\n    # Step 2: Select top 3 worst segments to potentially reverse\n    worst_segments = sorted(range(n), key=lambda i: segment_scores[i])[:3]\n\n    # Step 3: Apply dynamic reversal with edge reordering\n    for i in worst_segments:\n        j = (i + 1) % n\n        # Reverse segment and reorder edges based on combined cost\n        segment = new_solution[i:j+1] if i < j else np.concatenate([new_solution[i:], new_solution[:j+1]])\n        reversed_segment = np.flip(segment)\n\n        # Evaluate all possible edge orderings in the reversed segment\n        best_order = None\n        min_cost = float('inf')\n\n        for k in range(len(reversed_segment)):\n            ordered_segment = np.roll(reversed_segment, k)\n            # Calculate combined cost of the new segment\n            cost1 = distance_matrix_1[new_solution[i-1], ordered_segment[0]] + distance_matrix_1[ordered_segment[-1], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i-1], ordered_segment[0]] + distance_matrix_2[ordered_segment[-1], new_solution[j]]\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_order = ordered_segment\n\n        # Apply the best ordering\n        if best_order is not None:\n            if i < j:\n                new_solution[i:j+1] = best_order\n            else:\n                new_solution[i:] = best_order[:n-i]\n                new_solution[:j+1] = best_order[n-i:]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{Select a solution from the archive based on its dominance in both objectives, then apply a novel local search that combines segment reversal with a biased edge reordering strategy to explore non-dominated regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Biased segment reversal with objective-aware edge selection\n    for _ in range(2):\n        # Select segments based on their potential to improve both objectives\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment if it improves the worse objective\n        reversed_segment = np.flip(segment)\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]],\n                      distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b]])\n\n        if max(cost_after) <= max(cost_before):\n            new_solution[a:b] = reversed_segment\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by swapping conflicting nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            indices = np.where(new_solution == dup)[0]\n            for idx in indices[1:]:\n                # Find a valid replacement\n                candidates = [i for i in range(n) if new_solution[i] not in new_solution[:idx]]\n                if candidates:\n                    new_solution[idx] = new_solution[random.choice(candidates)]\n\n    return new_solution\n\n",
        "score": [
            -0.46274245393982283,
            2.4250168800354004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Biased segment reversal with objective-aware edge selection\n    for _ in range(2):\n        # Select segments based on their potential to improve both objectives\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment if it improves the worse objective\n        reversed_segment = np.flip(segment)\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]],\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n        cost_after = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[b]],\n                      distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[b]])\n\n        if max(cost_after) <= max(cost_before):\n            new_solution[a:b] = reversed_segment\n\n    # Ensure feasibility by checking for duplicates and repairing if needed\n    if len(np.unique(new_solution)) != n:\n        # Repair by swapping conflicting nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            indices = np.where(new_solution == dup)[0]\n            for idx in indices[1:]:\n                # Find a valid replacement\n                candidates = [i for i in range(n) if new_solution[i] not in new_solution[:idx]]\n                if candidates:\n                    new_solution[idx] = new_solution[random.choice(candidates)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel local search strategy that combines random segment reversal with a probabilistic edge insertion mechanism, where segments are selected based on their potential improvement in both objectives, and edges are inserted in a way that minimizes the increase in tour length while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Probabilistically insert an edge from another segment\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(1, n), 2))\n        edge = new_solution[c]\n        # Find a position to insert the edge that minimizes the increase in both objectives\n        best_pos = -1\n        min_increase = float('inf')\n        for i in range(1, n):\n            if i != c and i != c + 1:\n                # Calculate the increase in both objectives\n                increase = (distance_matrix_1[new_solution[i-1], edge] + distance_matrix_1[edge, new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n                           (distance_matrix_2[new_solution[i-1], edge] + distance_matrix_2[edge, new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = i\n        if best_pos != -1:\n            # Insert the edge at the best position\n            new_solution = np.insert(new_solution, best_pos, edge)\n            # Remove the duplicate (original position of the edge)\n            new_solution = np.delete(new_solution, c if c < best_pos else c + 1)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8600492087487968,
            0.22714108228683472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Probabilistically insert an edge from another segment\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(1, n), 2))\n        edge = new_solution[c]\n        # Find a position to insert the edge that minimizes the increase in both objectives\n        best_pos = -1\n        min_increase = float('inf')\n        for i in range(1, n):\n            if i != c and i != c + 1:\n                # Calculate the increase in both objectives\n                increase = (distance_matrix_1[new_solution[i-1], edge] + distance_matrix_1[edge, new_solution[i]] - distance_matrix_1[new_solution[i-1], new_solution[i]]) + \\\n                           (distance_matrix_2[new_solution[i-1], edge] + distance_matrix_2[edge, new_solution[i]] - distance_matrix_2[new_solution[i-1], new_solution[i]])\n                if increase < min_increase:\n                    min_increase = increase\n                    best_pos = i\n        if best_pos != -1:\n            # Insert the edge at the best position\n            new_solution = np.insert(new_solution, best_pos, edge)\n            # Remove the duplicate (original position of the edge)\n            new_solution = np.delete(new_solution, c if c < best_pos else c + 1)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of normalized objectives, then applies a novel edge-reversal strategy that selectively reverses segments of the tour while preserving feasibility and exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-reversal strategy: select three random segments and reverse them in a specific order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply the edge reversal: reverse segments in a non-sequential order\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n    new_solution[a:c] = np.flip(new_solution[a:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6961309112175096,
            0.18770241737365723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-reversal strategy: select three random segments and reverse them in a specific order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply the edge reversal: reverse segments in a non-sequential order\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n    new_solution[a:c] = np.flip(new_solution[a:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of normalized objectives, then applies a novel edge-reversal strategy that selectively reverses segments of the tour while preserving feasibility and exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-reversal strategy: select three random segments and reverse them in a specific order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply the edge reversal: reverse segments in a non-sequential order\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n    new_solution[a:c] = np.flip(new_solution[a:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6961309112175096,
            0.18770241737365723
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-reversal strategy: select three random segments and reverse them in a specific order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply the edge reversal: reverse segments in a non-sequential order\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n    new_solution[a:c] = np.flip(new_solution[a:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel heuristic that selects a solution from the archive based on a weighted sum of objectives with random perturbation, then applies a hybrid local search combining segment reversal and edge-swap operations while ensuring feasibility through validation and fallback to simpler moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [random.uniform(0.3, 0.7), random.uniform(0.3, 0.7)]\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Random edge-swap\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8029013678195034,
            0.21458220481872559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [random.uniform(0.3, 0.7), random.uniform(0.3, 0.7)]\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Random edge-swap\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Edge swap between two random non-adjacent edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9371933437842593,
            0.2423783540725708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Edge swap between two random non-adjacent edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal and edge swaps with a novel adaptive segment selection strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on objective improvement potential\n    obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Determine segment size based on objective balance\n    segment_size = max(2, int(0.3 * n * (1 - min(obj1, obj2) / max(obj1, obj2))))\n\n    # Randomly select segments with adaptive size\n    a = random.randint(1, n - segment_size)\n    b = a + segment_size\n    c = random.randint(1, n - segment_size)\n    d = c + segment_size\n\n    # Apply segment reversal with probability based on objective balance\n    if random.random() < 0.7 * (1 - obj1 / (obj1 + obj2)):\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    if random.random() < 0.3 * (obj2 / (obj1 + obj2)):\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Novel edge swap with adaptive probability\n    if random.random() < 0.5 * (1 - abs(obj1 - obj2) / (obj1 + obj2)):\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.966896135318451,
            0.23782992362976074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on objective improvement potential\n    obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Determine segment size based on objective balance\n    segment_size = max(2, int(0.3 * n * (1 - min(obj1, obj2) / max(obj1, obj2))))\n\n    # Randomly select segments with adaptive size\n    a = random.randint(1, n - segment_size)\n    b = a + segment_size\n    c = random.randint(1, n - segment_size)\n    d = c + segment_size\n\n    # Apply segment reversal with probability based on objective balance\n    if random.random() < 0.7 * (1 - obj1 / (obj1 + obj2)):\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    if random.random() < 0.3 * (obj2 / (obj1 + obj2)):\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Novel edge swap with adaptive probability\n    if random.random() < 0.5 * (1 - abs(obj1 - obj2) / (obj1 + obj2)):\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0070144886720338,
            1.5190768241882324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0070144886720338,
            1.5190768241882324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to rotate and reinsert\n    segment_length = random.randint(3, min(6, n-1))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, segment_length-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Remove the original segment and reinsert the rotated one at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], rotated_segment, new_solution[insert_pos:]])\n\n    # Verify feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a simple swap as fallback\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.942118955624692,
            0.19342464208602905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to rotate and reinsert\n    segment_length = random.randint(3, min(6, n-1))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, segment_length-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Remove the original segment and reinsert the rotated one at a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], rotated_segment, new_solution[insert_pos:]])\n\n    # Verify feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a simple swap as fallback\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on the Pareto dominance count (number of solutions it dominates) and applies a hybrid local search combining edge insertion with a novel segment rotation strategy while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = [sum(1 for sol in archive if (sol[1][0] >= obj[0] and sol[1][1] >= obj[1]) and (sol[1][0] > obj[0] or sol[1][1] > obj[1])) for _, obj in archive]\n    selected_solution = archive[dominance_counts.index(max(dominance_counts))][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Edge insertion with segment rotation\n    i, j = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[i:j].copy()\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Rotate segment to find better configuration\n    best_segment = segment.copy()\n    for k in range(1, len(segment)):\n        rotated = np.roll(segment, k)\n        if (distance_matrix_1[new_solution[insert_pos-1], rotated[0]] + distance_matrix_1[rotated[-1], new_solution[(insert_pos + len(segment)) % n]]) < \\\n           (distance_matrix_1[new_solution[insert_pos-1], best_segment[0]] + distance_matrix_1[best_segment[-1], new_solution[(insert_pos + len(best_segment)) % n]]):\n            best_segment = rotated\n\n    new_solution[insert_pos:insert_pos+len(best_segment)] = best_segment\n\n    # Repair if invalid\n    if len(np.unique(new_solution)) != n:\n        missing = [node for node in range(n) if node not in new_solution]\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.876932478829138,
            0.3144041895866394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = [sum(1 for sol in archive if (sol[1][0] >= obj[0] and sol[1][1] >= obj[1]) and (sol[1][0] > obj[0] or sol[1][1] > obj[1])) for _, obj in archive]\n    selected_solution = archive[dominance_counts.index(max(dominance_counts))][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Edge insertion with segment rotation\n    i, j = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[i:j].copy()\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Rotate segment to find better configuration\n    best_segment = segment.copy()\n    for k in range(1, len(segment)):\n        rotated = np.roll(segment, k)\n        if (distance_matrix_1[new_solution[insert_pos-1], rotated[0]] + distance_matrix_1[rotated[-1], new_solution[(insert_pos + len(segment)) % n]]) < \\\n           (distance_matrix_1[new_solution[insert_pos-1], best_segment[0]] + distance_matrix_1[best_segment[-1], new_solution[(insert_pos + len(best_segment)) % n]]):\n            best_segment = rotated\n\n    new_solution[insert_pos:insert_pos+len(best_segment)] = best_segment\n\n    # Repair if invalid\n    if len(np.unique(new_solution)) != n:\n        missing = [node for node in range(n) if node not in new_solution]\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid of segment reversal and node insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: segment reversal with node insertion\n    # Step 1: Reverse a random segment\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Step 2: Insert a random node at a different position\n    node = random.choice(new_solution[1:-1])\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([\n        new_solution[:pos],\n        np.array([node]),\n        new_solution[new_solution != node]\n    ])[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal if insertion causes duplicates\n        new_solution = selected_solution.copy()\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.9313931014132435,
            0.19527900218963623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n\n    # Hybrid local search: segment reversal with node insertion\n    # Step 1: Reverse a random segment\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Step 2: Insert a random node at a different position\n    node = random.choice(new_solution[1:-1])\n    pos = random.randint(1, n-1)\n    new_solution = np.concatenate([\n        new_solution[:pos],\n        np.array([node]),\n        new_solution[new_solution != node]\n    ])[:n]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal if insertion causes duplicates\n        new_solution = selected_solution.copy()\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a block of nodes to remove and reinsert\n    block_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - block_size)\n    block = new_solution[start:start+block_size]\n\n    # Remove the block\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+block_size:]])\n\n    # Find the best insertion position for the block\n    best_pos = 0\n    best_gain = -float('inf')\n\n    for pos in range(len(new_solution) - block_size + 1):\n        # Temporarily insert the block\n        candidate = np.concatenate([new_solution[:pos], block, new_solution[pos:]])\n\n        # Calculate the gain in both objectives\n        cost1 = distance_matrix_1[candidate[-1], candidate[0]] + sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n        cost2 = distance_matrix_2[candidate[-1], candidate[0]] + sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n\n        # Combine the gains (weighted sum)\n        gain = - (cost1 + cost2)\n\n        if gain > best_gain:\n            best_gain = gain\n            best_pos = pos\n\n    # Insert the block at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], block, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9149198786257835,
            0.4373634457588196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a block of nodes to remove and reinsert\n    block_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - block_size)\n    block = new_solution[start:start+block_size]\n\n    # Remove the block\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+block_size:]])\n\n    # Find the best insertion position for the block\n    best_pos = 0\n    best_gain = -float('inf')\n\n    for pos in range(len(new_solution) - block_size + 1):\n        # Temporarily insert the block\n        candidate = np.concatenate([new_solution[:pos], block, new_solution[pos:]])\n\n        # Calculate the gain in both objectives\n        cost1 = distance_matrix_1[candidate[-1], candidate[0]] + sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n        cost2 = distance_matrix_2[candidate[-1], candidate[0]] + sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1))\n\n        # Combine the gains (weighted sum)\n        gain = - (cost1 + cost2)\n\n        if gain > best_gain:\n            best_gain = gain\n            best_pos = pos\n\n    # Insert the block at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], block, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The new algorithm selects a solution from the archive with the highest combined objective score and applies a novel segment-shuffling strategy that randomly permutes non-overlapping segments of the tour while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Split the tour into k random non-overlapping segments and shuffle them\n    k = random.randint(2, min(5, n//2))\n    segment_length = n // k\n    segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(k)]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Repair to ensure feasibility (no duplicates and all nodes present)\n    missing_nodes = set(range(n)) - set(new_solution)\n    extra_nodes = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n    if missing_nodes or extra_nodes:\n        # Replace extra nodes with missing ones\n        for extra in extra_nodes:\n            if missing_nodes:\n                idx = np.where(new_solution == extra)[0][0]\n                new_solution[idx] = missing_nodes.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8962546071078863,
            0.19415372610092163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Split the tour into k random non-overlapping segments and shuffle them\n    k = random.randint(2, min(5, n//2))\n    segment_length = n // k\n    segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(k)]\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Repair to ensure feasibility (no duplicates and all nodes present)\n    missing_nodes = set(range(n)) - set(new_solution)\n    extra_nodes = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n    if missing_nodes or extra_nodes:\n        # Replace extra nodes with missing ones\n        for extra in extra_nodes:\n            if missing_nodes:\n                idx = np.where(new_solution == extra)[0][0]\n                new_solution[idx] = missing_nodes.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel bi-objective TSP heuristic selects a solution from the archive using a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge swapping with probabilistic segment selection and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Probabilistic segment reversal and edge swap\n    if random.random() < 0.7:  # 70% chance for segment reversal\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:  # 30% chance for edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 2:  # Ensure meaningful swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.906118662510711,
            0.20485186576843262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Probabilistic segment reversal and edge swap\n    if random.random() < 0.7:  # 70% chance for segment reversal\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:  # 30% chance for edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 2:  # Ensure meaningful swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a novel hybrid local search that combines segment reversal with a dynamic edge reordering strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: Dynamic segment reversal with edge optimization\n    for _ in range(2):  # Apply two consecutive operations\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n        # Dynamic edge reordering: swap edges based on objective improvement\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i]]) < \\\n           (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[j+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6895216251264553,
            0.21108996868133545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: Dynamic segment reversal with edge optimization\n    for _ in range(2):  # Apply two consecutive operations\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n        # Dynamic edge reordering: swap edges based on objective improvement\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if (distance_matrix_1[new_solution[i-1]][new_solution[j]] + distance_matrix_1[new_solution[j]][new_solution[i]]) < \\\n           (distance_matrix_1[new_solution[i-1]][new_solution[i]] + distance_matrix_1[new_solution[j]][new_solution[j+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid crossover and mutation operator that combines segments from multiple solutions while ensuring feasibility through a novel repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = 0\n    else:\n        # Select two solutions with the best combined objective values\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined = normalized.sum(axis=1)\n        selected_idx = np.argmin(combined)\n\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = np.zeros(n, dtype=int)\n    unvisited = set(range(n))\n\n    # Hybrid crossover-mutation: combine segments from multiple solutions\n    for i in range(n):\n        if np.random.rand() < 0.7:  # 70% chance to take from base solution\n            candidate = base_solution[i]\n        else:  # 30% chance to take from another solution\n            other_idx = np.random.choice(len(archive))\n            candidate = archive[other_idx][0][i]\n\n        if candidate in unvisited:\n            new_solution[i] = candidate\n            unvisited.remove(candidate)\n        else:\n            # Repair mechanism: insert remaining nodes in order\n            for node in unvisited:\n                if node not in new_solution:\n                    new_solution[i] = node\n                    unvisited.remove(node)\n                    break\n\n    # Final check for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if repair fails\n        remaining = list(unvisited)\n        for i in range(n):\n            if new_solution[i] == 0:\n                new_solution[i] = remaining.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.743404434533433,
            2.840844690799713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = 0\n    else:\n        # Select two solutions with the best combined objective values\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        combined = normalized.sum(axis=1)\n        selected_idx = np.argmin(combined)\n\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = np.zeros(n, dtype=int)\n    unvisited = set(range(n))\n\n    # Hybrid crossover-mutation: combine segments from multiple solutions\n    for i in range(n):\n        if np.random.rand() < 0.7:  # 70% chance to take from base solution\n            candidate = base_solution[i]\n        else:  # 30% chance to take from another solution\n            other_idx = np.random.choice(len(archive))\n            candidate = archive[other_idx][0][i]\n\n        if candidate in unvisited:\n            new_solution[i] = candidate\n            unvisited.remove(candidate)\n        else:\n            # Repair mechanism: insert remaining nodes in order\n            for node in unvisited:\n                if node not in new_solution:\n                    new_solution[i] = node\n                    unvisited.remove(node)\n                    break\n\n    # Final check for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if repair fails\n        remaining = list(unvisited)\n        for i in range(n):\n            if new_solution[i] == 0:\n                new_solution[i] = remaining.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel local search heuristic that intelligently selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid edge-swapping and segment-shifting operator to generate a high-quality neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive), p=[1.0/len(archive) for _ in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge-swapping with segment shifting\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Apply edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Apply segment shifting (move a random segment to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while k == l or abs(k - l) < 2:\n        l = np.random.randint(0, n)\n\n    segment = new_solution[min(k, l):max(k, l)]\n    new_solution = np.concatenate([\n        new_solution[:min(k, l)],\n        new_solution[max(k, l):],\n        segment\n    ])\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge-swapping if shifting causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for multi-objective improvement, then applies a hybrid segment-reversal and node-insertion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) > 0:\n        # Normalize objectives and compute a score (lower is better)\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        scores = np.sum(normalized, axis=1)\n        probabilities = np.exp(-scores) / np.sum(np.exp(-scores))\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = np.random.randint(0, len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    # Apply segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if insertion causes duplicates\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9227170985697747,
            0.2592555284500122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) > 0:\n        # Normalize objectives and compute a score (lower is better)\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n        scores = np.sum(normalized, axis=1)\n        probabilities = np.exp(-scores) / np.sum(np.exp(-scores))\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = np.random.randint(0, len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    # Apply segment reversal\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply node insertion\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    while l == k or l == (k + 1) % n:\n        l = np.random.randint(0, n)\n\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to segment reversal if insertion causes duplicates\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel algorithm that selects solutions based on a weighted combination of objective values and applies a hybrid local search combining segment reversal and edge swapping, with feasibility checks to ensure valid tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and apply segment reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge swap between two random edges\n    e, f = sorted(random.sample(range(1, n), 2))\n    new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.833944153593855,
            0.21162033081054688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and apply segment reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge swap between two random edges\n    e, f = sorted(random.sample(range(1, n), 2))\n    new_solution[e], new_solution[f] = new_solution[f], new_solution[e]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel approach that selects solutions based on their diversity and applies a segment-based local search with randomized edge insertions to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_score(sol):\n        obj1, obj2 = sol[1]\n        return abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n\n    selected_solution = max(archive, key=diversity_score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4707902686856162,
            0.24438446760177612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_score(sol):\n        obj1, obj2 = sol[1]\n        return abs(obj1 - obj2) / (obj1 + obj2 + 1e-10)\n\n    selected_solution = max(archive, key=diversity_score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and insert it elsewhere\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - 0.3 * (x[1][0] / distance_matrix_1.sum() + x[1][1] / distance_matrix_2.sum())))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert their order\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Optionally, apply a small 2-opt move with 30% probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8300528704303095,
            0.5817822813987732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - 0.3 * (x[1][0] / distance_matrix_1.sum() + x[1][1] / distance_matrix_2.sum())))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert their order\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Optionally, apply a small 2-opt move with 30% probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a multi-segment reversal strategy with adaptive segment selection to improve both objectives simultaneously while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on objective dominance\n    segments = []\n    for _ in range(3):  # Select 3 segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        segments.append((a, b))\n\n    # Sort segments by their potential impact\n    segments.sort(key=lambda seg: (distance_matrix_1[new_solution[seg[0]-1], new_solution[seg[1]-1]] +\n                                   distance_matrix_2[new_solution[seg[0]-1], new_solution[seg[1]-1]]))\n\n    # Apply multi-segment reversal\n    for a, b in segments[:2]:  # Use top 2 segments\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a single segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8664939911065104,
            0.2230127453804016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on objective dominance\n    segments = []\n    for _ in range(3):  # Select 3 segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        segments.append((a, b))\n\n    # Sort segments by their potential impact\n    segments.sort(key=lambda seg: (distance_matrix_1[new_solution[seg[0]-1], new_solution[seg[1]-1]] +\n                                   distance_matrix_2[new_solution[seg[0]-1], new_solution[seg[1]-1]]))\n\n    # Apply multi-segment reversal\n    for a, b in segments[:2]:  # Use top 2 segments\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a single segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search approach that combines a multi-segment inversion operator with a guided edge insertion strategy to explore diverse solution spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: Multi-segment inversion with edge insertion\n    segments = sorted(random.sample(range(1, n-1), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge insertion: Insert a random edge from another segment\n    c, d = random.sample(range(1, n-1), 2)\n    if c > d:\n        c, d = d, c\n    if d - c > 1:\n        edge = random.choice([(c, c+1), (d-1, d)])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_solution[edge[0]:edge[1]+1],\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by removing duplicates and appending missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n",
        "score": [
            -0.9229659729632512,
            1.5458438992500305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: Multi-segment inversion with edge insertion\n    segments = sorted(random.sample(range(1, n-1), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert middle segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge insertion: Insert a random edge from another segment\n    c, d = random.sample(range(1, n-1), 2)\n    if c > d:\n        c, d = d, c\n    if d - c > 1:\n        edge = random.choice([(c, c+1), (d-1, d)])\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            new_solution[edge[0]:edge[1]+1],\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by removing duplicates and appending missing nodes\n        missing = list(set(range(n)) - set(new_solution))\n        new_solution = np.concatenate([new_solution, missing])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objective values, then applies a hybrid local search combining segment reversals and edge swaps to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge swap with probability 0.3\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8666564050399996,
            0.21355587244033813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge swap with probability 0.3\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel multi-segment inversion operator that selectively reverses segments to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n        # Select solution with best balance of objective and crowding\n        selected_idx = np.argmax([(obj[0] + obj[1]) / 2 + crowding[i] for i, (_, obj) in enumerate(archive)])\n        selected_solution = archive[selected_idx][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel multi-segment inversion operator\n    # Select up to 3 non-overlapping segments and invert them\n    segments = []\n    remaining_indices = list(range(1, n))\n    random.shuffle(remaining_indices)\n\n    # Select up to 3 segments\n    for _ in range(min(3, len(remaining_indices) // 2)):\n        if len(remaining_indices) < 2:\n            break\n        a, b = sorted(random.sample(remaining_indices, 2))\n        segments.append((a, b))\n        remaining_indices = [x for x in remaining_indices if x < a or x > b]\n\n    # Sort segments by length (longest first) to prioritize larger improvements\n    segments.sort(key=lambda x: -(x[1] - x[0]))\n\n    # Apply inversions\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to single-segment inversion\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.728014527289707,
            0.34249407052993774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n\n        # Select solution with best balance of objective and crowding\n        selected_idx = np.argmax([(obj[0] + obj[1]) / 2 + crowding[i] for i, (_, obj) in enumerate(archive)])\n        selected_solution = archive[selected_idx][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel multi-segment inversion operator\n    # Select up to 3 non-overlapping segments and invert them\n    segments = []\n    remaining_indices = list(range(1, n))\n    random.shuffle(remaining_indices)\n\n    # Select up to 3 segments\n    for _ in range(min(3, len(remaining_indices) // 2)):\n        if len(remaining_indices) < 2:\n            break\n        a, b = sorted(random.sample(remaining_indices, 2))\n        segments.append((a, b))\n        remaining_indices = [x for x in remaining_indices if x < a or x > b]\n\n    # Sort segments by length (longest first) to prioritize larger improvements\n    segments.sort(key=lambda x: -(x[1] - x[0]))\n\n    # Apply inversions\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to single-segment inversion\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = [(sol, (obj[0] / np.max([o[0] for _, o in archive]), obj[1] / np.max([o[1] for _, o in archive]))) for sol, obj in archive]\n    selected_solution = max(normalized_scores, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9268413963861658,
            2.8843957781791687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_scores = [(sol, (obj[0] / np.max([o[0] for _, o in archive]), obj[1] / np.max([o[1] for _, o in archive]))) for sol, obj in archive]\n    selected_solution = max(normalized_scores, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-recombination: Divide the tour into k segments and recombine them in a random order\n    k = random.randint(3, min(5, n // 2))\n    segment_length = n // k\n    segments = [new_solution[i*segment_length : (i+1)*segment_length] for i in range(k)]\n\n    # Recombine segments in a random non-sequential order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple segment reversal to restore feasibility\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8091935550356694,
            0.17294830083847046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-recombination: Divide the tour into k segments and recombine them in a random order\n    k = random.randint(3, min(5, n // 2))\n    segment_length = n // k\n    segments = [new_solution[i*segment_length : (i+1)*segment_length] for i in range(k)]\n\n    # Recombine segments in a random non-sequential order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple segment reversal to restore feasibility\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-recombination: Divide the tour into k segments and recombine them in a random order\n    k = random.randint(3, min(5, n // 2))\n    segment_length = n // k\n    segments = [new_solution[i*segment_length : (i+1)*segment_length] for i in range(k)]\n\n    # Recombine segments in a random non-sequential order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple segment reversal to restore feasibility\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8091935550356694,
            0.17294830083847046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment-recombination: Divide the tour into k segments and recombine them in a random order\n    k = random.randint(3, min(5, n // 2))\n    segment_length = n // k\n    segments = [new_solution[i*segment_length : (i+1)*segment_length] for i in range(k)]\n\n    # Recombine segments in a random non-sequential order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple segment reversal to restore feasibility\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a promising solution from the archive by evaluating both objectives, then applies a novel segment-based local search that combines partial segment reversal with adaptive edge insertion to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and a position to insert it elsewhere\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.delete(new_solution, slice(a, b))\n    insert_pos = random.randint(1, n - len(segment))\n\n    # Insert the segment at the new position\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Apply adaptive reversal based on distance matrices\n    for i in range(1, n - 1):\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two adjacent nodes\n        i = random.randint(1, n - 1)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7756050330644968,
            0.2808592915534973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and a position to insert it elsewhere\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.delete(new_solution, slice(a, b))\n    insert_pos = random.randint(1, n - len(segment))\n\n    # Insert the segment at the new position\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Apply adaptive reversal based on distance matrices\n    for i in range(1, n - 1):\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two adjacent nodes\n        i = random.randint(1, n - 1)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search that combines segment reversal with a novel edge reordering strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [x[1][0] + x[1][1] for x in archive]\n    weights = [1/(cost + 1e-6) for cost in total_costs]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n\n    # Novel edge reordering: rotate segment and reinsert at random position\n    rotated_segment = np.roll(segment, random.randint(0, len(segment)-1))\n    new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9308337807057209,
            0.2820695638656616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [x[1][0] + x[1][1] for x in archive]\n    weights = [1/(cost + 1e-6) for cost in total_costs]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n\n    # Novel edge reordering: rotate segment and reinsert at random position\n    rotated_segment = np.roll(segment, random.randint(0, len(segment)-1))\n    new_solution = np.concatenate([new_solution[:a], rotated_segment, new_solution[b:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{Select a solution from the archive using a novel dominance-based selection and apply a multi-segment inversion strategy that reverses multiple non-overlapping segments to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n    non_dominated = [s for i, s in enumerate(archive) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = archive\n    selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Multi-segment inversion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n    num_segments = random.randint(2, min(4, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(1, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segments.append((start, end))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    for seg in segments:\n        if not merged_segments or seg[0] > merged_segments[-1][1]:\n            merged_segments.append(seg)\n        else:\n            new_start = merged_segments[-1][0]\n            new_end = max(merged_segments[-1][1], seg[1])\n            merged_segments[-1] = (new_start, new_end)\n\n    # Apply inversions\n    for start, end in reversed(merged_segments):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler 2-opt move if inversion causes duplicates\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7894412396024293,
            0.2681303024291992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n    non_dominated = [s for i, s in enumerate(archive) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = archive\n    selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Multi-segment inversion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n    num_segments = random.randint(2, min(4, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(1, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segments.append((start, end))\n\n    # Sort segments to avoid overlaps\n    segments.sort()\n    merged_segments = []\n    for seg in segments:\n        if not merged_segments or seg[0] > merged_segments[-1][1]:\n            merged_segments.append(seg)\n        else:\n            new_start = merged_segments[-1][0]\n            new_end = max(merged_segments[-1][1], seg[1])\n            merged_segments[-1] = (new_start, new_end)\n\n    # Apply inversions\n    for start, end in reversed(merged_segments):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler 2-opt move if inversion causes duplicates\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives with randomized weights, then applies a hybrid local search combining segment reversal and edge reordering while ensuring feasibility through validation and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weights /= np.sum(weights)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Apply segment reversal and edge reordering\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9392559366529685,
            0.23319149017333984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    weights /= np.sum(weights)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Apply segment reversal and edge reordering\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The new algorithm will select a solution from the archive based on a combination of its objective values and the diversity of its segments, then apply a novel segment-based crossover operator that combines segments from multiple solutions to create a new neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + len(set(x[0][1:-1])) / len(x[0])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover with multiple solutions\n    if len(archive) > 1:\n        other_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], selected_solution)]).copy()\n        segments = sorted(random.sample(range(1, n), 2))\n        a, b = segments[0], segments[1]\n\n        # Replace a segment from the selected solution with a segment from another solution\n        new_solution[a:b] = other_solution[a:b]\n\n        # Ensure feasibility by checking for duplicates and fixing if needed\n        if len(np.unique(new_solution)) != n:\n            # If invalid, apply a segment reversal to fix\n            c, d = sorted(random.sample(range(1, n), 2))\n            new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # If archive has only one solution, apply a segment reversal\n    else:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.7948056867842176,
            0.4984726309776306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + len(set(x[0][1:-1])) / len(x[0])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover with multiple solutions\n    if len(archive) > 1:\n        other_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], selected_solution)]).copy()\n        segments = sorted(random.sample(range(1, n), 2))\n        a, b = segments[0], segments[1]\n\n        # Replace a segment from the selected solution with a segment from another solution\n        new_solution[a:b] = other_solution[a:b]\n\n        # Ensure feasibility by checking for duplicates and fixing if needed\n        if len(np.unique(new_solution)) != n:\n            # If invalid, apply a segment reversal to fix\n            c, d = sorted(random.sample(range(1, n), 2))\n            new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # If archive has only one solution, apply a segment reversal\n    else:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal and edge-swap operations to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment reversal with validation\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Apply segment reversals and edge swaps\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge-swap between segments\n    if b < c:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Revert to a single segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8218473247016715,
            0.20807701349258423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment reversal with validation\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Apply segment reversals and edge swaps\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge-swap between segments\n    if b < c:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # Revert to a single segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to swap (avoiding trivial cases)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9715495012306186,
            0.21160674095153809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to swap (avoiding trivial cases)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct segments to invert and reinsert\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract the three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Invert each segment\n    segment2 = np.flip(segment2)\n    segment3 = np.flip(segment3)\n\n    # Reinsert the segments in a new order (with 66% probability of each permutation)\n    rand = random.random()\n    if rand < 1/3:\n        new_solution = np.concatenate([segment2, segment3, segment1, segment4])\n    elif rand < 2/3:\n        new_solution = np.concatenate([segment3, segment2, segment4, segment1])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple 2-opt move to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9923296829061664,
            0.19733655452728271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct segments to invert and reinsert\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract the three segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Invert each segment\n    segment2 = np.flip(segment2)\n    segment3 = np.flip(segment3)\n\n    # Reinsert the segments in a new order (with 66% probability of each permutation)\n    rand = random.random()\n    if rand < 1/3:\n        new_solution = np.concatenate([segment2, segment3, segment1, segment4])\n    elif rand < 2/3:\n        new_solution = np.concatenate([segment3, segment2, segment4, segment1])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple 2-opt move to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The new algorithm selects a promising solution from the archive by considering both objective values, then applies a novel local search strategy that combines segment reversal with a probabilistic edge insertion heuristic to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: Probabilistic segment reversal with edge insertion\n    for _ in range(2):  # Apply twice for more exploration\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = np.flip(segment)\n\n        # Insert the segment at a random position with probability based on distance improvement\n        insert_pos = random.randint(1, n)\n        if insert_pos > a:\n            insert_pos -= len(segment)\n\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n\n        # Accept if improvement in at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2) or random.random() < 0.2:  # 20% randomness for exploration\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by removing duplicates and filling gaps\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Randomly insert missing nodes at valid positions\n        for node in missing_nodes:\n            pos = random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if necessary\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        # Fill remaining slots with missing nodes (if any)\n        remaining_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(remaining_nodes) > 0:\n            new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.9272594316074109,
            0.14992642402648926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: Probabilistic segment reversal with edge insertion\n    for _ in range(2):  # Apply twice for more exploration\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = np.flip(segment)\n\n        # Insert the segment at a random position with probability based on distance improvement\n        insert_pos = random.randint(1, n)\n        if insert_pos > a:\n            insert_pos -= len(segment)\n\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n\n        # Accept if improvement in at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2) or random.random() < 0.2:  # 20% randomness for exploration\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by removing duplicates and filling gaps\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Randomly insert missing nodes at valid positions\n        for node in missing_nodes:\n            pos = random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if necessary\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        # Fill remaining slots with missing nodes (if any)\n        remaining_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(remaining_nodes) > 0:\n            new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{The new algorithm selects a promising solution from the archive by considering both objective values, then applies a novel local search strategy that combines segment reversal with a probabilistic edge insertion heuristic to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: Probabilistic segment reversal with edge insertion\n    for _ in range(2):  # Apply twice for more exploration\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = np.flip(segment)\n\n        # Insert the segment at a random position with probability based on distance improvement\n        insert_pos = random.randint(1, n)\n        if insert_pos > a:\n            insert_pos -= len(segment)\n\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n\n        # Accept if improvement in at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2) or random.random() < 0.2:  # 20% randomness for exploration\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by removing duplicates and filling gaps\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Randomly insert missing nodes at valid positions\n        for node in missing_nodes:\n            pos = random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if necessary\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        # Fill remaining slots with missing nodes (if any)\n        remaining_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(remaining_nodes) > 0:\n            new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.9272594316074109,
            0.14992642402648926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: Probabilistic segment reversal with edge insertion\n    for _ in range(2):  # Apply twice for more exploration\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = np.flip(segment)\n\n        # Insert the segment at a random position with probability based on distance improvement\n        insert_pos = random.randint(1, n)\n        if insert_pos > a:\n            insert_pos -= len(segment)\n\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[b]]\n\n        # Accept if improvement in at least one objective\n        if (new_cost1 < old_cost1 or new_cost2 < old_cost2) or random.random() < 0.2:  # 20% randomness for exploration\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by removing duplicates and filling gaps\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    if len(missing_nodes) > 0:\n        # Randomly insert missing nodes at valid positions\n        for node in missing_nodes:\n            pos = random.randint(1, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Trim to original length if necessary\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        # Fill remaining slots with missing nodes (if any)\n        remaining_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(remaining_nodes) > 0:\n            new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search operator that combines segment relocation with adaptive segment length and a probabilistic segment reordering strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection with variable segment lengths\n    seg_points = sorted(random.sample(range(1, n), 3))\n    a, b, c = seg_points[0], seg_points[1], seg_points[2]\n\n    # Extract segments with adaptive lengths\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Probabilistic segment reordering with 4 possible configurations\n    rand_val = random.random()\n    if rand_val < 0.25:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    elif rand_val < 0.5:\n        new_solution = np.concatenate([segment4, segment3, segment2, segment1])\n    elif rand_val < 0.75:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Apply a more sophisticated repair mechanism\n        for i in range(1, n):\n            if new_solution[i] in new_solution[:i]:\n                # Find the first missing node and swap\n                missing = set(range(n)) - set(new_solution)\n                if missing:\n                    new_solution[i] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.9166337977271408,
            1.4917507767677307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection with variable segment lengths\n    seg_points = sorted(random.sample(range(1, n), 3))\n    a, b, c = seg_points[0], seg_points[1], seg_points[2]\n\n    # Extract segments with adaptive lengths\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Probabilistic segment reordering with 4 possible configurations\n    rand_val = random.random()\n    if rand_val < 0.25:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    elif rand_val < 0.5:\n        new_solution = np.concatenate([segment4, segment3, segment2, segment1])\n    elif rand_val < 0.75:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Apply a more sophisticated repair mechanism\n        for i in range(1, n):\n            if new_solution[i] in new_solution[:i]:\n                # Find the first missing node and swap\n                missing = set(range(n)) - set(new_solution)\n                if missing:\n                    new_solution[i] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel multi-objective local search algorithm that selects solutions based on a crowding distance metric to identify under-explored regions in the objective space and applies a hybrid 3-segment relocation operator with adaptive segment selection to generate diverse high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n\n    crowding = {}\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding[archive[i][0].tobytes()] = float('inf')\n        else:\n            dist1 = abs(sorted_obj1[i+1][1][0] - sorted_obj1[i-1][1][0])\n            dist2 = abs(sorted_obj2[i+1][1][1] - sorted_obj2[i-1][1][1])\n            crowding[archive[i][0].tobytes()] = dist1 + dist2\n\n    # Select solution with lowest crowding distance (most under-explored)\n    selected_solution = min(archive, key=lambda x: crowding.get(x[0].tobytes(), 0))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on solution quality\n    if random.random() < 0.7:\n        # Select segments based on distance in both objectives\n        total_dist1 = sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(n-1))\n        total_dist2 = sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(n-1))\n\n        # Find segments with high relative distance\n        segments = []\n        for i in range(1, n-1):\n            dist1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]]\n            dist2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]]\n            if (dist1 > total_dist1 * 0.3) or (dist2 > total_dist2 * 0.3):\n                segments.append(i)\n        if len(segments) >= 3:\n            segments = sorted(random.sample(segments, 3))\n        else:\n            segments = sorted(random.sample(range(1, n), 3))\n    else:\n        segments = sorted(random.sample(range(1, n), 3))\n\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create segments and relocate them\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with higher probability of beneficial permutations\n    if random.random() < 0.6:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2, segment3, segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply a more sophisticated repair if needed\n        for i in range(1, n):\n            if new_solution[i] in new_solution[:i]:\n                # Find a node not in current solution\n                missing = set(range(n)) - set(new_solution[:i+1])\n                if missing:\n                    new_solution[i] = random.choice(list(missing))\n\n    return new_solution\n\n",
        "score": [
            -0.6859503474679107,
            0.3297393321990967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n    sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n\n    crowding = {}\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding[archive[i][0].tobytes()] = float('inf')\n        else:\n            dist1 = abs(sorted_obj1[i+1][1][0] - sorted_obj1[i-1][1][0])\n            dist2 = abs(sorted_obj2[i+1][1][1] - sorted_obj2[i-1][1][1])\n            crowding[archive[i][0].tobytes()] = dist1 + dist2\n\n    # Select solution with lowest crowding distance (most under-explored)\n    selected_solution = min(archive, key=lambda x: crowding.get(x[0].tobytes(), 0))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on solution quality\n    if random.random() < 0.7:\n        # Select segments based on distance in both objectives\n        total_dist1 = sum(distance_matrix_1[selected_solution[i], selected_solution[i+1]] for i in range(n-1))\n        total_dist2 = sum(distance_matrix_2[selected_solution[i], selected_solution[i+1]] for i in range(n-1))\n\n        # Find segments with high relative distance\n        segments = []\n        for i in range(1, n-1):\n            dist1 = distance_matrix_1[selected_solution[i-1], selected_solution[i]]\n            dist2 = distance_matrix_2[selected_solution[i-1], selected_solution[i]]\n            if (dist1 > total_dist1 * 0.3) or (dist2 > total_dist2 * 0.3):\n                segments.append(i)\n        if len(segments) >= 3:\n            segments = sorted(random.sample(segments, 3))\n        else:\n            segments = sorted(random.sample(range(1, n), 3))\n    else:\n        segments = sorted(random.sample(range(1, n), 3))\n\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create segments and relocate them\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with higher probability of beneficial permutations\n    if random.random() < 0.6:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2, segment3, segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply a more sophisticated repair if needed\n        for i in range(1, n):\n            if new_solution[i] in new_solution[:i]:\n                # Find a node not in current solution\n                missing = set(range(n)) - set(new_solution[:i+1])\n                if missing:\n                    new_solution[i] = random.choice(list(missing))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel segment relocation strategy that intelligently combines multiple segment reversals and insertions to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective (can be tuned)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment relocation strategy\n    for _ in range(3):  # Apply multiple operations for diversity\n        # Randomly select segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        # Extract and reinsert segments with possible reversal\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        if random.random() > 0.5:\n            segment1 = np.flip(segment1)\n        if random.random() > 0.5:\n            segment2 = np.flip(segment2)\n\n        # Find insertion points and reinsert\n        insert_pos = random.randint(1, n-1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment1,\n            segment2,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates (retain first occurrence)\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    # Ensure full tour coverage\n    missing = set(range(n)) - set(new_solution)\n    if missing:\n        # Insert missing nodes at random positions\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8748211384339193,
            0.27457743883132935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective (can be tuned)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment relocation strategy\n    for _ in range(3):  # Apply multiple operations for diversity\n        # Randomly select segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        # Extract and reinsert segments with possible reversal\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        if random.random() > 0.5:\n            segment1 = np.flip(segment1)\n        if random.random() > 0.5:\n            segment2 = np.flip(segment2)\n\n        # Find insertion points and reinsert\n        insert_pos = random.randint(1, n-1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment1,\n            segment2,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates (retain first occurrence)\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    # Ensure full tour coverage\n    missing = set(range(n)) - set(new_solution)\n    if missing:\n        # Insert missing nodes at random positions\n        for node in missing:\n            pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-crossing strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    while (a < d < b) or (c < b < d):  # Ensure segments don't overlap\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the first segment and reinsert it between the second segment\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple edge swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9707214327532284,
            0.11527574062347412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-crossing strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    while (a < d < b) or (c < b < d):  # Ensure segments don't overlap\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the first segment and reinsert it between the second segment\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple edge swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-crossing strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    while (a < d < b) or (c < b < d):  # Ensure segments don't overlap\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the first segment and reinsert it between the second segment\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple edge swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9707214327532284,
            0.11527574062347412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-crossing strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    while (a < d < b) or (c < b < d):  # Ensure segments don't overlap\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the first segment and reinsert it between the second segment\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple edge swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        # Normalized dominance count (smaller is better)\n        dom_count = sum(1 for s in archive if s[1][0] < obj1 and s[1][1] < obj2)\n        # Crowding distance (larger is better)\n        crowd_dist = np.mean([abs(obj1 - s[1][0]) + abs(obj2 - s[1][1]) for s in archive])\n        return (1 / (1 + dom_count)) * crowd_dist\n\n    # Select solution with highest hybrid score\n    selected_solution = max(archive, key=lambda x: selection_score(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation\n    # Select 2-4 segments based on solution quality\n    num_segments = min(4, max(2, int(np.log(n)) // 2 + 1))\n    segments = sorted(random.sample(range(1, n), num_segments))\n\n    # Split into segments\n    segments_list = []\n    prev = 0\n    for seg in segments:\n        segments_list.append(new_solution[prev:seg])\n        prev = seg\n    segments_list.append(new_solution[prev:])\n\n    # Randomly permute segments with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for better solutions\n        random.shuffle(segments_list)\n    else:\n        # Reverse some segments with lower probability\n        for i in range(len(segments_list)):\n            if random.random() < 0.3:\n                segments_list[i] = segments_list[i][::-1]\n\n    # Recombine segments\n    new_solution = np.concatenate(segments_list)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply 2-opt local improvement to fix\n        i, j = random.sample(range(1, n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7612570271993743,
            5.436814963817596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        # Normalized dominance count (smaller is better)\n        dom_count = sum(1 for s in archive if s[1][0] < obj1 and s[1][1] < obj2)\n        # Crowding distance (larger is better)\n        crowd_dist = np.mean([abs(obj1 - s[1][0]) + abs(obj2 - s[1][1]) for s in archive])\n        return (1 / (1 + dom_count)) * crowd_dist\n\n    # Select solution with highest hybrid score\n    selected_solution = max(archive, key=lambda x: selection_score(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation\n    # Select 2-4 segments based on solution quality\n    num_segments = min(4, max(2, int(np.log(n)) // 2 + 1))\n    segments = sorted(random.sample(range(1, n), num_segments))\n\n    # Split into segments\n    segments_list = []\n    prev = 0\n    for seg in segments:\n        segments_list.append(new_solution[prev:seg])\n        prev = seg\n    segments_list.append(new_solution[prev:])\n\n    # Randomly permute segments with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for better solutions\n        random.shuffle(segments_list)\n    else:\n        # Reverse some segments with lower probability\n        for i in range(len(segments_list)):\n            if random.random() < 0.3:\n                segments_list[i] = segments_list[i][::-1]\n\n    # Recombine segments\n    new_solution = np.concatenate(segments_list)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply 2-opt local improvement to fix\n        i, j = random.sample(range(1, n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A new algorithm that selects solutions based on their dominance in the Pareto front and applies a hybrid local search combining segment reversal with a novel edge-swap strategy, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8246474183560702,
            0.19631046056747437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based inversion and rotation operator\n    # Randomly select a segment and invert it, then rotate the entire solution\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n\n    # Invert the selected segment\n    inverted_segment = segment[::-1]\n\n    # Replace the original segment with the inverted one\n    new_solution[a:b] = inverted_segment\n\n    # Rotate the entire solution by a random amount\n    rotation = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[rotation:], new_solution[:rotation]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0028473727962068,
            1.4656519889831543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based inversion and rotation operator\n    # Randomly select a segment and invert it, then rotate the entire solution\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n\n    # Invert the selected segment\n    inverted_segment = segment[::-1]\n\n    # Replace the original segment with the inverted one\n    new_solution[a:b] = inverted_segment\n\n    # Rotate the entire solution by a random amount\n    rotation = random.randint(1, n-1)\n    new_solution = np.concatenate([new_solution[rotation:], new_solution[:rotation]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid score combining objective values and dominance relationships, then applies a multi-segment relocation operator with probabilistic segment reordering to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: multi-segment relocation with probabilistic inversion\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Apply probabilistic segment reordering with 3 possible configurations\n    if random.random() < 0.33:\n        new_solution = np.concatenate([segment3, segment2, segment1, segment4])\n    elif random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment2, segment4, segment3, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing with reverse segment\n    if len(np.unique(new_solution)) != n:\n        # Reverse the middle segment to fix duplicates\n        middle_segment = new_solution[a:b]\n        new_solution[a:b] = middle_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9937367226514271,
            1.4554467797279358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: multi-segment relocation with probabilistic inversion\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Apply probabilistic segment reordering with 3 possible configurations\n    if random.random() < 0.33:\n        new_solution = np.concatenate([segment3, segment2, segment1, segment4])\n    elif random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment2, segment4, segment3, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing with reverse segment\n    if len(np.unique(new_solution)) != n:\n        # Reverse the middle segment to fix duplicates\n        middle_segment = new_solution[a:b]\n        new_solution[a:b] = middle_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{Select a solution from the archive based on its objective values and apply a novel multi-segment inversion and reordering operator that combines segment reversals and cyclic permutations to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - 0.1 * sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion and reordering\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Reverse segments and reorder cyclically\n    segment1 = np.flip(new_solution[:a])\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = np.flip(new_solution[c:])\n\n    # Reorder segments in a cyclic permutation\n    new_solution = np.concatenate([segment2, segment4, segment1, segment3])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random cyclic shift\n        shift = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            -0.8015528629527144,
            0.24454522132873535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - 0.1 * sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion and reordering\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Reverse segments and reorder cyclically\n    segment1 = np.flip(new_solution[:a])\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = np.flip(new_solution[c:])\n\n    # Reorder segments in a cyclic permutation\n    new_solution = np.concatenate([segment2, segment4, segment1, segment3])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random cyclic shift\n        shift = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge reordering, with a fallback to a simpler move if the solution becomes invalid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    if n > 3:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(1, n-3)\n        seg1_end = random.randint(seg1_start+1, n-2)\n        seg2_start = random.randint(1, n-2)\n        seg2_end = random.randint(seg2_start+1, n-1)\n\n        # Reverse segments and reorder edges\n        new_solution[seg1_start:seg1_end] = np.flip(new_solution[seg1_start:seg1_end])\n        new_solution[seg2_start:seg2_end] = np.flip(new_solution[seg2_start:seg2_end])\n\n        # Reconnect segments with a novel edge swap\n        if random.random() < 0.5:\n            # Swap edges between segments\n            temp = new_solution[seg1_end]\n            new_solution[seg1_end] = new_solution[seg2_end]\n            new_solution[seg2_end] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9412309109189164,
            0.2303154468536377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    if n > 3:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(1, n-3)\n        seg1_end = random.randint(seg1_start+1, n-2)\n        seg2_start = random.randint(1, n-2)\n        seg2_end = random.randint(seg2_start+1, n-1)\n\n        # Reverse segments and reorder edges\n        new_solution[seg1_start:seg1_end] = np.flip(new_solution[seg1_start:seg1_end])\n        new_solution[seg2_start:seg2_end] = np.flip(new_solution[seg2_start:seg2_end])\n\n        # Reconnect segments with a novel edge swap\n        if random.random() < 0.5:\n            # Swap edges between segments\n            temp = new_solution[seg1_end]\n            new_solution[seg1_end] = new_solution[seg2_end]\n            new_solution[seg2_end] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(sol):\n        obj1, obj2 = sol[1]\n        dominated = sum(1 for s in archive if s[1][0] <= obj1 and s[1][1] <= obj2 and (s[1][0] < obj1 or s[1][1] < obj2))\n        crowding = (obj1 + obj2) * (1 + dominated)\n        return crowding\n\n    selected_solution = max(archive, key=crowding_distance)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment selection and reordering\n    num_segments = random.randint(2, min(4, n//2))\n    segments = sorted(random.sample(range(1, n), num_segments))\n\n    # Split into segments\n    segment_list = [new_solution[:segments[0]]]\n    for i in range(num_segments-1):\n        segment_list.append(new_solution[segments[i]:segments[i+1]])\n    segment_list.append(new_solution[segments[-1]:])\n\n    # Reorder segments with probability based on segment size\n    weights = [len(seg) for seg in segment_list]\n    reordered = random.choices(segment_list, weights=weights, k=num_segments)\n    new_solution = np.concatenate(reordered)\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Apply a 3-opt repair\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9008357434450347,
            1.1585018634796143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(sol):\n        obj1, obj2 = sol[1]\n        dominated = sum(1 for s in archive if s[1][0] <= obj1 and s[1][1] <= obj2 and (s[1][0] < obj1 or s[1][1] < obj2))\n        crowding = (obj1 + obj2) * (1 + dominated)\n        return crowding\n\n    selected_solution = max(archive, key=crowding_distance)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment selection and reordering\n    num_segments = random.randint(2, min(4, n//2))\n    segments = sorted(random.sample(range(1, n), num_segments))\n\n    # Split into segments\n    segment_list = [new_solution[:segments[0]]]\n    for i in range(num_segments-1):\n        segment_list.append(new_solution[segments[i]:segments[i+1]])\n    segment_list.append(new_solution[segments[-1]:])\n\n    # Reorder segments with probability based on segment size\n    weights = [len(seg) for seg in segment_list]\n    reordered = random.choices(segment_list, weights=weights, k=num_segments)\n    new_solution = np.concatenate(reordered)\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Apply a 3-opt repair\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n\n    # Cluster nodes into groups based on proximity in both objective spaces\n    clusters = []\n    current_cluster = [selected_solution[0]]\n    for i in range(1, n):\n        node = selected_solution[i]\n        last_node = current_cluster[-1]\n        # Check if the node is close to the last node in the current cluster in both spaces\n        if (distance_matrix_1[last_node, node] < np.mean(distance_matrix_1) * 0.5 and\n            distance_matrix_2[last_node, node] < np.mean(distance_matrix_2) * 0.5):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Randomly reorder clusters to create a new solution\n    new_solution = []\n    for cluster in random.sample(clusters, len(clusters)):\n        new_solution.extend(cluster)\n\n    # Ensure feasibility by checking for duplicates (should not occur due to cluster construction)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if clusters fail\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8362211139114943,
            0.3476995825767517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n\n    # Cluster nodes into groups based on proximity in both objective spaces\n    clusters = []\n    current_cluster = [selected_solution[0]]\n    for i in range(1, n):\n        node = selected_solution[i]\n        last_node = current_cluster[-1]\n        # Check if the node is close to the last node in the current cluster in both spaces\n        if (distance_matrix_1[last_node, node] < np.mean(distance_matrix_1) * 0.5 and\n            distance_matrix_2[last_node, node] < np.mean(distance_matrix_2) * 0.5):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Randomly reorder clusters to create a new solution\n    new_solution = []\n    for cluster in random.sample(clusters, len(clusters)):\n        new_solution.extend(cluster)\n\n    # Ensure feasibility by checking for duplicates (should not occur due to cluster construction)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if clusters fail\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives, where weights are dynamically adjusted based on the relative improvements of solutions, and applies a hybrid local search combining segment reversal and edge insertion to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives to compare relative improvements\n        obj1 = [x[1][0] for x in archive]\n        obj2 = [x[1][1] for x in archive]\n        min_obj1, max_obj1 = min(obj1), max(obj1)\n        min_obj2, max_obj2 = min(obj2), max(obj2)\n\n        # Calculate improvement scores (higher is better)\n        imp1 = [(max_obj1 - o) / (max_obj1 - min_obj1 + 1e-9) for o in obj1]\n        imp2 = [(max_obj2 - o) / (max_obj2 - min_obj2 + 1e-9) for o in obj2]\n\n        # Weighted selection based on improvement potential\n        weights = [0.7 * imp1[i] + 0.3 * imp2[i] for i in range(len(archive))]\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    else:\n        selected_idx = 0\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(random.sample(range(1, n), 2))\n    if i + 1 < j:\n        edge = new_solution[i:i+2]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+2:j], edge, new_solution[j:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8730472653439945,
            0.21437925100326538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives to compare relative improvements\n        obj1 = [x[1][0] for x in archive]\n        obj2 = [x[1][1] for x in archive]\n        min_obj1, max_obj1 = min(obj1), max(obj1)\n        min_obj2, max_obj2 = min(obj2), max(obj2)\n\n        # Calculate improvement scores (higher is better)\n        imp1 = [(max_obj1 - o) / (max_obj1 - min_obj1 + 1e-9) for o in obj1]\n        imp2 = [(max_obj2 - o) / (max_obj2 - min_obj2 + 1e-9) for o in obj2]\n\n        # Weighted selection based on improvement potential\n        weights = [0.7 * imp1[i] + 0.3 * imp2[i] for i in range(len(archive))]\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    else:\n        selected_idx = 0\n\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal + edge insertion\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(random.sample(range(1, n), 2))\n    if i + 1 < j:\n        edge = new_solution[i:i+2]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+2:j], edge, new_solution[j:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and a novel edge-swap strategy, ensuring feasibility through validation and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    # Randomly select two segments and reverse them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply a novel edge-swap: swap edges between segments\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.79152881768963,
            0.1984415054321289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    # Randomly select two segments and reverse them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply a novel edge-swap: swap edges between segments\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments for reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal with edge insertion\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Randomly insert a node from one segment into another\n    if random.random() < 0.5 and len(segment1) > 1 and len(segment2) > 1:\n        node_to_insert = segment1[0]\n        insert_pos = random.randint(0, len(segment2) - 1)\n        new_solution[c + insert_pos] = node_to_insert\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8867654197271378,
            0.14207643270492554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments for reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal with edge insertion\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Randomly insert a node from one segment into another\n    if random.random() < 0.5 and len(segment1) > 1 and len(segment2) > 1:\n        node_to_insert = segment1[0]\n        insert_pos = random.randint(0, len(segment2) - 1)\n        new_solution[c + insert_pos] = node_to_insert\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on a weighted objective score, then applies a combination of segment reversal and edge reordering to generate high-quality neighbors while ensuring feasibility through validation checks and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge reordering\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to manipulate\n    points = sorted(random.sample(range(1, n), 3))\n\n    # Apply segment reversal and edge reordering\n    new_solution[points[0]:points[1]] = np.flip(new_solution[points[0]:points[1]])\n    new_solution[points[1]:points[2]] = np.roll(new_solution[points[1]:points[2]], 1)\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler 2-opt move as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8363183971414339,
            0.22155308723449707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge reordering\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to manipulate\n    points = sorted(random.sample(range(1, n), 3))\n\n    # Apply segment reversal and edge reordering\n    new_solution[points[0]:points[1]] = np.flip(new_solution[points[0]:points[1]])\n    new_solution[points[1]:points[2]] = np.roll(new_solution[points[1]:points[2]], 1)\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler 2-opt move as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that balances objective values and diversity, then applies a novel multi-crossover operator that combines segments from multiple solutions to create a high-quality neighbor while ensuring feasibility through a sophisticated repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel multi-crossover operator\n    # Select 3 random non-consecutive segments and combine them in a new order\n    points = sorted(random.sample(range(1, n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Create segments\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:]\n\n    # Combine segments in a new order (with 66% probability for each permutation)\n    rand_val = random.random()\n    if rand_val < 0.33:\n        new_solution = np.concatenate([seg3, seg1, seg4, seg2])\n    elif rand_val < 0.66:\n        new_solution = np.concatenate([seg2, seg4, seg1, seg3])\n    else:\n        new_solution = np.concatenate([seg4, seg2, seg3, seg1])\n\n    # Repair mechanism: ensure all nodes are present and in correct order\n    missing = set(range(n)) - set(new_solution)\n    if missing:\n        # Insert missing nodes at random positions\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a node shuffle to fix\n        np.random.shuffle(new_solution[1:-1])\n\n    return new_solution\n\n",
        "score": [
            -0.8556350409620411,
            1.4622709155082703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel multi-crossover operator\n    # Select 3 random non-consecutive segments and combine them in a new order\n    points = sorted(random.sample(range(1, n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Create segments\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:]\n\n    # Combine segments in a new order (with 66% probability for each permutation)\n    rand_val = random.random()\n    if rand_val < 0.33:\n        new_solution = np.concatenate([seg3, seg1, seg4, seg2])\n    elif rand_val < 0.66:\n        new_solution = np.concatenate([seg2, seg4, seg1, seg3])\n    else:\n        new_solution = np.concatenate([seg4, seg2, seg3, seg1])\n\n    # Repair mechanism: ensure all nodes are present and in correct order\n    missing = set(range(n)) - set(new_solution)\n    if missing:\n        # Insert missing nodes at random positions\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a node shuffle to fix\n        np.random.shuffle(new_solution[1:-1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objective values, then applies a multi-segment inversion strategy with adaptive segment size selection to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//2))\n    segments = sorted(random.sample(range(1, n-1), num_segments))\n\n    for i in range(0, len(segments), 2):\n        start = segments[i]\n        end = segments[i+1] if i+1 < len(segments) else n-1\n        if start < end:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a single segment inversion as fallback\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.9704343109415268,
            0.23023176193237305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion with adaptive segment sizes\n    num_segments = random.randint(2, min(4, n//2))\n    segments = sorted(random.sample(range(1, n-1), num_segments))\n\n    for i in range(0, len(segments), 2):\n        start = segments[i]\n        end = segments[i+1] if i+1 < len(segments) else n-1\n        if start < end:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a single segment inversion as fallback\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high average objective values, then applies a novel segment-based local search that combines multiple segment reversals and edge swaps to explore diverse neighborhoods while ensuring feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    # Randomly select three segments and perform a combination of reversals and edge swaps\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Reverse the first segment\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Swap edges between the second and third segments\n    if b < c:\n        temp = new_solution[b:c].copy()\n        new_solution[b:c] = np.flip(temp)\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9087962648947917,
            0.20579004287719727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    # Randomly select three segments and perform a combination of reversals and edge swaps\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Reverse the first segment\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Swap edges between the second and third segments\n    if b < c:\n        temp = new_solution[b:c].copy()\n        new_solution[b:c] = np.flip(temp)\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{Select a solution from the archive that has high potential for improvement based on its dominance count and apply a novel multi-segment inversion operator that reverses non-overlapping segments to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 non-overlapping segments and invert each\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert three non-overlapping segments\n    new_solution[:a] = np.flip(new_solution[:a])\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple 2-opt move to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8935583911609699,
            1.480496346950531
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 non-overlapping segments and invert each\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert three non-overlapping segments\n    new_solution[:a] = np.flip(new_solution[:a])\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple 2-opt move to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining segment reversal and a novel edge-reconnection strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 - (i / len(archive)) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid local search: segment reversal with edge reconnection\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments and reconnect edges\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Edge reconnection: swap edges between segments if beneficial\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8660242793588018,
            0.22449404001235962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 - (i / len(archive)) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid local search: segment reversal with edge reconnection\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments and reconnect edges\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Edge reconnection: swap edges between segments if beneficial\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions with high potential for improvement by combining edge-swap operations with a dynamic selection of segments based on their objective-space contributions, while ensuring feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment selection based on objective-space contributions\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Novel hybrid operation: reverse segments and swap edges based on objective-space distances\n    if random.random() < 0.5:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        # Edge swap based on distance in both spaces\n        if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] < \\\n           distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n            new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply a simpler edge reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9565245520089959,
            0.20046979188919067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment selection based on objective-space contributions\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Novel hybrid operation: reverse segments and swap edges based on objective-space distances\n    if random.random() < 0.5:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        # Edge swap based on distance in both spaces\n        if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] < \\\n           distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n            new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply a simpler edge reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct segments to cross and mutate\n    a, b, c, d, e, f = sorted(random.sample(range(1, n), 6))\n\n    # Extract three segments from the solution\n    segment1 = selected_solution[a:b]\n    segment2 = selected_solution[c:d]\n    segment3 = selected_solution[e:f]\n\n    # Apply a novel segment-wise crossover and mutation strategy\n    # Combine segments in a non-linear order and apply cyclic shifts\n    combined = np.concatenate([segment1, segment2, segment3])\n    np.random.shuffle(combined)\n\n    # Insert the combined segments back into the solution\n    new_solution[a:b] = combined[:(b-a)]\n    new_solution[c:d] = combined[(b-a):(b-a)+(d-c)]\n    new_solution[e:f] = combined[(b-a)+(d-c):]\n\n    # Apply a cyclic shift to the entire solution to ensure diversity\n    shift = random.randint(1, n-1)\n    new_solution = np.roll(new_solution, shift)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.644196963864198,
            0.20320898294448853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct segments to cross and mutate\n    a, b, c, d, e, f = sorted(random.sample(range(1, n), 6))\n\n    # Extract three segments from the solution\n    segment1 = selected_solution[a:b]\n    segment2 = selected_solution[c:d]\n    segment3 = selected_solution[e:f]\n\n    # Apply a novel segment-wise crossover and mutation strategy\n    # Combine segments in a non-linear order and apply cyclic shifts\n    combined = np.concatenate([segment1, segment2, segment3])\n    np.random.shuffle(combined)\n\n    # Insert the combined segments back into the solution\n    new_solution[a:b] = combined[:(b-a)]\n    new_solution[c:d] = combined[(b-a):(b-a)+(d-c)]\n    new_solution[e:f] = combined[(b-a)+(d-c):]\n\n    # Apply a cyclic shift to the entire solution to ensure diversity\n    shift = random.randint(1, n-1)\n    new_solution = np.roll(new_solution, shift)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The new algorithm will select a solution from the archive using a non-uniform probability based on the dominance rank of solutions, then apply a novel \"segment rotation\" operator that rotates segments of the tour by a random angle while ensuring feasibility through careful edge reconnection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    ranks = {sol[0].tobytes(): i for i, sol in enumerate(sorted_solutions)}\n    selected = random.choices(\n        [sol[0] for sol in archive],\n        weights=[1/(ranks[sol[0].tobytes()]+1) for sol in archive]\n    )[0].copy()\n\n    # Novel segment rotation operator\n    n = len(selected)\n    new_solution = selected.copy()\n    k = random.randint(2, min(5, n//2))  # Segment size\n    start = random.randint(0, n-k)\n    segment = new_solution[start:start+k]\n\n    # Rotate segment by random angle (simulated by reordering)\n    rotated = np.roll(segment, random.randint(1, k-1))\n\n    # Reconnect edges while maintaining feasibility\n    if start > 0:\n        new_solution[start] = rotated[0]\n    if start + k < n:\n        new_solution[start+k-1] = rotated[-1]\n\n    # Ensure no duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8261459495561673,
            0.10340994596481323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    ranks = {sol[0].tobytes(): i for i, sol in enumerate(sorted_solutions)}\n    selected = random.choices(\n        [sol[0] for sol in archive],\n        weights=[1/(ranks[sol[0].tobytes()]+1) for sol in archive]\n    )[0].copy()\n\n    # Novel segment rotation operator\n    n = len(selected)\n    new_solution = selected.copy()\n    k = random.randint(2, min(5, n//2))  # Segment size\n    start = random.randint(0, n-k)\n    segment = new_solution[start:start+k]\n\n    # Rotate segment by random angle (simulated by reordering)\n    rotated = np.roll(segment, random.randint(1, k-1))\n\n    # Reconnect edges while maintaining feasibility\n    if start > 0:\n        new_solution[start] = rotated[0]\n    if start + k < n:\n        new_solution[start+k-1] = rotated[-1]\n\n    # Ensure no duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The new algorithm will select a solution from the archive using a non-uniform probability based on the dominance rank of solutions, then apply a novel \"segment rotation\" operator that rotates segments of the tour by a random angle while ensuring feasibility through careful edge reconnection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    ranks = {sol[0].tobytes(): i for i, sol in enumerate(sorted_solutions)}\n    selected = random.choices(\n        [sol[0] for sol in archive],\n        weights=[1/(ranks[sol[0].tobytes()]+1) for sol in archive]\n    )[0].copy()\n\n    # Novel segment rotation operator\n    n = len(selected)\n    new_solution = selected.copy()\n    k = random.randint(2, min(5, n//2))  # Segment size\n    start = random.randint(0, n-k)\n    segment = new_solution[start:start+k]\n\n    # Rotate segment by random angle (simulated by reordering)\n    rotated = np.roll(segment, random.randint(1, k-1))\n\n    # Reconnect edges while maintaining feasibility\n    if start > 0:\n        new_solution[start] = rotated[0]\n    if start + k < n:\n        new_solution[start+k-1] = rotated[-1]\n\n    # Ensure no duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8261459495561673,
            0.10340994596481323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    ranks = {sol[0].tobytes(): i for i, sol in enumerate(sorted_solutions)}\n    selected = random.choices(\n        [sol[0] for sol in archive],\n        weights=[1/(ranks[sol[0].tobytes()]+1) for sol in archive]\n    )[0].copy()\n\n    # Novel segment rotation operator\n    n = len(selected)\n    new_solution = selected.copy()\n    k = random.randint(2, min(5, n//2))  # Segment size\n    start = random.randint(0, n-k)\n    segment = new_solution[start:start+k]\n\n    # Rotate segment by random angle (simulated by reordering)\n    rotated = np.roll(segment, random.randint(1, k-1))\n\n    # Reconnect edges while maintaining feasibility\n    if start > 0:\n        new_solution[start] = rotated[0]\n    if start + k < n:\n        new_solution[start+k-1] = rotated[-1]\n\n    # Ensure no duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert and rotate\n    a, b = sorted(random.sample(range(1, n), 2))\n\n    # Invert the selected segment and rotate it by a random amount\n    segment = new_solution[a:b]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b] = np.flip(rotated_segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7023472657213212,
            0.3030772805213928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert and rotate\n    a, b = sorted(random.sample(range(1, n), 2))\n\n    # Invert the selected segment and rotate it by a random amount\n    segment = new_solution[a:b]\n    rotation = random.randint(1, len(segment)-1) if len(segment) > 1 else 0\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b] = np.flip(rotated_segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]) * 0.5))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation with dynamic segment selection\n    num_segments = random.choice([2, 3, 4])\n    segments = sorted(random.sample(range(1, n), num_segments - 1))\n\n    # Create segments and store them\n    segments_list = []\n    prev = 0\n    for seg in segments:\n        segments_list.append(new_solution[prev:seg])\n        prev = seg\n    segments_list.append(new_solution[prev:])\n\n    # Shuffle segments with probability based on their quality\n    if random.random() < 0.7:\n        random.shuffle(segments_list)\n\n    # Recombine segments with adaptive order\n    new_solution = np.concatenate(segments_list)\n\n    # Apply local optimization with weighted distance consideration\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.960267881614195,
            1.5785232782363892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]) * 0.5))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation with dynamic segment selection\n    num_segments = random.choice([2, 3, 4])\n    segments = sorted(random.sample(range(1, n), num_segments - 1))\n\n    # Create segments and store them\n    segments_list = []\n    prev = 0\n    for seg in segments:\n        segments_list.append(new_solution[prev:seg])\n        prev = seg\n    segments_list.append(new_solution[prev:])\n\n    # Shuffle segments with probability based on their quality\n    if random.random() < 0.7:\n        random.shuffle(segments_list)\n\n    # Recombine segments with adaptive order\n    new_solution = np.concatenate(segments_list)\n\n    # Apply local optimization with weighted distance consideration\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover: randomly select a segment and insert it in a different position\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Local refinement: apply a limited number of node swaps to improve the solution\n    for _ in range(3):\n        i, j = random.sample(range(1, n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8305534332830945,
            0.23361551761627197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover: randomly select a segment and insert it in a different position\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Local refinement: apply a limited number of node swaps to improve the solution\n    for _ in range(3):\n        i, j = random.sample(range(1, n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance and diversity, then applies a novel multi-segment crossover and mutation operator to generate a neighbor solution while ensuring feasibility by validating and repairing the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment crossover and mutation\n    # Randomly select 3 distinct segments and recombine them with mutation\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with probabilistic order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment2, segment3])\n\n    # Apply random mutation to ensure diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple inversion to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9170519181244267,
            1.5331573486328125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment crossover and mutation\n    # Randomly select 3 distinct segments and recombine them with mutation\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with probabilistic order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment3, segment4, segment1])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment2, segment3])\n\n    # Apply random mutation to ensure diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple inversion to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{A novel algorithm that prioritizes solutions with balanced objective improvements, using a hybrid of multi-segment relocation and adaptive segment reordering to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid multi-segment relocation with adaptive reordering\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Adaptive segment reordering based on distance matrices\n    cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n    if cost1 > cost2:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2, segment1, segment3, segment5])\n\n    # Ensure feasibility with minimal perturbation\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0023933966853302,
            0.2659040093421936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - abs(x[1][0] - x[1][1]) / (x[1][0] + x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid multi-segment relocation with adaptive reordering\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Adaptive segment reordering based on distance matrices\n    cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n    if cost1 > cost2:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2, segment1, segment3, segment5])\n\n    # Ensure feasibility with minimal perturbation\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments and reverse them\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments don't overlap\n    if b <= c or d <= a:\n        # Apply segment reversal\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n    else:\n        # If segments overlap, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9244012151613683,
            0.20571494102478027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments and reverse them\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments don't overlap\n    if b <= c or d <= a:\n        # Apply segment reversal\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n    else:\n        # If segments overlap, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The new algorithm selects a solution from the archive based on its combined objective value and dominance count, then applies a hybrid local search operator that combines multi-segment relocation with adaptive segment reversal to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: multi-segment relocation with adaptive reversal\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Adaptive reversal: reverse segments with probability based on their distance\n    if distance_matrix_1[segment1[-1], segment1[0]] + distance_matrix_2[segment1[-1], segment1[0]] > distance_matrix_1[segment1[0], segment1[-1]] + distance_matrix_2[segment1[0], segment1[-1]]:\n        segment1 = segment1[::-1]\n    if distance_matrix_1[segment2[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment2[0]] > distance_matrix_1[segment2[0], segment2[-1]] + distance_matrix_2[segment2[0], segment2[-1]]:\n        segment2 = segment2[::-1]\n    if distance_matrix_1[segment3[-1], segment3[0]] + distance_matrix_2[segment3[-1], segment3[0]] > distance_matrix_1[segment3[0], segment3[-1]] + distance_matrix_2[segment3[0], segment3[-1]]:\n        segment3 = segment3[::-1]\n\n    # Recombine segments with adaptive order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Check feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Use a more sophisticated repair mechanism\n        for i in range(n):\n            if np.count_nonzero(new_solution == new_solution[i]) > 1:\n                # Find a node not in the solution and insert it\n                missing = [node for node in range(n) if node not in new_solution]\n                if missing:\n                    new_solution[i] = missing[0]\n                else:\n                    # If all nodes are present but duplicates exist, swap with a random node\n                    j = random.choice(range(n))\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8729898725777785,
            1.544388234615326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: multi-segment relocation with adaptive reversal\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Adaptive reversal: reverse segments with probability based on their distance\n    if distance_matrix_1[segment1[-1], segment1[0]] + distance_matrix_2[segment1[-1], segment1[0]] > distance_matrix_1[segment1[0], segment1[-1]] + distance_matrix_2[segment1[0], segment1[-1]]:\n        segment1 = segment1[::-1]\n    if distance_matrix_1[segment2[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment2[0]] > distance_matrix_1[segment2[0], segment2[-1]] + distance_matrix_2[segment2[0], segment2[-1]]:\n        segment2 = segment2[::-1]\n    if distance_matrix_1[segment3[-1], segment3[0]] + distance_matrix_2[segment3[-1], segment3[0]] > distance_matrix_1[segment3[0], segment3[-1]] + distance_matrix_2[segment3[0], segment3[-1]]:\n        segment3 = segment3[::-1]\n\n    # Recombine segments with adaptive order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Check feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Use a more sophisticated repair mechanism\n        for i in range(n):\n            if np.count_nonzero(new_solution == new_solution[i]) > 1:\n                # Find a node not in the solution and insert it\n                missing = [node for node in range(n) if node not in new_solution]\n                if missing:\n                    new_solution[i] = missing[0]\n                else:\n                    # If all nodes are present but duplicates exist, swap with a random node\n                    j = random.choice(range(n))\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of its objective values and diversity, then applies a novel multi-segment inversion strategy that reverses selected segments and reorders them in a way that preserves feasibility while potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments in a new order\n    segment1 = new_solution[:a]\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = new_solution[c:]\n\n    # Recombine segments with a probabilistic order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple inversion to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8701735349613482,
            1.750495731830597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments in a new order\n    segment1 = new_solution[:a]\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = new_solution[c:]\n\n    # Recombine segments with a probabilistic order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple inversion to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{A novel hybrid local search approach that combines a multi-segment reversal operator with a probabilistic edge insertion strategy to intelligently explore the solution space while maintaining feasibility and diversity in the generated neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment reversal with adaptive segment size\n    segments = random.randint(2, 4)\n    segment_size = n // segments\n    for i in range(segments):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < segments - 1 else n\n        if random.random() < 0.7:  # 70% chance to reverse segment\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Probabilistic edge insertion for diversification\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        # Insert node at j before i with probability based on distance improvement\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before or random.random() < 0.3:  # Accept if better or with 30% probability\n            new_solution = np.insert(np.delete(new_solution, j), i, new_solution[j])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9127930626232108,
            0.2105119824409485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment reversal with adaptive segment size\n    segments = random.randint(2, 4)\n    segment_size = n // segments\n    for i in range(segments):\n        start = i * segment_size\n        end = (i + 1) * segment_size if i < segments - 1 else n\n        if random.random() < 0.7:  # 70% chance to reverse segment\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Probabilistic edge insertion for diversification\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        # Insert node at j before i with probability based on distance improvement\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        if cost_after < cost_before or random.random() < 0.3:  # Accept if better or with 30% probability\n            new_solution = np.insert(np.delete(new_solution, j), i, new_solution[j])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of its objective values and diversity, then applies a hybrid local search operator that combines edge swaps with a novel segment inversion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    if random.random() < 0.7:\n        # Perform multiple edge swaps\n        num_swaps = random.randint(1, min(3, n//2))\n        for _ in range(num_swaps):\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7282677571909162,
            1.3441638350486755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    if random.random() < 0.7:\n        # Perform multiple edge swaps\n        num_swaps = random.randint(1, min(3, n//2))\n        for _ in range(num_swaps):\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform segment inversion\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel segment-based crossover and mutation strategy to generate a neighbor by combining segments from different parts of the tour while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = 1 / (objectives + 1e-6)  # Avoid division by zero\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    n = len(selected_solution)\n    new_solution = np.zeros_like(selected_solution)\n\n    # Split the tour into three segments\n    split_points = sorted(random.sample(range(1, n), 2))\n    segments = [\n        selected_solution[:split_points[0]],\n        selected_solution[split_points[0]:split_points[1]],\n        selected_solution[split_points[1]:]\n    ]\n\n    # Reconstruct tour by interleaving segments with possible mutations\n    for i in range(n):\n        if i % 3 == 0:\n            segment = segments[0]\n        elif i % 3 == 1:\n            segment = segments[1]\n        else:\n            segment = segments[2]\n\n        if len(segment) > 0:\n            new_solution[i] = segment[0]\n            segments[0 if i % 3 == 0 else 1 if i % 3 == 1 else 2] = segment[1:]\n\n    # Apply random mutation to ensure diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a simple insertion move\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.935484977547993,
            0.07704603672027588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = 1 / (objectives + 1e-6)  # Avoid division by zero\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    n = len(selected_solution)\n    new_solution = np.zeros_like(selected_solution)\n\n    # Split the tour into three segments\n    split_points = sorted(random.sample(range(1, n), 2))\n    segments = [\n        selected_solution[:split_points[0]],\n        selected_solution[split_points[0]:split_points[1]],\n        selected_solution[split_points[1]:]\n    ]\n\n    # Reconstruct tour by interleaving segments with possible mutations\n    for i in range(n):\n        if i % 3 == 0:\n            segment = segments[0]\n        elif i % 3 == 1:\n            segment = segments[1]\n        else:\n            segment = segments[2]\n\n        if len(segment) > 0:\n            new_solution[i] = segment[0]\n            segments[0 if i % 3 == 0 else 1 if i % 3 == 1 else 2] = segment[1:]\n\n    # Apply random mutation to ensure diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a simple insertion move\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel segment-based crossover and mutation strategy to generate a neighbor by combining segments from different parts of the tour while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = 1 / (objectives + 1e-6)  # Avoid division by zero\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    n = len(selected_solution)\n    new_solution = np.zeros_like(selected_solution)\n\n    # Split the tour into three segments\n    split_points = sorted(random.sample(range(1, n), 2))\n    segments = [\n        selected_solution[:split_points[0]],\n        selected_solution[split_points[0]:split_points[1]],\n        selected_solution[split_points[1]:]\n    ]\n\n    # Reconstruct tour by interleaving segments with possible mutations\n    for i in range(n):\n        if i % 3 == 0:\n            segment = segments[0]\n        elif i % 3 == 1:\n            segment = segments[1]\n        else:\n            segment = segments[2]\n\n        if len(segment) > 0:\n            new_solution[i] = segment[0]\n            segments[0 if i % 3 == 0 else 1 if i % 3 == 1 else 2] = segment[1:]\n\n    # Apply random mutation to ensure diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a simple insertion move\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.935484977547993,
            0.07704603672027588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    weights = 1 / (objectives + 1e-6)  # Avoid division by zero\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_solution = archive[np.argmax(weighted_scores)][0].copy()\n\n    n = len(selected_solution)\n    new_solution = np.zeros_like(selected_solution)\n\n    # Split the tour into three segments\n    split_points = sorted(random.sample(range(1, n), 2))\n    segments = [\n        selected_solution[:split_points[0]],\n        selected_solution[split_points[0]:split_points[1]],\n        selected_solution[split_points[1]:]\n    ]\n\n    # Reconstruct tour by interleaving segments with possible mutations\n    for i in range(n):\n        if i % 3 == 0:\n            segment = segments[0]\n        elif i % 3 == 1:\n            segment = segments[1]\n        else:\n            segment = segments[2]\n\n        if len(segment) > 0:\n            new_solution[i] = segment[0]\n            segments[0 if i % 3 == 0 else 1 if i % 3 == 1 else 2] = segment[1:]\n\n    # Apply random mutation to ensure diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a simple insertion move\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{A new algorithm that selects solutions from the archive based on a hybrid score combining normalized objective values and diversity metrics, then applies a multi-segment relocation operator with adaptive segment selection and probabilistic segment recombination to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    diversity = np.array([sum(1 for _, other_obj in archive if all(o < other_obj[i] for i, o in enumerate(obj))) for _, obj in archive])\n    scores = (1 - normalized_obj[:, 0]) * (1 - normalized_obj[:, 1]) * (1 + diversity)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation operator\n    k = max(2, min(5, n // 4))  # Adaptive number of segments\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    # Create segments and shuffle them\n    segment_list = [new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)]\n    random.shuffle(segment_list)\n    new_solution = np.concatenate(segment_list)\n\n    # Ensure feasibility with probabilistic local repair\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.7:  # 70% chance of using insertion repair\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n        else:  # 30% chance of using swap repair\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7803159947952634,
            0.3468990921974182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    diversity = np.array([sum(1 for _, other_obj in archive if all(o < other_obj[i] for i, o in enumerate(obj))) for _, obj in archive])\n    scores = (1 - normalized_obj[:, 0]) * (1 - normalized_obj[:, 1]) * (1 + diversity)\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation operator\n    k = max(2, min(5, n // 4))  # Adaptive number of segments\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    # Create segments and shuffle them\n    segment_list = [new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)]\n    random.shuffle(segment_list)\n    new_solution = np.concatenate(segment_list)\n\n    # Ensure feasibility with probabilistic local repair\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.7:  # 70% chance of using insertion repair\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n        else:  # 30% chance of using swap repair\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select an edge to reinsert elsewhere\n    i = random.randint(1, n-1)\n    edge = new_solution[i:i+2]\n    new_solution = np.delete(new_solution, i)\n    j = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, j, edge)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9754414523742911,
            0.05872851610183716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select an edge to reinsert elsewhere\n    i = random.randint(1, n-1)\n    edge = new_solution[i:i+2]\n    new_solution = np.delete(new_solution, i)\n    j = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, j, edge)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select an edge to reinsert elsewhere\n    i = random.randint(1, n-1)\n    edge = new_solution[i:i+2]\n    new_solution = np.delete(new_solution, i)\n    j = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, j, edge)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9754414523742911,
            0.05872851610183716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select an edge to reinsert elsewhere\n    i = random.randint(1, n-1)\n    edge = new_solution[i:i+2]\n    new_solution = np.delete(new_solution, i)\n    j = random.randint(1, len(new_solution)-1)\n    new_solution = np.insert(new_solution, j, edge)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge swapping with probabilistic acceptance to ensure diversity and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4] if archive[0][1][0] < archive[0][1][1] else [0.4, 0.6]\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: segment reversal with probabilistic edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    if random.random() < 0.3:  # 30% chance to apply edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8956747603095134,
            0.21360498666763306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4] if archive[0][1][0] < archive[0][1][1] else [0.4, 0.6]\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: segment reversal with probabilistic edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    if random.random() < 0.3:  # 30% chance to apply edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and their dominance counts, then applies a novel multi-segment inversion operator that reverses selected segments in a non-adjacent manner while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them in a non-adjacent manner\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments in a non-adjacent pattern\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9789310314410007,
            1.494077742099762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them in a non-adjacent manner\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments in a non-adjacent pattern\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with lower average objective values, then applies a novel hybrid local search that combines segment reversal with a randomized edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Randomly select two segments and reverse them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Randomly insert a node to disrupt the tour and create new edges\n    if random.random() < 0.5:\n        insert_pos = random.randint(1, n-1)\n        node_to_move = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6864453091348593,
            0.19842249155044556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Randomly select two segments and reverse them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Randomly insert a node to disrupt the tour and create new edges\n    if random.random() < 0.5:\n        insert_pos = random.randint(1, n-1)\n        node_to_move = random.choice(new_solution[1:-1])\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{A novel algorithm that selects solutions based on a weighted sum of objectives with adaptive weights and applies a hybrid local search combining segment reversal and edge swapping while ensuring feasibility through validity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Adjust weights based on problem characteristics\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge swapping\n    if c < b and d > b:\n        new_solution[b:d] = np.flip(new_solution[b:d])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.893471640640551,
            0.22065651416778564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Adjust weights based on problem characteristics\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge swapping\n    if c < b and d > b:\n        new_solution[b:d] = np.flip(new_solution[b:d])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on a weighted objective score, then applies a combination of segment reversal and edge reordering with feasibility checks to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge reordering\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Optionally swap edges between segments\n    if random.random() < 0.5 and b < c:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9067346460373702,
            0.21508294343948364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge reordering\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Optionally swap edges between segments\n    if random.random() < 0.5 and b < c:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel adaptive segment reversal with objective-aware selection\n    # Identify segments that are costly in both objectives\n    segment_length = max(3, n // 5)\n    segment_starts = random.sample(range(1, n - segment_length), 2)\n\n    # For each segment, calculate its cost in both objectives\n    segment_costs = []\n    for start in segment_starts:\n        end = start + segment_length\n        segment = selected_solution[start:end]\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Sort segments by total cost (highest cost first)\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n\n    # Reverse the most costly segments with a probability based on their cost\n    for cost, start, end in segment_costs:\n        if random.random() < (cost / (sum(c[0] for c in segment_costs) + 1e-6)):\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8360113556608397,
            0.5412337779998779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel adaptive segment reversal with objective-aware selection\n    # Identify segments that are costly in both objectives\n    segment_length = max(3, n // 5)\n    segment_starts = random.sample(range(1, n - segment_length), 2)\n\n    # For each segment, calculate its cost in both objectives\n    segment_costs = []\n    for start in segment_starts:\n        end = start + segment_length\n        segment = selected_solution[start:end]\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n        segment_costs.append((cost1 + cost2, start, end))\n\n    # Sort segments by total cost (highest cost first)\n    segment_costs.sort(reverse=True, key=lambda x: x[0])\n\n    # Reverse the most costly segments with a probability based on their cost\n    for cost, start, end in segment_costs:\n        if random.random() < (cost / (sum(c[0] for c in segment_costs) + 1e-6)):\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a multi-segment reversal and edge insertion strategy to generate a neighbor solution while ensuring feasibility through a novel validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weight1 = np.sum(distance_matrix_1) / (distance_matrix_1.shape[0] ** 2)\n    weight2 = np.sum(distance_matrix_2) / (distance_matrix_2.shape[0] ** 2)\n    selected_solution = max(archive, key=lambda x: (x[1][0] * weight1 + x[1][1] * weight2))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply multi-segment reversal and edge insertion\n    num_segments = random.randint(2, min(4, n // 2))\n    segments = sorted(random.sample(range(1, n), num_segments))\n    segments.append(n)\n\n    for i in range(len(segments) - 1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.5:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Edge insertion for additional diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9447906495746384,
            0.21666407585144043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weight1 = np.sum(distance_matrix_1) / (distance_matrix_1.shape[0] ** 2)\n    weight2 = np.sum(distance_matrix_2) / (distance_matrix_2.shape[0] ** 2)\n    selected_solution = max(archive, key=lambda x: (x[1][0] * weight1 + x[1][1] * weight2))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply multi-segment reversal and edge insertion\n    num_segments = random.randint(2, min(4, n // 2))\n    segments = sorted(random.sample(range(1, n), num_segments))\n    segments.append(n)\n\n    for i in range(len(segments) - 1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.5:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Edge insertion for additional diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Validate and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] > x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Multi-segment relocation with edge-swap\n    # Randomly select 4 distinct segments and apply a novel relocation pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a novel pattern\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment3, segment5, segment2, segment1, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment5, segment2])\n\n    # Apply novel edge-swap: reverse segments based on distance improvement\n    for i in range(1, n, 2):\n        if random.random() < 0.3:  # 30% chance to reverse\n            new_solution[i:i+2] = np.flip(new_solution[i:i+2])\n\n    # Ensure feasibility through a sophisticated repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a distance-based repair\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Try all possible swaps to find the best feasible solution\n        best_swap = None\n        best_cost = (current_cost1, current_cost2)\n\n        for i in range(n):\n            for j in range(i+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                if len(np.unique(temp_solution)) == n:\n                    cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n                        best_swap = (i, j)\n                        best_cost = (cost1, cost2)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If no improvement found, revert to a random feasible solution\n            while len(np.unique(new_solution)) != n:\n                new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.940762945377757,
            0.2722235321998596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] > x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Multi-segment relocation with edge-swap\n    # Randomly select 4 distinct segments and apply a novel relocation pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a novel pattern\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment3, segment5, segment2, segment1, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment5, segment2])\n\n    # Apply novel edge-swap: reverse segments based on distance improvement\n    for i in range(1, n, 2):\n        if random.random() < 0.3:  # 30% chance to reverse\n            new_solution[i:i+2] = np.flip(new_solution[i:i+2])\n\n    # Ensure feasibility through a sophisticated repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a distance-based repair\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Try all possible swaps to find the best feasible solution\n        best_swap = None\n        best_cost = (current_cost1, current_cost2)\n\n        for i in range(n):\n            for j in range(i+1, n):\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                if len(np.unique(temp_solution)) == n:\n                    cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n\n                    if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n                        best_swap = (i, j)\n                        best_cost = (cost1, cost2)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # If no improvement found, revert to a random feasible solution\n            while len(np.unique(new_solution)) != n:\n                new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines objective values with diversity metrics, then applies a novel \"node-swap and chain-reversal\" operator to generate neighbors by swapping nodes and reversing segments while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]) / len(archive)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel node-swap and chain-reversal operator\n    # Step 1: Select a random node and swap it with its neighbor\n    i = random.randint(1, n - 2)\n    new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    # Step 2: Reverse a random segment between two nodes\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Step 3: Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple circular shift to restore feasibility\n        shift = random.randint(1, n - 1)\n        new_solution[1:] = np.roll(new_solution[1:], shift)\n\n    return new_solution\n\n",
        "score": [
            -0.7887443309185768,
            0.25237905979156494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 - sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]) / len(archive)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel node-swap and chain-reversal operator\n    # Step 1: Select a random node and swap it with its neighbor\n    i = random.randint(1, n - 2)\n    new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    # Step 2: Reverse a random segment between two nodes\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Step 3: Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple circular shift to restore feasibility\n        shift = random.randint(1, n - 1)\n        new_solution[1:] = np.roll(new_solution[1:], shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge-swap operations, with a fallback to 2-opt if feasibility is violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based local search\n    if random.random() < 0.7:  # 70% chance for segment-based move\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        while (a < c < b or a < d < b):  # Ensure segments don't overlap\n            c, d = sorted(random.sample(range(1, n), 2))\n\n        # Reverse segments and reinsert them in a different order\n        segment1 = np.flip(new_solution[a:b])\n        segment2 = np.flip(new_solution[c:d])\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n    else:  # 30% chance for edge-swap move\n        # Select 4 distinct edges and perform a 4-opt swap\n        i, j, k, l = sorted(random.sample(range(1, n), 4))\n        new_solution = np.concatenate([\n            new_solution[:i], new_solution[k:l], new_solution[j:k], new_solution[i:j], new_solution[l:]\n        ])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply 2-opt as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9755741801319067,
            0.14273744821548462
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based local search\n    if random.random() < 0.7:  # 70% chance for segment-based move\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        while (a < c < b or a < d < b):  # Ensure segments don't overlap\n            c, d = sorted(random.sample(range(1, n), 2))\n\n        # Reverse segments and reinsert them in a different order\n        segment1 = np.flip(new_solution[a:b])\n        segment2 = np.flip(new_solution[c:d])\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n    else:  # 30% chance for edge-swap move\n        # Select 4 distinct edges and perform a 4-opt swap\n        i, j, k, l = sorted(random.sample(range(1, n), 4))\n        new_solution = np.concatenate([\n            new_solution[:i], new_solution[k:l], new_solution[j:k], new_solution[i:j], new_solution[l:]\n        ])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply 2-opt as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The new algorithm will select a solution based on dominance relationships in the archive, then apply a novel \"parallel 3-opt\" move that simultaneously optimizes both objectives by rearranging three randomly chosen segments in a way that minimizes the combined cost of the tour in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = set()\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated.add(i)\n    non_dominated = [sol for idx, (sol, _) in enumerate(archive) if idx not in dominated]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated).copy()\n\n    # Parallel 3-opt: simultaneously optimize both objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments and rearrange them\n    points = sorted(random.sample(range(1, n), 3))\n    a, b, c = points\n\n    # Create three possible rearrangements and evaluate their combined cost\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:b], new_solution[a:b], new_solution[b:c], new_solution[c:]])\n    ]\n\n    # Select the option with the lowest combined cost\n    best_option = min(options, key=lambda x: sum(distance_matrix_1[x[i], x[i+1]] + distance_matrix_2[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_1[x[-1], x[0]] + distance_matrix_2[x[-1], x[0]])\n\n    # Apply the best option\n    new_solution = best_option.copy()\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.830469216228348,
            0.14381539821624756
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = set()\n    for i, (sol1, obj1) in enumerate(archive):\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated.add(i)\n    non_dominated = [sol for idx, (sol, _) in enumerate(archive) if idx not in dominated]\n    if not non_dominated:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(non_dominated).copy()\n\n    # Parallel 3-opt: simultaneously optimize both objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments and rearrange them\n    points = sorted(random.sample(range(1, n), 3))\n    a, b, c = points\n\n    # Create three possible rearrangements and evaluate their combined cost\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]),\n        np.concatenate([new_solution[:a], new_solution[c:], new_solution[a:b], new_solution[b:c]]),\n        np.concatenate([new_solution[:b], new_solution[a:b], new_solution[b:c], new_solution[c:]])\n    ]\n\n    # Select the option with the lowest combined cost\n    best_option = min(options, key=lambda x: sum(distance_matrix_1[x[i], x[i+1]] + distance_matrix_2[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_1[x[-1], x[0]] + distance_matrix_2[x[-1], x[0]])\n\n    # Apply the best option\n    new_solution = best_option.copy()\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive based on Pareto dominance, then applies a novel segment-reversal and segment-shuffling hybrid local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] > archive[j][1][1]) or \\\n               (archive[i][1][0] > archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]):\n                dominated[i] = True\n                break\n    non_dominated = [sol for i, sol in enumerate(archive) if not dominated[i]]\n    selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with segment shuffling\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments and shuffle the middle part\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    mid_segment = new_solution[c:d]\n    np.random.shuffle(mid_segment)\n    new_solution[c:d] = mid_segment\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9061674921872946,
            0.298406720161438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] > archive[j][1][1]) or \\\n               (archive[i][1][0] > archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]):\n                dominated[i] = True\n                break\n    non_dominated = [sol for i, sol in enumerate(archive) if not dominated[i]]\n    selected_solution = random.choice(non_dominated)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with segment shuffling\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments and shuffle the middle part\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    mid_segment = new_solution[c:d]\n    np.random.shuffle(mid_segment)\n    new_solution[c:d] = mid_segment\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Novel local search: Combine segment reversal with adaptive edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Adaptive edge insertion: insert a randomly selected node in a new position\n    node_to_insert = random.choice(new_solution[1:-1])\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_insert)), insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to segment reversal only\n        new_solution = selected_solution.copy()\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.8706643491940765,
            0.2194448709487915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Novel local search: Combine segment reversal with adaptive edge insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Adaptive edge insertion: insert a randomly selected node in a new position\n    node_to_insert = random.choice(new_solution[1:-1])\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_insert)), insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to segment reversal only\n        new_solution = selected_solution.copy()\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel algorithm that selects solutions from the archive based on a weighted sum of objectives with a random weighting factor, then applies a hybrid local search combining segment reversal and edge reinsertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weight = random.uniform(0.3, 0.7)\n    selected_solution = max(archive, key=lambda x: weight * x[1][0] + (1 - weight) * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge reinsertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and reinsert edges\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Edge reinsertion\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9911201489438264,
            0.2171834111213684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weight = random.uniform(0.3, 0.7)\n    selected_solution = max(archive, key=lambda x: weight * x[1][0] + (1 - weight) * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge reinsertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and reinsert edges\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Edge reinsertion\n    if random.random() < 0.5:\n        i = random.randint(1, n-2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and a donor solution for crossover\n    a, b = sorted(random.sample(range(1, n), 2))\n    donor_idx = random.randint(0, len(archive) - 1)\n    donor_solution = archive[donor_idx][0]\n\n    # Extract segment from donor and insert into current solution\n    segment = donor_solution[a:b]\n    remaining_nodes = [node for node in selected_solution if node not in segment]\n    new_solution = np.concatenate([remaining_nodes[:a], segment, remaining_nodes[a:]])\n\n    # Apply local refinement by optimizing a small window\n    window_size = min(5, n - 1)\n    start = random.randint(0, n - window_size)\n    window = new_solution[start:start+window_size]\n\n    # Evaluate all possible permutations of the window\n    best_window = window.copy()\n    best_cost = sum(distance_matrix_1[window[i], window[(i+1)%window_size]] for i in range(window_size)) + \\\n                sum(distance_matrix_2[window[i], window[(i+1)%window_size]] for i in range(window_size))\n\n    for _ in range(5):  # Limited trials for efficiency\n        candidate = window.copy()\n        i, j = sorted(random.sample(range(window_size), 2))\n        candidate[i:j] = np.flip(candidate[i:j])\n        cost = sum(distance_matrix_1[candidate[i], candidate[(i+1)%window_size]] for i in range(window_size)) + \\\n               sum(distance_matrix_2[candidate[i], candidate[(i+1)%window_size]] for i in range(window_size))\n        if cost < best_cost:\n            best_window = candidate\n            best_cost = cost\n\n    new_solution[start:start+window_size] = best_window\n\n    return new_solution\n\n",
        "score": [
            -0.8194693713655401,
            0.8287559747695923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and a donor solution for crossover\n    a, b = sorted(random.sample(range(1, n), 2))\n    donor_idx = random.randint(0, len(archive) - 1)\n    donor_solution = archive[donor_idx][0]\n\n    # Extract segment from donor and insert into current solution\n    segment = donor_solution[a:b]\n    remaining_nodes = [node for node in selected_solution if node not in segment]\n    new_solution = np.concatenate([remaining_nodes[:a], segment, remaining_nodes[a:]])\n\n    # Apply local refinement by optimizing a small window\n    window_size = min(5, n - 1)\n    start = random.randint(0, n - window_size)\n    window = new_solution[start:start+window_size]\n\n    # Evaluate all possible permutations of the window\n    best_window = window.copy()\n    best_cost = sum(distance_matrix_1[window[i], window[(i+1)%window_size]] for i in range(window_size)) + \\\n                sum(distance_matrix_2[window[i], window[(i+1)%window_size]] for i in range(window_size))\n\n    for _ in range(5):  # Limited trials for efficiency\n        candidate = window.copy()\n        i, j = sorted(random.sample(range(window_size), 2))\n        candidate[i:j] = np.flip(candidate[i:j])\n        cost = sum(distance_matrix_1[candidate[i], candidate[(i+1)%window_size]] for i in range(window_size)) + \\\n               sum(distance_matrix_2[candidate[i], candidate[(i+1)%window_size]] for i in range(window_size))\n        if cost < best_cost:\n            best_window = candidate\n            best_cost = cost\n\n    new_solution[start:start+window_size] = best_window\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    centroid = np.mean([sol[0] for sol in archive], axis=0)\n    selected_solution = min(archive, key=lambda x: np.sum(np.abs(x[0] - centroid)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and a shift amount\n    a, b = sorted(random.sample(range(1, n), 2))\n    shift = random.randint(1, min(3, b - a))\n\n    # Reverse the segment and shift it within the segment\n    segment = new_solution[a:b]\n    reversed_segment = np.flip(segment)\n    shifted_segment = np.roll(reversed_segment, shift)\n\n    # Insert the modified segment back\n    new_solution[a:b] = shifted_segment\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple cyclic permutation to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i:j] = np.roll(new_solution[i:j], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7854718128800262,
            0.5759763121604919
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    centroid = np.mean([sol[0] for sol in archive], axis=0)\n    selected_solution = min(archive, key=lambda x: np.sum(np.abs(x[0] - centroid)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and a shift amount\n    a, b = sorted(random.sample(range(1, n), 2))\n    shift = random.randint(1, min(3, b - a))\n\n    # Reverse the segment and shift it within the segment\n    segment = new_solution[a:b]\n    reversed_segment = np.flip(segment)\n    shifted_segment = np.roll(reversed_segment, shift)\n\n    # Insert the modified segment back\n    new_solution[a:b] = shifted_segment\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple cyclic permutation to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i:j] = np.roll(new_solution[i:j], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The new algorithm selects a promising solution from the archive by considering both its objective values and the diversity of its segments, then generates a neighbor by intelligently recombining multiple segments while preserving feasibility through a novel segment-based crossover and mutation strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover and mutation\n    # Randomly select 4 distinct segments and recombine them\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Create 3 possible recombinations with 33% probability each\n    rand = random.random()\n    if rand < 0.33:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment5, segment3])\n    elif rand < 0.66:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2, segment3, segment1, segment5])\n\n    # Apply segment-based mutation: reverse a random segment\n    if random.random() < 0.3:\n        seg_start, seg_end = sorted(random.sample(range(1, n), 2))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment swap to fix\n        seg1_start, seg1_end = sorted(random.sample(range(1, n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(1, n), 2))\n        temp = new_solution[seg1_start:seg1_end].copy()\n        new_solution[seg1_start:seg1_end] = new_solution[seg2_start:seg2_end]\n        new_solution[seg2_start:seg2_end] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9450921802416916,
            1.5496271848678589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover and mutation\n    # Randomly select 4 distinct segments and recombine them\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Create 3 possible recombinations with 33% probability each\n    rand = random.random()\n    if rand < 0.33:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment5, segment3])\n    elif rand < 0.66:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2, segment3, segment1, segment5])\n\n    # Apply segment-based mutation: reverse a random segment\n    if random.random() < 0.3:\n        seg_start, seg_end = sorted(random.sample(range(1, n), 2))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment swap to fix\n        seg1_start, seg1_end = sorted(random.sample(range(1, n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(1, n), 2))\n        temp = new_solution[seg1_start:seg1_end].copy()\n        new_solution[seg1_start:seg1_end] = new_solution[seg2_start:seg2_end]\n        new_solution[seg2_start:seg2_end] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This new algorithm selects the best solution from the archive based on the sum of normalized objective values, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    if n > 3:\n        # Randomly select two segments and reverse them\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n        # Insert a random edge from elsewhere in the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j:\n            edge = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7801790762303897,
            0.24659371376037598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge insertion\n    if n > 3:\n        # Randomly select two segments and reverse them\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n        # Insert a random edge from elsewhere in the tour\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j:\n            edge = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(1, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted combination of objective values and applies a hybrid local search combining segment reversal and edge-swap operations, while ensuring feasibility through validation checks and fallback to simpler moves when necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Validate and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8514501774439595,
            0.1978272795677185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Validate and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This new algorithm selects a solution from the archive based on a novel scoring function that combines objective values with diversity and dominance metrics, then applies a hybrid local search operator that combines segment relocation with adaptive edge swaps to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        dominance = sum(1 for s in archive if s[1][0] < obj1 and s[1][1] < obj2)\n        diversity = sum(abs(obj1 - s[1][0]) + abs(obj2 - s[1][1]) for s in archive)\n        return (obj1 + obj2) * (1 + dominance) + 0.1 * diversity\n\n    selected_solution = max(archive, key=score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    # Adaptive segment relocation with edge swaps\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Adaptive segment permutation\n    if random.random() < 0.3:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    elif random.random() < 0.6:\n        new_solution = np.concatenate([segment3, segment1, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment4, segment2])\n\n    # Edge swap improvement\n    for _ in range(3):\n        i, j = random.sample(range(1, n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swap improves both objectives\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if new_cost < original_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5837384866025739,
            3.9732812643051147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        dominance = sum(1 for s in archive if s[1][0] < obj1 and s[1][1] < obj2)\n        diversity = sum(abs(obj1 - s[1][0]) + abs(obj2 - s[1][1]) for s in archive)\n        return (obj1 + obj2) * (1 + dominance) + 0.1 * diversity\n\n    selected_solution = max(archive, key=score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    # Adaptive segment relocation with edge swaps\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Adaptive segment permutation\n    if random.random() < 0.3:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    elif random.random() < 0.6:\n        new_solution = np.concatenate([segment3, segment1, segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment4, segment2])\n\n    # Edge swap improvement\n    for _ in range(3):\n        i, j = random.sample(range(1, n), 2)\n        if i > j:\n            i, j = j, i\n        # Check if swap improves both objectives\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        if new_cost < original_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: 3-opt with adaptive segment selection\n    # Randomly select 3 distinct nodes and perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create four segments from the selected nodes\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order (with 6 possible permutations)\n    permutations = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment2, segment1, segment3, segment4]),\n        np.concatenate([segment3, segment1, segment2, segment4]),\n        np.concatenate([segment3, segment2, segment1, segment4]),\n        np.concatenate([segment2, segment3, segment1, segment4])\n    ]\n    new_solution = random.choice(permutations)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        a, b = random.sample(range(1, n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9172351590961441,
            0.2066274881362915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: 3-opt with adaptive segment selection\n    # Randomly select 3 distinct nodes and perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create four segments from the selected nodes\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Recombine segments in a new order (with 6 possible permutations)\n    permutations = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment2, segment1, segment3, segment4]),\n        np.concatenate([segment3, segment1, segment2, segment4]),\n        np.concatenate([segment3, segment2, segment1, segment4]),\n        np.concatenate([segment2, segment3, segment1, segment4])\n    ]\n    new_solution = random.choice(permutations)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        a, b = random.sample(range(1, n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on the worst objective value (to focus on less explored regions) and applies a sequence of alternating edge insertions and segment reversals, ensuring feasibility by always maintaining a valid tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: min(x[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Alternating edge insertion and segment reversal\n    for _ in range(2):\n        # Random edge insertion\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Random segment reversal\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by removing duplicates and reinserting missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    for node in missing_nodes:\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7377076567474892,
            0.2678282856941223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: min(x[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Alternating edge insertion and segment reversal\n    for _ in range(2):\n        # Random edge insertion\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n        # Random segment reversal\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by removing duplicates and reinserting missing nodes\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n    for node in missing_nodes:\n        pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects the solution with the highest average objective value from the archive, then applies a novel \"multi-segment reversal\" strategy that randomly reverses multiple non-overlapping segments of the tour while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly determine number of segments to reverse (between 2 and 4)\n    num_segments = random.randint(2, 4)\n    segment_lengths = sorted(random.sample(range(2, n//2), num_segments))\n\n    # Generate non-overlapping segments\n    segments = []\n    current_pos = 1\n    for length in segment_lengths:\n        if current_pos + length >= n:\n            break\n        segments.append((current_pos, current_pos + length))\n        current_pos += length + 1\n\n    # Reverse each segment\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a single 2-opt move as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9314085683723476,
            0.20504891872406006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly determine number of segments to reverse (between 2 and 4)\n    num_segments = random.randint(2, 4)\n    segment_lengths = sorted(random.sample(range(2, n//2), num_segments))\n\n    # Generate non-overlapping segments\n    segments = []\n    current_pos = 1\n    for length in segment_lengths:\n        if current_pos + length >= n:\n            break\n        segments.append((current_pos, current_pos + length))\n        current_pos += length + 1\n\n    # Reverse each segment\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a single 2-opt move as fallback\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal and partial path reordering with a novel edge-swapping strategy to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/distance_matrix_1.sum(), 1/distance_matrix_2.sum()]\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: segment reversal with conditional edge swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Conditional edge swap: only if it improves both objectives\n    if random.random() < 0.3:  # 30% chance to apply swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) and \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple 2-opt\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9468533030168674,
            0.21434175968170166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/distance_matrix_1.sum(), 1/distance_matrix_2.sum()]\n    selected_solution = max(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: segment reversal with conditional edge swapping\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Conditional edge swap: only if it improves both objectives\n    if random.random() < 0.3:  # 30% chance to apply swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]) and \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple 2-opt\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a hybrid of its objective values and the density of solutions in its neighborhood, then applies a multi-segment insertion operator that intelligently reorders and inserts segments while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if (y[1][0] < x[1][0] and y[1][1] < x[1][1]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment insertion operator\n    # Randomly select 4 distinct segments and insert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a new order (with 4 possible permutations)\n    permutation = random.randint(0, 3)\n    if permutation == 0:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3, segment5])\n    elif permutation == 1:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2, segment5])\n    elif permutation == 2:\n        new_solution = np.concatenate([segment4, segment3, segment2, segment1, segment5])\n    else:\n        new_solution = np.concatenate([segment1, segment5, segment2, segment4, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9671733160236511,
            1.4964268803596497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if (y[1][0] < x[1][0] and y[1][1] < x[1][1]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment insertion operator\n    # Randomly select 4 distinct segments and insert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a new order (with 4 possible permutations)\n    permutation = random.randint(0, 3)\n    if permutation == 0:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3, segment5])\n    elif permutation == 1:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2, segment5])\n    elif permutation == 2:\n        new_solution = np.concatenate([segment4, segment3, segment2, segment1, segment5])\n    else:\n        new_solution = np.concatenate([segment1, segment5, segment2, segment4, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This new algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a novel 3-opt local search by randomly selecting three segments to reverse and reinsert, ensuring feasibility through validation and fallback to a simpler move if invalid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to reverse and reinsert\n    indices = sorted(random.sample(range(1, n), 3))\n    a, b, c = indices[0], indices[1], indices[2]\n\n    # Apply novel 3-opt: reverse segments and reorder\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.790055719375338,
            0.1989738941192627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to reverse and reinsert\n    indices = sorted(random.sample(range(1, n), 3))\n    a, b, c = indices[0], indices[1], indices[2]\n\n    # Apply novel 3-opt: reverse segments and reorder\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment quality based on edge contributions in both objectives\n    segment_scores = []\n    for i in range(n):\n        for j in range(i + 2, min(i + 10, n - 1)):  # Limit segment length for efficiency\n            segment = selected_solution[i:j]\n            cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            segment_scores.append((i, j, cost1 + cost2))\n\n    # Select top 3 segments with highest quality\n    segment_scores.sort(key=lambda x: -x[2])\n    selected_segments = segment_scores[:3]\n\n    # Apply segment-based crossover: replace segments with their reversed versions\n    for i, j, _ in selected_segments:\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple insertion to fix\n        for i in range(1, n):\n            if new_solution[i] in new_solution[:i]:\n                j = np.where(new_solution == new_solution[i])[0][0]\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9414932776522429,
            0.7866697907447815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment quality based on edge contributions in both objectives\n    segment_scores = []\n    for i in range(n):\n        for j in range(i + 2, min(i + 10, n - 1)):  # Limit segment length for efficiency\n            segment = selected_solution[i:j]\n            cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1))\n            segment_scores.append((i, j, cost1 + cost2))\n\n    # Select top 3 segments with highest quality\n    segment_scores.sort(key=lambda x: -x[2])\n    selected_segments = segment_scores[:3]\n\n    # Apply segment-based crossover: replace segments with their reversed versions\n    for i, j, _ in selected_segments:\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple insertion to fix\n        for i in range(1, n):\n            if new_solution[i] in new_solution[:i]:\n                j = np.where(new_solution == new_solution[i])[0][0]\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A novel algorithm that selects solutions based on a hybrid crowding-distance and dominance-ranking metric to prioritize solutions in less-explored regions, followed by a multi-segment inversion operator that reorders segments in a non-sequential pattern to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def hybrid_score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        crowding = (max(x[1][0] for x in archive) - min(x[1][0] for x in archive)) + (max(x[1][1] for x in archive) - min(x[1][1] for x in archive))\n        dominates = sum(1 for x in archive if (x[1][0] < obj1 and x[1][1] < obj2) or (x[1][0] <= obj1 and x[1][1] < obj2) or (x[1][0] < obj1 and x[1][1] <= obj2))\n        return crowding * (1 + dominates)\n\n    selected_solution = max(archive, key=lambda x: hybrid_score(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Invert segments in a novel pattern\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1[::-1], segment3[::-1], segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2[::-1], segment3[::-1], segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8745960714960221,
            5.534692406654358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def hybrid_score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        crowding = (max(x[1][0] for x in archive) - min(x[1][0] for x in archive)) + (max(x[1][1] for x in archive) - min(x[1][1] for x in archive))\n        dominates = sum(1 for x in archive if (x[1][0] < obj1 and x[1][1] < obj2) or (x[1][0] <= obj1 and x[1][1] < obj2) or (x[1][0] < obj1 and x[1][1] <= obj2))\n        return crowding * (1 + dominates)\n\n    selected_solution = max(archive, key=lambda x: hybrid_score(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Invert segments in a novel pattern\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1[::-1], segment3[::-1], segment2, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment2[::-1], segment3[::-1], segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a hybrid scoring function combining normalized objective values and dominance count, followed by a multi-segment relocation and inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Compute hybrid score: normalized sum + dominance count\n    dominance = np.array([sum(1 for y in objectives if y[0] < x[0] and y[1] < x[1]) for x in objectives])\n    scores = (normalized[:, 0] + normalized[:, 1]) * (1 + dominance)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment relocation with inversion\n    segments = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments and invert middle segment\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b][::-1]  # Invert middle segment\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9232147593036343,
            4.1381537318229675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Compute hybrid score: normalized sum + dominance count\n    dominance = np.array([sum(1 for y in objectives if y[0] < x[0] and y[1] < x[1]) for x in objectives])\n    scores = (normalized[:, 0] + normalized[:, 1]) * (1 + dominance)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment relocation with inversion\n    segments = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments and invert middle segment\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b][::-1]  # Invert middle segment\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel k-segment shuffle operator\n    # Randomly select k distinct segments and reorder them in a new configuration\n    k = random.randint(2, min(5, n // 2))  # Randomly choose 2-5 segments\n    segment_points = sorted(random.sample(range(1, n), k - 1))\n    segments = []\n    start = 0\n\n    for point in segment_points:\n        segments.append(new_solution[start:point])\n        start = point\n    segments.append(new_solution[start:])\n\n    # Shuffle the segments in a random order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment reversal to fix\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.8314703921474403,
            0.29404932260513306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel k-segment shuffle operator\n    # Randomly select k distinct segments and reorder them in a new configuration\n    k = random.randint(2, min(5, n // 2))  # Randomly choose 2-5 segments\n    segment_points = sorted(random.sample(range(1, n), k - 1))\n    segments = []\n    start = 0\n\n    for point in segment_points:\n        segments.append(new_solution[start:point])\n        start = point\n    segments.append(new_solution[start:])\n\n    # Shuffle the segments in a random order\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment reversal to fix\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (sum(y[1][0] * y[1][1] for y in archive) + 1e-6))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based insertion operator\n    # Randomly select 4 distinct points and insert segments in a new order\n    points = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = points[0], points[1], points[2], points[3]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a new order (with 33% probability for each permutation)\n    rand_val = random.random()\n    if rand_val < 0.33:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment4, segment2])\n    elif rand_val < 0.66:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3, segment5])\n    else:\n        new_solution = np.concatenate([segment5, segment2, segment4, segment1, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random segment reversal to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9431932442207848,
            1.910829782485962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (sum(y[1][0] * y[1][1] for y in archive) + 1e-6))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based insertion operator\n    # Randomly select 4 distinct points and insert segments in a new order\n    points = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = points[0], points[1], points[2], points[3]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a new order (with 33% probability for each permutation)\n    rand_val = random.random()\n    if rand_val < 0.33:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment4, segment2])\n    elif rand_val < 0.66:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3, segment5])\n    else:\n        new_solution = np.concatenate([segment5, segment2, segment4, segment1, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random segment reversal to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive using a dominance-based selection criterion, then applies a novel hybrid segment inversion and relocation operator that combines segment inversion with segment relocations to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid segment inversion and relocation operator\n    # Randomly select 2 distinct segments and apply inversion to one, then relocate both\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the first segment\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b][::-1]\n    segment3 = new_solution[b:]\n\n    # Combine segments in a new order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment3, segment1])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment2])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.935277719314012,
            1.4746224284172058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid segment inversion and relocation operator\n    # Randomly select 2 distinct segments and apply inversion to one, then relocate both\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the first segment\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b][::-1]\n    segment3 = new_solution[b:]\n\n    # Combine segments in a new order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment3, segment1])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment2])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{The new algorithm combines a multi-segment relocation strategy with a novel edge-reordering mechanism, selecting solutions based on their potential for improvement in both objectives while ensuring feasibility through a segment-based validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based edge reordering\n    # Randomly select 4 distinct segments and reorder them\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create four segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a new order (with 60% probability of each permutation)\n    rand_val = random.random()\n    if rand_val < 0.2:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n    elif rand_val < 0.4:\n        new_solution = np.concatenate([segment2, segment4, segment3, segment5, segment1])\n    elif rand_val < 0.6:\n        new_solution = np.concatenate([segment4, segment5, segment2, segment1, segment3])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment4, segment2, segment5])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment swap to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9283926863466019,
            1.6636865735054016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based edge reordering\n    # Randomly select 4 distinct segments and reorder them\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create four segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a new order (with 60% probability of each permutation)\n    rand_val = random.random()\n    if rand_val < 0.2:\n        new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n    elif rand_val < 0.4:\n        new_solution = np.concatenate([segment2, segment4, segment3, segment5, segment1])\n    elif rand_val < 0.6:\n        new_solution = np.concatenate([segment4, segment5, segment2, segment1, segment3])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment4, segment2, segment5])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment swap to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel adaptive local search algorithm that combines a biased random selection of solutions based on their objective values with a hybrid edge-reversal and segment-insertion strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Adaptive segment selection based on distance matrices\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Hybrid operator: reverse a segment and insert it elsewhere\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9650116954998792,
            0.0804663896560669
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Adaptive segment selection based on distance matrices\n    i, j = sorted(random.sample(range(1, n), 2))\n    k, l = sorted(random.sample(range(1, n), 2))\n\n    # Hybrid operator: reverse a segment and insert it elsewhere\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: Edge reinsertion followed by segment inversion\n    if random.random() < 0.7:\n        # Edge reinsertion (remove and reinsert a random edge)\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n    else:\n        # Segment inversion (reverse a random segment)\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8849747246496322,
            1.4804579615592957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: Edge reinsertion followed by segment inversion\n    if random.random() < 0.7:\n        # Edge reinsertion (remove and reinsert a random edge)\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = random.randint(1, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n    else:\n        # Segment inversion (reverse a random segment)\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining segment reversal and edge-swap operations, ensuring feasibility through validation and fallback to simpler moves if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / np.max(distance_matrix_1)) + (x[1][1] / np.max(distance_matrix_2)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and insert them at new positions\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Insert segments at random positions while maintaining feasibility\n    pos1, pos2 = sorted(random.sample(range(1, n), 2))\n    new_solution = np.concatenate([new_solution[:pos1], segment1, new_solution[pos1:pos2], segment2, new_solution[pos2:]])\n\n    # Ensure feasibility by removing duplicates and filling gaps\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for node in duplicates:\n        # Find positions of duplicates\n        indices = np.where(new_solution == node)[0][1:]\n        for idx in indices:\n            # Replace with a missing node\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing_nodes) > 0:\n                new_solution[idx] = random.choice(missing_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.8817196743728011,
            1.1725414991378784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / np.max(distance_matrix_1)) + (x[1][1] / np.max(distance_matrix_2)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment-based local search\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and insert them at new positions\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Insert segments at random positions while maintaining feasibility\n    pos1, pos2 = sorted(random.sample(range(1, n), 2))\n    new_solution = np.concatenate([new_solution[:pos1], segment1, new_solution[pos1:pos2], segment2, new_solution[pos2:]])\n\n    # Ensure feasibility by removing duplicates and filling gaps\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for node in duplicates:\n        # Find positions of duplicates\n        indices = np.where(new_solution == node)[0][1:]\n        for idx in indices:\n            # Replace with a missing node\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            if len(missing_nodes) > 0:\n                new_solution[idx] = random.choice(missing_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm selects a solution from the archive based on a modified score function that prioritizes solutions with better objective values and higher potential for improvement, then applies a novel multi-segment relocation operator with adaptive segment selection and recombination strategies.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation operator\n    k = max(2, min(5, random.randint(1, n//2)))  # Randomly select 2-5 segments\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    # Create segments and shuffle their order\n    segment_list = []\n    for i in range(len(segments)-1):\n        segment_list.append(new_solution[segments[i]:segments[i+1]])\n\n    random.shuffle(segment_list)\n    new_solution = np.concatenate(segment_list)\n\n    # Ensure feasibility with probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.7:  # 70% chance for insertion repair\n            i, j = random.sample(range(n), 2)\n            new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n        else:  # 30% chance for swap repair\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9483821025536916,
            1.474265456199646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation operator\n    k = max(2, min(5, random.randint(1, n//2)))  # Randomly select 2-5 segments\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    # Create segments and shuffle their order\n    segment_list = []\n    for i in range(len(segments)-1):\n        segment_list.append(new_solution[segments[i]:segments[i+1]])\n\n    random.shuffle(segment_list)\n    new_solution = np.concatenate(segment_list)\n\n    # Ensure feasibility with probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        if random.random() < 0.7:  # 70% chance for insertion repair\n            i, j = random.sample(range(n), 2)\n            new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n        else:  # 30% chance for swap repair\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-objective path reversal and segment insertion\n    # 1. Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if b - a < 2:\n        b = a + random.randint(2, min(5, n-a-1))\n\n    # 2. Reverse one segment and insert it after another\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b][::-1]  # Reverse the segment\n    segment3 = new_solution[b:]\n\n    # 3. Choose insertion point based on objective improvement\n    best_insertion = b\n    min_cost = float('inf')\n\n    for i in range(1, n):\n        if i >= a and i <= b:\n            continue\n\n        # Try inserting reversed segment at position i\n        temp_solution = np.concatenate([new_solution[:i], segment2, new_solution[i:]])\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Calculate cost in both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Use weighted sum of objectives with random weights to encourage exploration\n        weight = random.uniform(0.3, 0.7)\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = i\n\n    # Apply the best insertion found\n    new_solution = np.concatenate([new_solution[:best_insertion], segment2, new_solution[best_insertion:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9692043517036518,
            1.611649751663208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-objective path reversal and segment insertion\n    # 1. Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    if b - a < 2:\n        b = a + random.randint(2, min(5, n-a-1))\n\n    # 2. Reverse one segment and insert it after another\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b][::-1]  # Reverse the segment\n    segment3 = new_solution[b:]\n\n    # 3. Choose insertion point based on objective improvement\n    best_insertion = b\n    min_cost = float('inf')\n\n    for i in range(1, n):\n        if i >= a and i <= b:\n            continue\n\n        # Try inserting reversed segment at position i\n        temp_solution = np.concatenate([new_solution[:i], segment2, new_solution[i:]])\n        if len(np.unique(temp_solution)) != n:\n            continue\n\n        # Calculate cost in both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Use weighted sum of objectives with random weights to encourage exploration\n        weight = random.uniform(0.3, 0.7)\n        total_cost = weight * cost1 + (1 - weight) * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = i\n\n    # Apply the best insertion found\n    new_solution = np.concatenate([new_solution[:best_insertion], segment2, new_solution[best_insertion:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a novel multi-segment insertion heuristic that strategically reorders segments of the tour while ensuring feasibility through a constrained reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator\n    # Randomly select 4 distinct segments and reinsert them in a constrained order\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Reinsert segments with constraints to maintain feasibility\n    # Option 1: Insert segment3 between segment1 and segment2\n    # Option 2: Insert segment4 between segment2 and segment3\n    # Option 3: Insert segment2 between segment3 and segment4\n    option = random.randint(1, 3)\n\n    if option == 1:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4, segment5])\n    elif option == 2:\n        new_solution = np.concatenate([segment1, segment2, segment4, segment3, segment5])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4, segment5])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a constrained swap to fix\n        i = random.randint(1, n-1)\n        j = (i + random.randint(2, n//2)) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8913654390974506,
            1.4771922826766968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.4 + x[1][1] * 0.6) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator\n    # Randomly select 4 distinct segments and reinsert them in a constrained order\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Reinsert segments with constraints to maintain feasibility\n    # Option 1: Insert segment3 between segment1 and segment2\n    # Option 2: Insert segment4 between segment2 and segment3\n    # Option 3: Insert segment2 between segment3 and segment4\n    option = random.randint(1, 3)\n\n    if option == 1:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4, segment5])\n    elif option == 2:\n        new_solution = np.concatenate([segment1, segment2, segment4, segment3, segment5])\n    else:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4, segment5])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a constrained swap to fix\n        i = random.randint(1, n-1)\n        j = (i + random.randint(2, n//2)) % n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid local search operator that combines segment reversal with a novel edge-reversal strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge-reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Edge-reversal: reverse edges between segments\n    if random.random() < 0.5:\n        c = random.randint(1, n-1)\n        new_solution[c:] = np.flip(new_solution[c:])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8609343769131199,
            1.482739806175232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge-reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Edge-reversal: reverse edges between segments\n    if random.random() < 0.5:\n        c = random.randint(1, n-1)\n        new_solution[c:] = np.flip(new_solution[c:])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{A novel hybrid approach that combines adaptive segment relocation with dynamic edge swapping, where segments are selected based on their potential for improving both objectives, and edges are swapped in a way that balances the trade-off between the two objectives by considering their relative improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, (cost1, cost2) = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on objective trade-off\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Dynamic edge swapping with objective-aware balancing\n    if random.random() < (cost1 / (cost1 + cost2)):\n        # Prefer improving the first objective\n        new_solution[a:b] = np.roll(new_solution[a:b], random.randint(1, b-a))\n    else:\n        # Prefer improving the second objective\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9353860357829041,
            1.5012059211730957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, (cost1, cost2) = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on objective trade-off\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Dynamic edge swapping with objective-aware balancing\n    if random.random() < (cost1 / (cost1 + cost2)):\n        # Prefer improving the first objective\n        new_solution[a:b] = np.roll(new_solution[a:b], random.randint(1, b-a))\n    else:\n        # Prefer improving the second objective\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: segment reversal and edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7803502736021133,
            0.19184547662734985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: segment reversal and edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of its objective values and the number of solutions it dominates, then applies a novel multi-segment inversion operator that flips segments of the tour to create a new neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert them\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the selected segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9576770919955013,
            1.481366217136383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert them\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the selected segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal followed by edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Edge insertion: Move a random edge to a new position\n    i, j = sorted(random.sample(range(1, n), 2))\n    edge = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8424484609118272,
            0.19839030504226685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1][0], x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal followed by edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Edge insertion: Move a random edge to a new position\n    i, j = sorted(random.sample(range(1, n), 2))\n    edge = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a solution from the archive based on a modified dominance score that considers both objective values and their relative dominance, then applies a novel multi-segment relocation operator with adaptive segment selection and permutation strategies to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 * (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation with dynamic segment selection\n    num_segments = min(4, n // 3)\n    segments = sorted(random.sample(range(1, n), num_segments))\n    segments = [0] + segments + [n]\n\n    # Create segments and shuffle their order\n    segment_list = [new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)]\n    random.shuffle(segment_list)\n\n    # Recombine with probability based on segment quality\n    if random.random() < 0.6:\n        new_solution = np.concatenate(segment_list)\n    else:\n        # Alternate segment insertion\n        new_solution = segment_list[0].copy()\n        for seg in segment_list[1:]:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], seg, new_solution[insert_pos:]])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Apply edge swap repair\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Fallback to random swap\n            while True:\n                i, j = random.sample(range(1, n), 2)\n                if new_solution[i] != new_solution[j]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.909460539905653,
            1.5349220037460327
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 * (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation with dynamic segment selection\n    num_segments = min(4, n // 3)\n    segments = sorted(random.sample(range(1, n), num_segments))\n    segments = [0] + segments + [n]\n\n    # Create segments and shuffle their order\n    segment_list = [new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)]\n    random.shuffle(segment_list)\n\n    # Recombine with probability based on segment quality\n    if random.random() < 0.6:\n        new_solution = np.concatenate(segment_list)\n    else:\n        # Alternate segment insertion\n        new_solution = segment_list[0].copy()\n        for seg in segment_list[1:]:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], seg, new_solution[insert_pos:]])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Apply edge swap repair\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Fallback to random swap\n            while True:\n                i, j = random.sample(range(1, n), 2)\n                if new_solution[i] != new_solution[j]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{\"A new algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a multi-segment crossover with edge-preservation to generate a neighbor solution while ensuring feasibility.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment crossover with edge-preservation\n    # Select 4 random segments and recombine them in a novel pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a novel pattern\n    new_solution = np.concatenate([segment3, segment1, segment4, segment5, segment2])\n\n    # Edge-preservation: ensure no two consecutive nodes are the same\n    for i in range(n-1):\n        if new_solution[i] == new_solution[i+1]:\n            # Swap with a random node that doesn't create duplicates\n            candidates = [j for j in range(n) if new_solution[j] != new_solution[i] and new_solution[j] != new_solution[i+1]]\n            if candidates:\n                swap_pos = random.choice(candidates)\n                new_solution[i+1], new_solution[swap_pos] = new_solution[swap_pos], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.9316765352583425,
            1.4807614088058472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment crossover with edge-preservation\n    # Select 4 random segments and recombine them in a novel pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a novel pattern\n    new_solution = np.concatenate([segment3, segment1, segment4, segment5, segment2])\n\n    # Edge-preservation: ensure no two consecutive nodes are the same\n    for i in range(n-1):\n        if new_solution[i] == new_solution[i+1]:\n            # Swap with a random node that doesn't create duplicates\n            candidates = [j for j in range(n) if new_solution[j] != new_solution[i] and new_solution[j] != new_solution[i+1]]\n            if candidates:\n                swap_pos = random.choice(candidates)\n                new_solution[i+1], new_solution[swap_pos] = new_solution[swap_pos], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / distance_matrix_1.mean() + x[1][1] / distance_matrix_2.mean()))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: combine segment reversal and node insertion\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Randomly select a node and insert it elsewhere\n    node = random.choice(new_solution[1:-1])\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9992946943684163,
            0.9523524641990662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / distance_matrix_1.mean() + x[1][1] / distance_matrix_2.mean()))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: combine segment reversal and node insertion\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Randomly select a node and insert it elsewhere\n    node = random.choice(new_solution[1:-1])\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a multi-segment reversal strategy with adaptive segment length selection to generate a neighbor solution while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]  # Weight for first objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment reversal\n    num_segments = random.randint(2, min(4, n//2))\n    segments = []\n    for _ in range(num_segments):\n        seg_len = random.randint(2, min(6, n//num_segments))\n        start = random.randint(1, n - seg_len)\n        segments.append((start, start + seg_len))\n\n    # Sort segments by start position\n    segments.sort()\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Repair mechanism for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find duplicates and resolve by swapping with non-duplicated nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            dup_indices = np.where(new_solution == dup)[0]\n            for i in dup_indices[1:]:\n                # Find a non-duplicate node to swap with\n                valid_nodes = [node for node in range(n) if node not in new_solution and node != dup]\n                if valid_nodes:\n                    new_solution[i] = random.choice(valid_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.9027367389604255,
            0.2189365029335022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.7, 0.3]  # Weight for first objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment reversal\n    num_segments = random.randint(2, min(4, n//2))\n    segments = []\n    for _ in range(num_segments):\n        seg_len = random.randint(2, min(6, n//num_segments))\n        start = random.randint(1, n - seg_len)\n        segments.append((start, start + seg_len))\n\n    # Sort segments by start position\n    segments.sort()\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Repair mechanism for feasibility\n    if len(np.unique(new_solution)) != n:\n        # Find duplicates and resolve by swapping with non-duplicated nodes\n        unique, counts = np.unique(new_solution, return_counts=True)\n        duplicates = unique[counts > 1]\n        for dup in duplicates:\n            dup_indices = np.where(new_solution == dup)[0]\n            for i in dup_indices[1:]:\n                # Find a non-duplicate node to swap with\n                valid_nodes = [node for node in range(n) if node not in new_solution and node != dup]\n                if valid_nodes:\n                    new_solution[i] = random.choice(valid_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of its objective values and diversity, then applies a novel adaptive segment inversion operator that dynamically adjusts the inversion length based on the solution's current quality and the distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion operator\n    # Calculate inversion length based on solution quality and distance matrix properties\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * n)\n\n    # Determine inversion length (smaller for better solutions, larger for worse)\n    max_length = min(10, n // 2)\n    inv_length = max(2, int((1 - (total_dist1 + total_dist2) / (2 * avg_dist * n)) * max_length))\n\n    # Randomly select inversion segment\n    start = random.randint(0, n - inv_length)\n    end = start + inv_length\n\n    # Invert the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8957682566414114,
            1.5130317211151123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion operator\n    # Calculate inversion length based on solution quality and distance matrix properties\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * n)\n\n    # Determine inversion length (smaller for better solutions, larger for worse)\n    max_length = min(10, n // 2)\n    inv_length = max(2, int((1 - (total_dist1 + total_dist2) / (2 * avg_dist * n)) * max_length))\n\n    # Randomly select inversion segment\n    start = random.randint(0, n - inv_length)\n    end = start + inv_length\n\n    # Invert the selected segment\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of crowding distance and objective value, then applies a novel 3-segment relocation and inversion operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel 3-segment relocation and inversion operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # With 50% probability, invert one segment\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Recombine segments in a new order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment3, segment2, segment1, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.970283054762204,
            1.5631060600280762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel 3-segment relocation and inversion operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # With 50% probability, invert one segment\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Recombine segments in a new order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment3, segment2, segment1, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge-swap and segment-reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    if random.random() < 0.5:\n        # Edge-swap: swap two edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment-reversal: reverse a segment between two points\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.886636599360874,
            1.4595654010772705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge-swap and segment-reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    if random.random() < 0.5:\n        # Edge-swap: swap two edges\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment-reversal: reverse a segment between two points\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining segment reversal with a novel edge insertion strategy to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with better combined objective and higher diversity\n        selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2 + np.std(x[0]))\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Novel edge insertion: move a random node to a different position\n    if n > 3:\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8109231413219715,
            1.6806157231330872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prefer solutions with better combined objective and higher diversity\n        selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2 + np.std(x[0]))\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Novel edge insertion: move a random node to a different position\n    if n > 3:\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel weighted score combining objective values and solution diversity, then applies a hybrid local search combining segment reversal and edge-swap operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge-swap between two random edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7835834370907446,
            0.23974400758743286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge-swap between two random edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to simple segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A novel algorithm that selects solutions based on a weighted dominance score combining objective values and local improvement potential, then applies a hybrid segment relocation and inversion operator to generate diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol):\n        obj = sol[1]\n        # Dominance count (number of solutions it dominates)\n        dom_count = sum(1 for s in archive if s[1][0] > obj[0] and s[1][1] > obj[1])\n        # Normalized objective sum\n        norm_obj = (obj[0] + obj[1]) / (max(s[1][0] + s[1][1] for s in archive) + 1e-6)\n        return dom_count * (1 - norm_obj)\n\n    selected_solution = max(archive, key=dominance_score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid segment relocation and inversion operator\n    # Select two random segments and invert one of them\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Invert one segment with 70% probability\n    if random.random() < 0.7:\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n        else:\n            segment3 = segment3[::-1]\n\n    # Relocate segments with 50% probability\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        new_solution = np.concatenate([segment2, segment1, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6482277712417798,
            0.28454679250717163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol):\n        obj = sol[1]\n        # Dominance count (number of solutions it dominates)\n        dom_count = sum(1 for s in archive if s[1][0] > obj[0] and s[1][1] > obj[1])\n        # Normalized objective sum\n        norm_obj = (obj[0] + obj[1]) / (max(s[1][0] + s[1][1] for s in archive) + 1e-6)\n        return dom_count * (1 - norm_obj)\n\n    selected_solution = max(archive, key=dominance_score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid segment relocation and inversion operator\n    # Select two random segments and invert one of them\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Invert one segment with 70% probability\n    if random.random() < 0.7:\n        if random.random() < 0.5:\n            segment2 = segment2[::-1]\n        else:\n            segment3 = segment3[::-1]\n\n    # Relocate segments with 50% probability\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment3, segment2])\n    else:\n        new_solution = np.concatenate([segment2, segment1, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm selects the solution with the highest combined objective value from the archive, then applies a novel segment-based local search that combines two randomly selected segments by reversing and reordering them while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments are non-overlapping\n    if a < c < b or a < d < b:\n        c, d = b, c\n\n    # Extract segments and reverse them\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Recombine segments with a novel reordering\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Validate and fix if necessary\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9835027807066692,
            0.20304930210113525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Ensure segments are non-overlapping\n    if a < c < b or a < d < b:\n        c, d = b, c\n\n    # Extract segments and reverse them\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Recombine segments with a novel reordering\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Validate and fix if necessary\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid score combining objective values and dominance relationships, then applies a multi-segment relocation operator with probabilistic segment reordering to generate a neighbor solution while ensuring feasibility through a simple swap fix if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid multi-segment relocation with probabilistic segment inversion\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Randomly invert segments with 30% probability\n    if random.random() < 0.3:\n        segment1 = segment1[::-1]\n    if random.random() < 0.3:\n        segment2 = segment2[::-1]\n    if random.random() < 0.3:\n        segment3 = segment3[::-1]\n    if random.random() < 0.3:\n        segment4 = segment4[::-1]\n\n    # Recombine segments in a new order (with 40% probability of each permutation)\n    if random.random() < 0.4:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2])\n    elif random.random() < 0.8:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3])\n    else:\n        new_solution = np.concatenate([segment4, segment3, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9083792402358926,
            1.4801825284957886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid multi-segment relocation with probabilistic segment inversion\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Randomly invert segments with 30% probability\n    if random.random() < 0.3:\n        segment1 = segment1[::-1]\n    if random.random() < 0.3:\n        segment2 = segment2[::-1]\n    if random.random() < 0.3:\n        segment3 = segment3[::-1]\n    if random.random() < 0.3:\n        segment4 = segment4[::-1]\n\n    # Recombine segments in a new order (with 40% probability of each permutation)\n    if random.random() < 0.4:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2])\n    elif random.random() < 0.8:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3])\n    else:\n        new_solution = np.concatenate([segment4, segment3, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with balanced objective values, then applies a novel adaptive segment inversion and crossover operator that dynamically adjusts the segment sizes and crossover points based on the solution's current quality, ensuring feasibility through a validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion\n    segment_size = max(2, min(5, int(n * 0.2)))  # Dynamic segment size\n    start = random.randint(1, n - segment_size - 1)\n    new_solution[start:start+segment_size] = np.flip(new_solution[start:start+segment_size])\n\n    # Novel crossover with another random solution\n    if len(archive) > 1:\n        crossover_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], selected_solution)])\n        crossover_point = random.randint(1, n - 1)\n        new_solution[crossover_point:] = crossover_solution[crossover_point:]\n\n    # Validation and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a greedy repair\n        missing = set(range(n)) - set(new_solution)\n        for i in range(n):\n            if new_solution[i] not in range(n):\n                new_solution[i] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8745647950630104,
            0.2922537326812744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion\n    segment_size = max(2, min(5, int(n * 0.2)))  # Dynamic segment size\n    start = random.randint(1, n - segment_size - 1)\n    new_solution[start:start+segment_size] = np.flip(new_solution[start:start+segment_size])\n\n    # Novel crossover with another random solution\n    if len(archive) > 1:\n        crossover_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], selected_solution)])\n        crossover_point = random.randint(1, n - 1)\n        new_solution[crossover_point:] = crossover_solution[crossover_point:]\n\n    # Validation and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a greedy repair\n        missing = set(range(n)) - set(new_solution)\n        for i in range(n):\n            if new_solution[i] not in range(n):\n                new_solution[i] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of its objective values and the number of solutions it dominates, then applies a novel multi-segment inversion operator that flips multiple non-overlapping segments of the tour in a coordinated manner to explore the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them in a coordinated manner\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments with 66% probability of each permutation\n    if random.random() < 0.33:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n        new_solution[c:] = np.flip(new_solution[c:])\n    elif random.random() < 0.66:\n        new_solution[:a] = np.flip(new_solution[:a])\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:] = np.flip(new_solution[b:])\n    else:\n        new_solution[:a] = np.flip(new_solution[:a])\n        new_solution[a:c] = np.flip(new_solution[a:c])\n        new_solution[c:] = np.flip(new_solution[c:])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.940605189426762,
            1.5335862636566162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them in a coordinated manner\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments with 66% probability of each permutation\n    if random.random() < 0.33:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n        new_solution[c:] = np.flip(new_solution[c:])\n    elif random.random() < 0.66:\n        new_solution[:a] = np.flip(new_solution[:a])\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:] = np.flip(new_solution[b:])\n    else:\n        new_solution[:a] = np.flip(new_solution[:a])\n        new_solution[a:c] = np.flip(new_solution[a:c])\n        new_solution[c:] = np.flip(new_solution[c:])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and a position to reinsert\n    a, b = sorted(random.sample(range(1, n), 2))\n    pos = random.randint(1, n - (b - a))\n\n    # Apply segment reversal and reinsertion\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.952816214299081,
            0.22551584243774414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and a position to reinsert\n    a, b = sorted(random.sample(range(1, n), 2))\n    pos = random.randint(1, n - (b - a))\n\n    # Apply segment reversal and reinsertion\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge swapping while ensuring feasibility through validation and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] * (1 / distance_matrix_1.mean()) + x[1][1] * (1 / distance_matrix_2.mean())))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge swapping if valid\n    if c < a < d < b and len(np.unique(new_solution)) == n:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Validate and fix if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7994700024143555,
            0.8550360202789307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] * (1 / distance_matrix_1.mean()) + x[1][1] * (1 / distance_matrix_2.mean())))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge swapping if valid\n    if c < a < d < b and len(np.unique(new_solution)) == n:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Validate and fix if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if (y[1][0] < x[1][0] and y[1][1] < x[1][1]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on distance matrices\n    # Select segments that are high-cost in either objective space\n    segment_start = random.randint(1, n-3)\n    segment_length = random.randint(2, min(5, n-segment_start-1))\n\n    # Extract segments\n    segment = new_solution[segment_start:segment_start+segment_length]\n    left = new_solution[:segment_start]\n    right = new_solution[segment_start+segment_length:]\n\n    # Calculate segment costs\n    def segment_cost(seg, dm):\n        cost = 0\n        for i in range(len(seg)-1):\n            cost += dm[seg[i], seg[i+1]]\n        return cost\n\n    seg_cost1 = segment_cost(segment, distance_matrix_1)\n    seg_cost2 = segment_cost(segment, distance_matrix_2)\n\n    # Reinsert segment in a position that improves both objectives\n    best_pos = segment_start\n    best_improvement = 0\n\n    for pos in range(1, n-segment_length+1):\n        if pos == segment_start:\n            continue\n\n        # Temporary insertion\n        temp = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(np.unique(temp)) != n:\n            continue\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n        new_cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n        # Calculate improvement\n        improvement = (seg_cost1 + seg_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best found position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment reversal to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9048304378389939,
            1.702143907546997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if (y[1][0] < x[1][0] and y[1][1] < x[1][1]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on distance matrices\n    # Select segments that are high-cost in either objective space\n    segment_start = random.randint(1, n-3)\n    segment_length = random.randint(2, min(5, n-segment_start-1))\n\n    # Extract segments\n    segment = new_solution[segment_start:segment_start+segment_length]\n    left = new_solution[:segment_start]\n    right = new_solution[segment_start+segment_length:]\n\n    # Calculate segment costs\n    def segment_cost(seg, dm):\n        cost = 0\n        for i in range(len(seg)-1):\n            cost += dm[seg[i], seg[i+1]]\n        return cost\n\n    seg_cost1 = segment_cost(segment, distance_matrix_1)\n    seg_cost2 = segment_cost(segment, distance_matrix_2)\n\n    # Reinsert segment in a position that improves both objectives\n    best_pos = segment_start\n    best_improvement = 0\n\n    for pos in range(1, n-segment_length+1):\n        if pos == segment_start:\n            continue\n\n        # Temporary insertion\n        temp = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(np.unique(temp)) != n:\n            continue\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n        new_cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n        # Calculate improvement\n        improvement = (seg_cost1 + seg_cost2) - (new_cost1 + new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best found position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment reversal to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = {}\n    for sol, obj in archive:\n        dominance_counts[tuple(sol)] = sum(1 for _, other_obj in archive if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]))\n\n    # Calculate crowding distance for each solution\n    def crowding_distance(sol):\n        objs = [obj for s, obj in archive if tuple(s) == tuple(sol)]\n        if len(objs) < 2:\n            return float('inf')\n        objs_sorted = sorted(objs)\n        distance = 0\n        for i in range(2):\n            if len(objs_sorted) > 1:\n                distance += objs_sorted[-1][i] - objs_sorted[0][i]\n        return distance\n\n    # Select solution with highest dominance and lowest crowding distance\n    selected_solution = max(archive, key=lambda x: dominance_counts[tuple(x[0])] - crowding_distance(x[0]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover operator\n    # Randomly select 4 distinct segments and recombine them in a non-sequential order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create four segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a random non-sequential order\n    order = random.sample([1, 2, 3, 4], 4)\n    new_segments = [segment1, segment2, segment3, segment4]\n    new_solution = np.concatenate([new_segments[i-1] for i in order])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random shuffle to fix\n        remaining_nodes = [node for node in range(n) if node not in new_solution]\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                new_solution[i] = remaining_nodes.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.8265204149405735,
            9.80978387594223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = {}\n    for sol, obj in archive:\n        dominance_counts[tuple(sol)] = sum(1 for _, other_obj in archive if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]))\n\n    # Calculate crowding distance for each solution\n    def crowding_distance(sol):\n        objs = [obj for s, obj in archive if tuple(s) == tuple(sol)]\n        if len(objs) < 2:\n            return float('inf')\n        objs_sorted = sorted(objs)\n        distance = 0\n        for i in range(2):\n            if len(objs_sorted) > 1:\n                distance += objs_sorted[-1][i] - objs_sorted[0][i]\n        return distance\n\n    # Select solution with highest dominance and lowest crowding distance\n    selected_solution = max(archive, key=lambda x: dominance_counts[tuple(x[0])] - crowding_distance(x[0]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover operator\n    # Randomly select 4 distinct segments and recombine them in a non-sequential order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create four segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a random non-sequential order\n    order = random.sample([1, 2, 3, 4], 4)\n    new_segments = [segment1, segment2, segment3, segment4]\n    new_solution = np.concatenate([new_segments[i-1] for i in order])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random shuffle to fix\n        remaining_nodes = [node for node in range(n) if node not in new_solution]\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                new_solution[i] = remaining_nodes.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection criterion, then applies a novel multi-segment inversion operator that reverses segments of the tour while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] > x[1][0] and y[1][1] > x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert each segment\n    a, b = sorted(random.sample(range(1, n), 2))\n\n    # Invert two segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select another segment and invert it\n    c, d = sorted(random.sample(range(1, n), 2))\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8934949105151903,
            0.21660888195037842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] > x[1][0] and y[1][1] > x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert each segment\n    a, b = sorted(random.sample(range(1, n), 2))\n\n    # Invert two segments\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select another segment and invert it\n    c, d = sorted(random.sample(range(1, n), 2))\n    new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A new algorithm that selects a solution with high potential for improvement by considering both objective values and their dominance relationships, then applies a novel segment-based crossover operator that combines parts of multiple solutions to create a high-quality neighbor.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated_count = {sol[0].tobytes(): sum(1 for other in archive if other[1][0] < sol[1][0] and other[1][1] < sol[1][1])\n                      for sol in archive}\n    selected_solution = min(archive, key=lambda x: dominated_count[x[0].tobytes()])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover with multiple parents\n    # Select 2-3 other solutions from archive and combine segments\n    parents = random.sample(archive, min(3, len(archive)))\n    segments = []\n    for parent in parents:\n        # Randomly split each parent into 3 segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        segments.extend([parent[0][:a], parent[0][a:b], parent[0][b:]])\n\n    # Shuffle and recombine segments while maintaining feasibility\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by removing duplicates and restoring missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    missing = [node for node in range(n) if node not in unique]\n    duplicates = [node for node in unique if counts[np.where(unique == node)[0][0]] > 1]\n\n    for dup in duplicates:\n        idx = np.where(new_solution == dup)[0][1:]  # All but first occurrence\n        for i in idx:\n            if missing:\n                new_solution[i] = missing.pop(0)\n            else:\n                # If no missing nodes, swap with another duplicate\n                swap_idx = np.where(new_solution == duplicates[-1])[0][1]\n                new_solution[i], new_solution[swap_idx] = new_solution[swap_idx], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9434859482223846,
            1.5453804731369019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated_count = {sol[0].tobytes(): sum(1 for other in archive if other[1][0] < sol[1][0] and other[1][1] < sol[1][1])\n                      for sol in archive}\n    selected_solution = min(archive, key=lambda x: dominated_count[x[0].tobytes()])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment-based crossover with multiple parents\n    # Select 2-3 other solutions from archive and combine segments\n    parents = random.sample(archive, min(3, len(archive)))\n    segments = []\n    for parent in parents:\n        # Randomly split each parent into 3 segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        segments.extend([parent[0][:a], parent[0][a:b], parent[0][b:]])\n\n    # Shuffle and recombine segments while maintaining feasibility\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by removing duplicates and restoring missing nodes\n    unique, counts = np.unique(new_solution, return_counts=True)\n    missing = [node for node in range(n) if node not in unique]\n    duplicates = [node for node in unique if counts[np.where(unique == node)[0][0]] > 1]\n\n    for dup in duplicates:\n        idx = np.where(new_solution == dup)[0][1:]  # All but first occurrence\n        for i in idx:\n            if missing:\n                new_solution[i] = missing.pop(0)\n            else:\n                # If no missing nodes, swap with another duplicate\n                swap_idx = np.where(new_solution == duplicates[-1])[0][1]\n                new_solution[i], new_solution[swap_idx] = new_solution[swap_idx], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted sum of objectives with randomized weights, then applies a hybrid local search combining segment reversal and edge swapping, ensuring feasibility by validating the solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weight1, weight2 = random.random(), random.random()\n    selected_solution = max(archive, key=lambda x: weight1 * x[1][0] + weight2 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swap between two random positions\n    i, j = random.sample(range(1, n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6548549972237551,
            0.21722090244293213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weight1, weight2 = random.random(), random.random()\n    selected_solution = max(archive, key=lambda x: weight1 * x[1][0] + weight2 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swap between two random positions\n    i, j = random.sample(range(1, n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: segment reversal followed by node exchange\n    # Step 1: Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Step 2: Randomly select two nodes and exchange them if it improves both objectives\n    i, j = random.sample(range(1, n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Only perform exchange if both objectives improve\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7998457621529977,
            1.272243857383728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: segment reversal followed by node exchange\n    # Step 1: Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Step 2: Randomly select two nodes and exchange them if it improves both objectives\n    i, j = random.sample(range(1, n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Only perform exchange if both objectives improve\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive based on a modified score function that prioritizes solutions with high potential for improvement in both objectives, then applies a novel multi-segment relocation operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator combining segment relocation and swap\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Recombine with probability-based permutation\n    if random.random() < 0.6:\n        new_solution = np.concatenate([segment2, segment3, segment1])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment2])\n\n    # Ensure feasibility with additional swap if needed\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional swap with probability 0.3\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9162171446917861,
            1.6821184754371643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator combining segment relocation and swap\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Recombine with probability-based permutation\n    if random.random() < 0.6:\n        new_solution = np.concatenate([segment2, segment3, segment1])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment2])\n\n    # Ensure feasibility with additional swap if needed\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional swap with probability 0.3\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{A novel local search strategy that combines random segment reversal with a biased edge insertion mechanism, where the insertion point is chosen based on the relative improvement in both objective spaces, ensuring a more diverse and effective neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Biased edge insertion: find the best insertion point for the first node of the reversed segment\n    best_pos = a\n    best_score = float('inf')\n    for i in range(n):\n        if i == a:\n            continue\n        # Calculate the cost of inserting node at position i\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(i+1)%n]]\n        total_cost = cost1 + cost2\n        if total_cost < best_score:\n            best_score = total_cost\n            best_pos = i\n\n    # Insert the node at the best position\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9306060953169116,
            0.24821996688842773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Biased edge insertion: find the best insertion point for the first node of the reversed segment\n    best_pos = a\n    best_score = float('inf')\n    for i in range(n):\n        if i == a:\n            continue\n        # Calculate the cost of inserting node at position i\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(i+1)%n]]\n        total_cost = cost1 + cost2\n        if total_cost < best_score:\n            best_score = total_cost\n            best_pos = i\n\n    # Insert the node at the best position\n    node = new_solution[a]\n    new_solution = np.delete(new_solution, a)\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel hybrid local search that combines a segment reversal with a custom edge reordering strategy, while ensuring feasibility through validation checks and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: Segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and reorder edges between segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge reordering between segments\n    if a < c < b < d:\n        new_solution[c:b] = np.flip(new_solution[c:b])\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9486115593179336,
            0.24487406015396118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: Segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and reorder edges between segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge reordering between segments\n    if a < c < b < d:\n        new_solution[c:b] = np.flip(new_solution[c:b])\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a novel hybrid local search operator that combines edge reinsertion with a multi-segment crossover strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search operator\n    # Step 1: Randomly select two edges and remove them\n    i, j = sorted(random.sample(range(1, n), 2))\n    removed_nodes = new_solution[i:j]\n    new_solution = np.delete(new_solution, range(i, j))\n\n    # Step 2: Find the best position to reinsert the removed nodes using a novel cost function\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(1, len(new_solution)):\n        # Create temporary solution\n        temp_solution = np.insert(new_solution, pos, removed_nodes)\n\n        # Calculate cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, len(temp_solution)))\n\n        # Combine costs with a weighted sum (0.7 for first objective, 0.3 for second)\n        combined_cost = 0.7 * cost1 + 0.3 * cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    # Reinsert at best position\n    new_solution = np.insert(new_solution, best_pos, removed_nodes)\n\n    # Step 3: Apply a multi-segment crossover for further improvement\n    if len(new_solution) > 4:\n        # Randomly select two crossover points\n        a, b = sorted(random.sample(range(1, len(new_solution)-1), 2))\n\n        # Create two segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Recombine segments with 50% probability\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment2, segment3, segment1])\n        else:\n            new_solution = np.concatenate([segment3, segment1, segment2])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.956538519814496,
            1.8479632139205933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search operator\n    # Step 1: Randomly select two edges and remove them\n    i, j = sorted(random.sample(range(1, n), 2))\n    removed_nodes = new_solution[i:j]\n    new_solution = np.delete(new_solution, range(i, j))\n\n    # Step 2: Find the best position to reinsert the removed nodes using a novel cost function\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(1, len(new_solution)):\n        # Create temporary solution\n        temp_solution = np.insert(new_solution, pos, removed_nodes)\n\n        # Calculate cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, len(temp_solution)))\n\n        # Combine costs with a weighted sum (0.7 for first objective, 0.3 for second)\n        combined_cost = 0.7 * cost1 + 0.3 * cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    # Reinsert at best position\n    new_solution = np.insert(new_solution, best_pos, removed_nodes)\n\n    # Step 3: Apply a multi-segment crossover for further improvement\n    if len(new_solution) > 4:\n        # Randomly select two crossover points\n        a, b = sorted(random.sample(range(1, len(new_solution)-1), 2))\n\n        # Create two segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Recombine segments with 50% probability\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment2, segment3, segment1])\n        else:\n            new_solution = np.concatenate([segment3, segment1, segment2])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert their order\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the segment between a and b\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # With 30% probability, apply a random 3-opt move to further diversify\n    if random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8646424209685954,
            1.4761322140693665
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 2 distinct segments and invert their order\n    segments = sorted(random.sample(range(1, n), 2))\n    a, b = segments[0], segments[1]\n\n    # Invert the segment between a and b\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # With 30% probability, apply a random 3-opt move to further diversify\n    if random.random() < 0.3:\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a solution from the archive based on the sum of normalized objective values, then applies a novel \"segment rotation\" operator that rotates segments of the tour by a random angle while maintaining feasibility through careful edge reordering and duplicate checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj = max(x[1] for x in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_obj[0] + x[1][1]/max_obj[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select random segment and rotation angle\n    a, b = sorted(random.sample(range(1, n), 2))\n    angle = random.uniform(0, 2*np.pi)\n\n    # Rotate segment around centroid\n    segment = new_solution[a:b]\n    centroid = np.mean(instance[segment], axis=0)\n    rotated = np.zeros_like(segment)\n\n    for i, node in enumerate(segment):\n        x1, y1, x2, y2 = instance[node]\n        # Rotate in first space\n        dx1 = x1 - centroid[0]\n        dy1 = y1 - centroid[1]\n        new_x1 = centroid[0] + dx1 * np.cos(angle) - dy1 * np.sin(angle)\n        new_y1 = centroid[1] + dx1 * np.sin(angle) + dy1 * np.cos(angle)\n\n        # Find closest node in second space\n        distances = np.sqrt((instance[:,2] - new_x1)**2 + (instance[:,3] - new_y1)**2)\n        rotated[i] = np.argmin(distances)\n\n    # Reorder rotated nodes to maintain tour continuity\n    new_solution[a:b] = rotated\n\n    # Check feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9414012606008901,
            0.16438370943069458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj = max(x[1] for x in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_obj[0] + x[1][1]/max_obj[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select random segment and rotation angle\n    a, b = sorted(random.sample(range(1, n), 2))\n    angle = random.uniform(0, 2*np.pi)\n\n    # Rotate segment around centroid\n    segment = new_solution[a:b]\n    centroid = np.mean(instance[segment], axis=0)\n    rotated = np.zeros_like(segment)\n\n    for i, node in enumerate(segment):\n        x1, y1, x2, y2 = instance[node]\n        # Rotate in first space\n        dx1 = x1 - centroid[0]\n        dy1 = y1 - centroid[1]\n        new_x1 = centroid[0] + dx1 * np.cos(angle) - dy1 * np.sin(angle)\n        new_y1 = centroid[1] + dx1 * np.sin(angle) + dy1 * np.cos(angle)\n\n        # Find closest node in second space\n        distances = np.sqrt((instance[:,2] - new_x1)**2 + (instance[:,3] - new_y1)**2)\n        rotated[i] = np.argmin(distances)\n\n    # Reorder rotated nodes to maintain tour continuity\n    new_solution[a:b] = rotated\n\n    # Check feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion and reinsertion strategy\n    # Randomly select 3 distinct segments and invert them, then reinsert them in a new order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments and invert them\n    segment1 = np.flip(new_solution[:a])\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment3, segment2, segment4, segment1])\n    else:\n        new_solution = np.concatenate([segment1, segment4, segment2, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9091065851501334,
            0.20153015851974487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion and reinsertion strategy\n    # Randomly select 3 distinct segments and invert them, then reinsert them in a new order\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments and invert them\n    segment1 = np.flip(new_solution[:a])\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment3, segment2, segment4, segment1])\n    else:\n        new_solution = np.concatenate([segment1, segment4, segment2, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(sol):\n        neighbors = [s for s in archive if s[1] != sol[1]]\n        if not neighbors:\n            return 0\n        dist1 = min(abs(sol[1][0] - n[1][0]) for n in neighbors)\n        dist2 = min(abs(sol[1][1] - n[1][1]) for n in neighbors)\n        return dist1 + dist2\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid operator: segment inversion and selective swaps\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]  # Invert segment\n\n    # Selective swaps based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(1, n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.802294568775042,
            1.4668267369270325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(sol):\n        neighbors = [s for s in archive if s[1] != sol[1]]\n        if not neighbors:\n            return 0\n        dist1 = min(abs(sol[1][0] - n[1][0]) for n in neighbors)\n        dist2 = min(abs(sol[1][1] - n[1][1]) for n in neighbors)\n        return dist1 + dist2\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    # Hybrid operator: segment inversion and selective swaps\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]  # Invert segment\n\n    # Selective swaps based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(1, n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of its objective values and diversity, then applies a novel combination of segment reversal and insertion operators to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: combine segment reversal with strategic insertion\n    # Randomly select two non-overlapping segments and reverse one, then insert it into another position\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Ensure segments don't overlap\n    while (a <= d <= b) or (c <= b <= d):\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the first segment\n    reversed_segment = np.flip(new_solution[a:b])\n\n    # Remove the original segment\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Insert the reversed segment at a new position (c)\n    new_solution = np.concatenate([new_solution[:c], reversed_segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple segment swap to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.875623196056993,
            1.4909935593605042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: combine segment reversal with strategic insertion\n    # Randomly select two non-overlapping segments and reverse one, then insert it into another position\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Ensure segments don't overlap\n    while (a <= d <= b) or (c <= b <= d):\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse the first segment\n    reversed_segment = np.flip(new_solution[a:b])\n\n    # Remove the original segment\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Insert the reversed segment at a new position (c)\n    new_solution = np.concatenate([new_solution[:c], reversed_segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple segment swap to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{My new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and a novel edge-swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Novel edge-swap: reverse segments and swap edges between them\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9521709326754578,
            0.2145581841468811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Novel edge-swap: reverse segments and swap edges between them\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion and reinsertion operator\n    # Randomly select 4 distinct segments and invert and reinsert them in a new position\n    segments = sorted(random.sample(range(1, n-1), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments and invert them\n    segment1 = new_solution[:a]\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = new_solution[c:d]\n    segment5 = np.flip(new_solution[d:])\n\n    # Reinsert segments in a new order (random permutation)\n    segments_list = [segment2, segment3, segment4, segment5]\n    random.shuffle(segments_list)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([segment1] + segments_list)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9034291642845995,
            0.2081228494644165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion and reinsertion operator\n    # Randomly select 4 distinct segments and invert and reinsert them in a new position\n    segments = sorted(random.sample(range(1, n-1), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments and invert them\n    segment1 = new_solution[:a]\n    segment2 = np.flip(new_solution[a:b])\n    segment3 = np.flip(new_solution[b:c])\n    segment4 = new_solution[c:d]\n    segment5 = np.flip(new_solution[d:])\n\n    # Reinsert segments in a new order (random permutation)\n    segments_list = [segment2, segment3, segment4, segment5]\n    random.shuffle(segments_list)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([segment1] + segments_list)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a reference solution from the archive for segment-based crossover\n    ref_solution = random.choice(archive)[0].copy()\n\n    # Find the longest common subsequence (LCS) between the selected and reference solutions\n    # This helps identify structurally similar segments between the two solutions\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if selected_solution[i] == ref_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Select a random segment from the LCS to preserve in the new solution\n        start, end = random.choice(lcs)\n        preserved_segment = selected_solution[start:end+1]\n\n        # Fill the remaining positions with nodes from the reference solution that aren't in the preserved segment\n        remaining_nodes = [node for node in ref_solution if node not in preserved_segment]\n        new_solution = np.concatenate([preserved_segment, remaining_nodes])\n\n        # Ensure feasibility by checking for duplicates and fixing if needed\n        if len(np.unique(new_solution)) != n:\n            # If invalid, apply a simple swap to fix\n            i, j = random.sample(range(1, n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no LCS found, apply a random segment relocation\n        segments = sorted(random.sample(range(1, n), 2))\n        a, b = segments[0], segments[1]\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.7591453101936452,
            8.934834480285645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a reference solution from the archive for segment-based crossover\n    ref_solution = random.choice(archive)[0].copy()\n\n    # Find the longest common subsequence (LCS) between the selected and reference solutions\n    # This helps identify structurally similar segments between the two solutions\n    lcs = []\n    for i in range(n):\n        for j in range(n):\n            if selected_solution[i] == ref_solution[j]:\n                lcs.append((i, j))\n\n    if lcs:\n        # Select a random segment from the LCS to preserve in the new solution\n        start, end = random.choice(lcs)\n        preserved_segment = selected_solution[start:end+1]\n\n        # Fill the remaining positions with nodes from the reference solution that aren't in the preserved segment\n        remaining_nodes = [node for node in ref_solution if node not in preserved_segment]\n        new_solution = np.concatenate([preserved_segment, remaining_nodes])\n\n        # Ensure feasibility by checking for duplicates and fixing if needed\n        if len(np.unique(new_solution)) != n:\n            # If invalid, apply a simple swap to fix\n            i, j = random.sample(range(1, n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no LCS found, apply a random segment relocation\n        segments = sorted(random.sample(range(1, n), 2))\n        a, b = segments[0], segments[1]\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{Select a solution from the archive with high combined objective value and apply a novel local search that combines segment reversal with a probabilistic edge insertion strategy to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Probabilistic segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly insert a node from another segment to create diversity\n    if random.random() < 0.5:\n        c = random.randint(1, n-1)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9121480602551555,
            0.21227478981018066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Probabilistic segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly insert a node from another segment to create diversity\n    if random.random() < 0.5:\n        c = random.randint(1, n-1)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator\n    # Randomly select 4 distinct segments and reinsert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:d]\n    seg5 = new_solution[d:]\n\n    # Create 4 possible permutations and choose one randomly\n    permutations = [\n        np.concatenate([seg2, seg4, seg1, seg3, seg5]),\n        np.concatenate([seg3, seg1, seg5, seg2, seg4]),\n        np.concatenate([seg4, seg5, seg2, seg1, seg3]),\n        np.concatenate([seg1, seg3, seg4, seg5, seg2])\n    ]\n    new_solution = random.choice(permutations)\n\n    # Dynamic segment repair: if invalid, find the minimal segment to swap\n    if len(np.unique(new_solution)) != n:\n        # Identify duplicate nodes\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n        # Find minimal segments containing duplicates\n        for i in range(1, n):\n            for j in range(i+1, n+1):\n                segment = new_solution[i:j]\n                if any(node in duplicates for node in segment):\n                    # Swap with a random segment of same length\n                    k = random.randint(1, n - len(segment))\n                    new_solution[k:k+len(segment)] = segment\n                    break\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8939259931883512,
            1.5012274980545044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator\n    # Randomly select 4 distinct segments and reinsert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Extract segments\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:d]\n    seg5 = new_solution[d:]\n\n    # Create 4 possible permutations and choose one randomly\n    permutations = [\n        np.concatenate([seg2, seg4, seg1, seg3, seg5]),\n        np.concatenate([seg3, seg1, seg5, seg2, seg4]),\n        np.concatenate([seg4, seg5, seg2, seg1, seg3]),\n        np.concatenate([seg1, seg3, seg4, seg5, seg2])\n    ]\n    new_solution = random.choice(permutations)\n\n    # Dynamic segment repair: if invalid, find the minimal segment to swap\n    if len(np.unique(new_solution)) != n:\n        # Identify duplicate nodes\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n        # Find minimal segments containing duplicates\n        for i in range(1, n):\n            for j in range(i+1, n+1):\n                segment = new_solution[i:j]\n                if any(node in duplicates for node in segment):\n                    # Swap with a random segment of same length\n                    k = random.randint(1, n - len(segment))\n                    new_solution[k:k+len(segment)] = segment\n                    break\n            if len(np.unique(new_solution)) == n:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = sum(1 for sol_j, obj_j in archive if obj_j[0] < obj_i[0] and obj_j[1] < obj_i[1])\n        dominance_counts.append((count, i))\n    selected_idx = min(dominance_counts, key=lambda x: x[0])[1]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid 3-opt and segment inversion operator\n    # Step 1: Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Step 2: Perform 3-opt by reversing segments with probability 0.7\n    if random.random() < 0.7:\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Step 3: Perform segment inversion (swap two segments)\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9183159798239254,
            0.38288724422454834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = sum(1 for sol_j, obj_j in archive if obj_j[0] < obj_i[0] and obj_j[1] < obj_i[1])\n        dominance_counts.append((count, i))\n    selected_idx = min(dominance_counts, key=lambda x: x[0])[1]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid 3-opt and segment inversion operator\n    # Step 1: Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Step 2: Perform 3-opt by reversing segments with probability 0.7\n    if random.random() < 0.7:\n        if random.random() < 0.5:\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            new_solution[b:c] = new_solution[b:c][::-1]\n    else:\n        # Step 3: Perform segment inversion (swap two segments)\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, applies a hybrid local search combining segment reversal and edge-swap operations, and ensures feasibility by reverting to a simpler move if invalid, while introducing randomness in segment selection to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9541610072785103,
            0.21328210830688477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{A new algorithm that prioritizes solutions with high variance in objective values to encourage exploration, then applies a hybrid local search combining segment reversal and edge insertion for more diverse neighborhood generation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal followed by edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select two positions and insert a node\n    i, j = sorted(random.sample(range(1, n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5603966433299005,
            0.1929829716682434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal followed by edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select two positions and insert a node\n    i, j = sorted(random.sample(range(1, n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects the solution with the best average objective value from the archive, then applies a novel \"multi-segment rotation\" local search operator that randomly selects three segments of the tour and rotates their positions while ensuring feasibility through a greedy validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to rotate\n    points = sorted(random.sample(range(1, n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Create candidate solutions by rotating segments\n    candidates = []\n    # Rotation 1: a-b-c -> b-c-a\n    candidate1 = new_solution.copy()\n    candidate1[a:c] = np.concatenate([new_solution[b:c], new_solution[a:b]])\n    candidates.append(candidate1)\n\n    # Rotation 2: a-b-c -> c-a-b\n    candidate2 = new_solution.copy()\n    candidate2[a:c] = np.concatenate([new_solution[c-1:c], new_solution[a:c-1]])\n    candidates.append(candidate2)\n\n    # Select the best candidate based on objective improvement\n    best_candidate = min(candidates, key=lambda x: (sum(distance_matrix_1[x[i], x[i+1]] for i in range(n-1)) + sum(distance_matrix_2[x[i], x[i+1]] for i in range(n-1))))\n\n    # Ensure feasibility\n    if len(np.unique(best_candidate)) == n:\n        return best_candidate\n    else:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            -0.8850683003383373,
            0.23782873153686523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to rotate\n    points = sorted(random.sample(range(1, n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Create candidate solutions by rotating segments\n    candidates = []\n    # Rotation 1: a-b-c -> b-c-a\n    candidate1 = new_solution.copy()\n    candidate1[a:c] = np.concatenate([new_solution[b:c], new_solution[a:b]])\n    candidates.append(candidate1)\n\n    # Rotation 2: a-b-c -> c-a-b\n    candidate2 = new_solution.copy()\n    candidate2[a:c] = np.concatenate([new_solution[c-1:c], new_solution[a:c-1]])\n    candidates.append(candidate2)\n\n    # Select the best candidate based on objective improvement\n    best_candidate = min(candidates, key=lambda x: (sum(distance_matrix_1[x[i], x[i+1]] for i in range(n-1)) + sum(distance_matrix_2[x[i], x[i+1]] for i in range(n-1))))\n\n    # Ensure feasibility\n    if len(np.unique(best_candidate)) == n:\n        return best_candidate\n    else:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by dominance count (higher is better)\n        dominance_counts = []\n        for sol, obj in archive:\n            count = sum(1 for _, other_obj in archive if other_obj[0] < obj[0] and other_obj[1] < obj[1])\n            dominance_counts.append(count)\n        # Sort by dominance and then by crowding distance (simplified)\n        sorted_indices = sorted(range(len(archive)), key=lambda i: (-dominance_counts[i], (archive[i][1][0] + archive[i][1][1])))\n        selected_solution = archive[sorted_indices[0]][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt* operator: select 3 edges and reconnect them in all possible ways, keeping the best\n    i, j, k = sorted(random.sample(range(n), 3))\n    # Original edges: (i,i+1), (j,j+1), (k,k+1)\n    # Generate all possible reconnections (8 cases for 3-opt*)\n    candidates = []\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                for c in [i, j, k]:\n                    if a != c and b != c:\n                        # Create new tour by reversing segments\n                        temp = new_solution.copy()\n                        temp[a:b] = temp[a:b][::-1]\n                        temp[b:c] = temp[b:c][::-1]\n                        candidates.append(temp)\n\n    # Evaluate all candidates and keep the best\n    best_candidate = new_solution\n    best_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                 sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)))\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n            best_candidate = candidate\n            best_cost = (cost1, cost2)\n\n    return best_candidate\n\n",
        "score": [
            -0.8673508558798095,
            1.4455609917640686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by dominance count (higher is better)\n        dominance_counts = []\n        for sol, obj in archive:\n            count = sum(1 for _, other_obj in archive if other_obj[0] < obj[0] and other_obj[1] < obj[1])\n            dominance_counts.append(count)\n        # Sort by dominance and then by crowding distance (simplified)\n        sorted_indices = sorted(range(len(archive)), key=lambda i: (-dominance_counts[i], (archive[i][1][0] + archive[i][1][1])))\n        selected_solution = archive[sorted_indices[0]][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Novel 3-opt* operator: select 3 edges and reconnect them in all possible ways, keeping the best\n    i, j, k = sorted(random.sample(range(n), 3))\n    # Original edges: (i,i+1), (j,j+1), (k,k+1)\n    # Generate all possible reconnections (8 cases for 3-opt*)\n    candidates = []\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                for c in [i, j, k]:\n                    if a != c and b != c:\n                        # Create new tour by reversing segments\n                        temp = new_solution.copy()\n                        temp[a:b] = temp[a:b][::-1]\n                        temp[b:c] = temp[b:c][::-1]\n                        candidates.append(temp)\n\n    # Evaluate all candidates and keep the best\n    best_candidate = new_solution\n    best_cost = (sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                 sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)))\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n            best_candidate = candidate\n            best_cost = (cost1, cost2)\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score, considering dominance\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search operator: adaptive segment inversion with objective-aware swaps\n    # Step 1: Identify critical segments based on objective differences\n    segment_length = max(2, n // 5)\n    segment_starts = sorted(random.sample(range(1, n - segment_length), 3))\n\n    # Step 2: Invert segments and swap nodes based on objective improvement\n    for start in segment_starts:\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate objective change if we invert this segment\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        inverted_segment = segment[::-1]\n        new_solution[start:end] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        # If inversion doesn't improve both objectives, try swapping nodes within segment\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution[start:end] = segment  # revert inversion\n            # Find the worst node in this segment based on combined objective\n            worst_node_idx = max(range(start, end), key=lambda i: distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]])\n            # Swap it with a random node from another segment\n            other_segment = random.choice([s for s in segment_starts if s != start])\n            swap_candidate = random.randint(other_segment, other_segment + segment_length - 1)\n            new_solution[worst_node_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_node_idx]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8982989905442986,
            0.9998259544372559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score, considering dominance\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search operator: adaptive segment inversion with objective-aware swaps\n    # Step 1: Identify critical segments based on objective differences\n    segment_length = max(2, n // 5)\n    segment_starts = sorted(random.sample(range(1, n - segment_length), 3))\n\n    # Step 2: Invert segments and swap nodes based on objective improvement\n    for start in segment_starts:\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Calculate objective change if we invert this segment\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        inverted_segment = segment[::-1]\n        new_solution[start:end] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        # If inversion doesn't improve both objectives, try swapping nodes within segment\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            new_solution[start:end] = segment  # revert inversion\n            # Find the worst node in this segment based on combined objective\n            worst_node_idx = max(range(start, end), key=lambda i: distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]])\n            # Swap it with a random node from another segment\n            other_segment = random.choice([s for s in segment_starts if s != start])\n            swap_candidate = random.randint(other_segment, other_segment + segment_length - 1)\n            new_solution[worst_node_idx], new_solution[swap_candidate] = new_solution[swap_candidate], new_solution[worst_node_idx]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{A novel algorithm that selects a solution based on a hybrid of dominance and crowding distance metrics, then applies a multi-segment inversion and relocation operator with adaptive segment selection to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_key(sol_obj):\n        obj = sol_obj[1]\n        dominance = sum(1 for s in archive if s[1][0] < obj[0] and s[1][1] < obj[1])\n        crowding = (obj[0] + obj[1]) / (sum(s[1][0] for s in archive) + sum(s[1][1] for s in archive))\n        return dominance + crowding\n\n    selected_solution = max(archive, key=selection_key)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment inversion and relocation\n    k = random.randint(2, min(5, n//2))\n    segments = sorted(random.sample(range(1, n), k))\n\n    # Invert and relocate segments\n    for i in range(k):\n        a, b = segments[i], segments[(i+1)%k]\n        if a > b:\n            a, b = b, a\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Random segment relocation\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Apply a simple insertion to fix\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6378380679998773,
            2.8078582882881165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_key(sol_obj):\n        obj = sol_obj[1]\n        dominance = sum(1 for s in archive if s[1][0] < obj[0] and s[1][1] < obj[1])\n        crowding = (obj[0] + obj[1]) / (sum(s[1][0] for s in archive) + sum(s[1][1] for s in archive))\n        return dominance + crowding\n\n    selected_solution = max(archive, key=selection_key)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment inversion and relocation\n    k = random.randint(2, min(5, n//2))\n    segments = sorted(random.sample(range(1, n), k))\n\n    # Invert and relocate segments\n    for i in range(k):\n        a, b = segments[i], segments[(i+1)%k]\n        if a > b:\n            a, b = b, a\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Random segment relocation\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Apply a simple insertion to fix\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid metric combining objective values and dominance counts, then applies a novel multi-segment relocation and inversion operator to generate a neighbor solution while ensuring feasibility through a dominance-based repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel hybrid operator: multi-segment relocation with inversion\n    if n > 4:\n        # Select two random segments and invert one\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Invert one segment with 70% probability\n        if random.random() < 0.7:\n            segment2 = segment2[::-1]\n\n        # Recombine with 60% probability of each permutation\n        if random.random() < 0.6:\n            new_solution = np.concatenate([segment1, segment3, segment2])\n        else:\n            new_solution = np.concatenate([segment3, segment2, segment1])\n\n    # Dominance-based feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Find the most dominated node and repair\n        node_counts = np.bincount(new_solution)\n        duplicated_nodes = np.where(node_counts > 1)[0]\n        if len(duplicated_nodes) > 0:\n            node_to_fix = duplicated_nodes[0]\n            positions = np.where(new_solution == node_to_fix)[0]\n            if len(positions) > 1:\n                # Replace one occurrence with a missing node\n                missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n                if len(missing_nodes) > 0:\n                    new_solution[positions[1]] = missing_nodes[0]\n\n    return new_solution\n\n",
        "score": [
            -0.8318787904883693,
            1.4449760913848877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel hybrid operator: multi-segment relocation with inversion\n    if n > 4:\n        # Select two random segments and invert one\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Invert one segment with 70% probability\n        if random.random() < 0.7:\n            segment2 = segment2[::-1]\n\n        # Recombine with 60% probability of each permutation\n        if random.random() < 0.6:\n            new_solution = np.concatenate([segment1, segment3, segment2])\n        else:\n            new_solution = np.concatenate([segment3, segment2, segment1])\n\n    # Dominance-based feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Find the most dominated node and repair\n        node_counts = np.bincount(new_solution)\n        duplicated_nodes = np.where(node_counts > 1)[0]\n        if len(duplicated_nodes) > 0:\n            node_to_fix = duplicated_nodes[0]\n            positions = np.where(new_solution == node_to_fix)[0]\n            if len(positions) > 1:\n                # Replace one occurrence with a missing node\n                missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n                if len(missing_nodes) > 0:\n                    new_solution[positions[1]] = missing_nodes[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel multi-segment inversion and reordering operator\n    # Select 4 distinct segments and apply a geometric transformation\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create segments\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:d]\n    seg5 = new_solution[d:]\n\n    # Apply inversion and reordering based on segment lengths\n    if len(seg2) > len(seg3):\n        new_solution = np.concatenate([np.flip(seg1), seg3, np.flip(seg2), seg4, seg5])\n    else:\n        new_solution = np.concatenate([seg2, np.flip(seg3), seg1, np.flip(seg4), seg5])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Apply a simple rotation to fix\n        shift = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            -0.9815658347603067,
            1.4960570335388184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] * x[1][1]) ** 0.5 * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Novel multi-segment inversion and reordering operator\n    # Select 4 distinct segments and apply a geometric transformation\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create segments\n    seg1 = new_solution[:a]\n    seg2 = new_solution[a:b]\n    seg3 = new_solution[b:c]\n    seg4 = new_solution[c:d]\n    seg5 = new_solution[d:]\n\n    # Apply inversion and reordering based on segment lengths\n    if len(seg2) > len(seg3):\n        new_solution = np.concatenate([np.flip(seg1), seg3, np.flip(seg2), seg4, seg5])\n    else:\n        new_solution = np.concatenate([seg2, np.flip(seg3), seg1, np.flip(seg4), seg5])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Apply a simple rotation to fix\n        shift = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Apply a novel segment rotation and edge reversal\n    if n > 3:\n        # Randomly select three segments and rotate them\n        a, b, c = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:n-1]\n\n        # Reorder segments in a rotated fashion\n        new_solution[a:n-1] = np.concatenate([segment2, segment3, segment1])\n\n        # Randomly reverse a segment to further perturb the solution\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9364184639041642,
            0.22431957721710205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Apply a novel segment rotation and edge reversal\n    if n > 3:\n        # Randomly select three segments and rotate them\n        a, b, c = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:n-1]\n\n        # Reorder segments in a rotated fashion\n        new_solution[a:n-1] = np.concatenate([segment2, segment3, segment1])\n\n        # Randomly reverse a segment to further perturb the solution\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects the solution with the best combined objective value from the archive, then applies a hybrid local search combining edge reversal and a novel segment-based edge swap, followed by feasibility checks to ensure a valid TSP tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: segment-based edge swap with reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Additional edge swap for diversity\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler edge swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9439837842778058,
            0.2048119306564331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: segment-based edge swap with reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Additional edge swap for diversity\n    if random.random() < 0.5:\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler edge swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge-swap operations, ensuring feasibility through validation and fallback to simpler moves if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments and apply operations\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9561170008881699,
            0.2096119523048401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments and apply operations\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score, then applies a novel segment-based local search that combines random segment reversal with a probabilistic edge insertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select segments for potential reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Apply segment reversal with probability based on segment lengths\n    if random.random() < 0.7:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    if random.random() < 0.5:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Probabilistic edge insertion for diversification\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n-1), 2)\n        if i != j:\n            # Insert node j after node i\n            new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8679531345198733,
            0.17816680669784546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select segments for potential reversal\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Apply segment reversal with probability based on segment lengths\n    if random.random() < 0.7:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    if random.random() < 0.5:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Probabilistic edge insertion for diversification\n    if random.random() < 0.3:\n        i, j = random.sample(range(1, n-1), 2)\n        if i != j:\n            # Insert node j after node i\n            new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(1, n-1), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{A new algorithm that selects a solution with high potential for improvement by considering both objective values and their dominance relationships, then applies a hybrid local search operator that combines segment reversal with a novel edge insertion strategy to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    reversed_segment = np.flip(segment)\n\n    # Insert reversed segment at a random position\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], reversed_segment, new_solution[insert_pos + len(segment):]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.823027424065564,
            0.0959973931312561
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    reversed_segment = np.flip(segment)\n\n    # Insert reversed segment at a random position\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], reversed_segment, new_solution[insert_pos + len(segment):]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Novel local search: Combine node relocation with edge inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a node to relocate\n    node_index = random.randint(1, n-1)\n    node = new_solution[node_index]\n\n    # Remove the node and find the best insertion point\n    new_solution = np.delete(new_solution, node_index)\n\n    # Evaluate insertion points using a weighted combination of both objectives\n    min_cost = float('inf')\n    best_pos = 0\n\n    for i in range(1, n):\n        # Insert node at position i\n        candidate = np.insert(new_solution, i, node)\n\n        # Calculate the change in both objectives\n        delta_1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                  distance_matrix_1[candidate[i], candidate[(i+1)%n]] -\n                  distance_matrix_1[candidate[i-1], candidate[(i+1)%n]])\n\n        delta_2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                  distance_matrix_2[candidate[i], candidate[(i+1)%n]] -\n                  distance_matrix_2[candidate[i-1], candidate[(i+1)%n]])\n\n        # Weighted cost (adjust weights based on problem characteristics)\n        weighted_cost = 0.6 * delta_1 + 0.4 * delta_2\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            best_pos = i\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply edge inversion to further improve the solution\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8837178314834753,
            0.4767070412635803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (potential for improvement)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Novel local search: Combine node relocation with edge inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a node to relocate\n    node_index = random.randint(1, n-1)\n    node = new_solution[node_index]\n\n    # Remove the node and find the best insertion point\n    new_solution = np.delete(new_solution, node_index)\n\n    # Evaluate insertion points using a weighted combination of both objectives\n    min_cost = float('inf')\n    best_pos = 0\n\n    for i in range(1, n):\n        # Insert node at position i\n        candidate = np.insert(new_solution, i, node)\n\n        # Calculate the change in both objectives\n        delta_1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                  distance_matrix_1[candidate[i], candidate[(i+1)%n]] -\n                  distance_matrix_1[candidate[i-1], candidate[(i+1)%n]])\n\n        delta_2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                  distance_matrix_2[candidate[i], candidate[(i+1)%n]] -\n                  distance_matrix_2[candidate[i-1], candidate[(i+1)%n]])\n\n        # Weighted cost (adjust weights based on problem characteristics)\n        weighted_cost = 0.6 * delta_1 + 0.4 * delta_2\n\n        if weighted_cost < min_cost:\n            min_cost = weighted_cost\n            best_pos = i\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Apply edge inversion to further improve the solution\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This new algorithm selects a solution from the archive using a dominance-based selection criterion, then applies a hybrid local search operator that combines a multi-segment relocation with a biased random walk to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [s for s in archive if not any(s[1][0] > other[1][0] and s[1][1] > other[1][1] for other in archive)]\n    if not non_dominated:\n        non_dominated = archive\n    selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: multi-segment relocation with biased random walk\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with bias toward improving both objectives\n    if random.random() < 0.7:  # Higher probability for this combination\n        new_solution = np.concatenate([segment2, segment3, segment1, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment2])\n\n    # Apply biased random walk to escape local optima\n    for _ in range(2):\n        i, j = random.sample(range(1, n), 2)\n        if random.random() < 0.3:  # Lower probability for swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7472209370028244,
            0.29260021448135376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [s for s in archive if not any(s[1][0] > other[1][0] and s[1][1] > other[1][1] for other in archive)]\n    if not non_dominated:\n        non_dominated = archive\n    selected_solution = max(non_dominated, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: multi-segment relocation with biased random walk\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with bias toward improving both objectives\n    if random.random() < 0.7:  # Higher probability for this combination\n        new_solution = np.concatenate([segment2, segment3, segment1, segment4])\n    else:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment2])\n\n    # Apply biased random walk to escape local optima\n    for _ in range(2):\n        i, j = random.sample(range(1, n), 2)\n        if random.random() < 0.3:  # Lower probability for swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search operator: 3-opt with multi-segment inversion\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments with probability 0.7\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Recombine segments in a new order (with 60% probability of each permutation)\n    if random.random() < 0.6:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8773379902797162,
            1.515586018562317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search operator: 3-opt with multi-segment inversion\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert segments with probability 0.7\n    if random.random() < 0.7:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Recombine segments in a new order (with 60% probability of each permutation)\n    if random.random() < 0.6:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[c:], new_solution[b:c], new_solution[a:b]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This new algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge swapping with a novel feasibility check to ensure valid tours.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal and edge swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Novel feasibility check: Ensure no duplicates and fix if invalid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8431487788544296,
            0.1961042284965515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal and edge swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Novel feasibility check: Ensure no duplicates and fix if invalid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{A new algorithm that prioritizes solutions with balanced improvement potential across objectives by selecting the top 30% of solutions, then applies a novel hybrid local search combining segment reversal and edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    top_30 = sorted_archive[:max(1, len(archive) // 3)]\n    selected_solution = random.choice(top_30)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and insert edges\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Reconstruct solution with inserted segments\n    new_solution = np.concatenate([\n        new_solution[:a], segment1, new_solution[b:c], segment2, new_solution[d:]\n    ])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7613985359715774,
            0.059332966804504395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    top_30 = sorted_archive[:max(1, len(archive) // 3)]\n    selected_solution = random.choice(top_30)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and insert edges\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Reconstruct solution with inserted segments\n    new_solution = np.concatenate([\n        new_solution[:a], segment1, new_solution[b:c], segment2, new_solution[d:]\n    ])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation with adaptive segment selection\n    segments = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create segments with overlapping boundaries\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a-1:b]\n    segment3 = new_solution[b-1:c]\n    segment4 = new_solution[c-1:]\n\n    # Recombine segments with probabilistic order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility with adaptive repair\n    if len(np.unique(new_solution)) != n:\n        # Find and fix duplicates\n        counts = np.bincount(new_solution)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n\n        for dup in duplicates:\n            for miss in missing:\n                idx = np.where(new_solution == dup)[0][1]\n                new_solution[idx] = miss\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8492416863610966,
            1.324200987815857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation with adaptive segment selection\n    segments = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create segments with overlapping boundaries\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a-1:b]\n    segment3 = new_solution[b-1:c]\n    segment4 = new_solution[c-1:]\n\n    # Recombine segments with probabilistic order\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility with adaptive repair\n    if len(np.unique(new_solution)) != n:\n        # Find and fix duplicates\n        counts = np.bincount(new_solution)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n\n        for dup in duplicates:\n            for miss in missing:\n                idx = np.where(new_solution == dup)[0][1]\n                new_solution[idx] = miss\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and applies a novel \"path inversion with guided segment insertion\" operator, which inverts a random segment of the tour and inserts it at a position that minimizes the increase in both objective costs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert\n    a, b = sorted(random.sample(range(1, n), 2))\n    inverted_segment = np.flip(new_solution[a:b])\n\n    # Find best insertion point for the inverted segment to minimize combined cost increase\n    best_insert_pos = 0\n    min_cost_increase = float('inf')\n\n    for i in range(n):\n        if i >= a and i < b:\n            continue  # Skip positions within the original segment\n\n        # Create temporary solution with segment inserted at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            inverted_segment,\n            new_solution[i:]\n        ])\n\n        # Calculate cost increase\n        original_cost1 = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[-2], new_solution[-1]])\n        new_cost1 = (distance_matrix_1[temp_solution[-1], temp_solution[0]] +\n                    distance_matrix_1[temp_solution[-2], temp_solution[-1]])\n\n        original_cost2 = (distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[-2], new_solution[-1]])\n        new_cost2 = (distance_matrix_2[temp_solution[-1], temp_solution[0]] +\n                    distance_matrix_2[temp_solution[-2], temp_solution[-1]])\n\n        cost_increase = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n\n        if cost_increase < min_cost_increase:\n            min_cost_increase = cost_increase\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert_pos],\n        inverted_segment,\n        new_solution[best_insert_pos:]\n    ])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8922769688596878,
            0.11894339323043823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) / (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert\n    a, b = sorted(random.sample(range(1, n), 2))\n    inverted_segment = np.flip(new_solution[a:b])\n\n    # Find best insertion point for the inverted segment to minimize combined cost increase\n    best_insert_pos = 0\n    min_cost_increase = float('inf')\n\n    for i in range(n):\n        if i >= a and i < b:\n            continue  # Skip positions within the original segment\n\n        # Create temporary solution with segment inserted at position i\n        temp_solution = np.concatenate([\n            new_solution[:i],\n            inverted_segment,\n            new_solution[i:]\n        ])\n\n        # Calculate cost increase\n        original_cost1 = (distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         distance_matrix_1[new_solution[-2], new_solution[-1]])\n        new_cost1 = (distance_matrix_1[temp_solution[-1], temp_solution[0]] +\n                    distance_matrix_1[temp_solution[-2], temp_solution[-1]])\n\n        original_cost2 = (distance_matrix_2[new_solution[-1], new_solution[0]] +\n                         distance_matrix_2[new_solution[-2], new_solution[-1]])\n        new_cost2 = (distance_matrix_2[temp_solution[-1], temp_solution[0]] +\n                    distance_matrix_2[temp_solution[-2], temp_solution[-1]])\n\n        cost_increase = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n\n        if cost_increase < min_cost_increase:\n            min_cost_increase = cost_increase\n            best_insert_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert_pos],\n        inverted_segment,\n        new_solution[best_insert_pos:]\n    ])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion combining objective values and dominance counts, then applies a novel multi-segment insertion strategy that intelligently reorders segments while preserving feasibility through a comprehensive validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if (y[1][0] < x[1][0] and y[1][1] <= x[1][1]) or (y[1][0] <= x[1][0] and y[1][1] < x[1][1]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator\n    # Randomly select 3 distinct segments and insert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Create 4 possible insertion configurations with 25% probability each\n    configs = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment3, segment1, segment4, segment2]),\n        np.concatenate([segment2, segment4, segment1, segment3]),\n        np.concatenate([segment4, segment2, segment3, segment1])\n    ]\n    new_solution = configs[random.randint(0, 3)]\n\n    # Feasibility validation and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a series of controlled swaps to fix\n        for _ in range(3):\n            i, j = random.sample(range(1, n), 2)\n            if new_solution[i] != new_solution[j]:  # Ensure no duplicates\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                if len(np.unique(new_solution)) == n:\n                    break\n\n    # Final validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If still invalid, revert to a simple insertion\n        i = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9316045759755672,
            2.100565254688263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if (y[1][0] < x[1][0] and y[1][1] <= x[1][1]) or (y[1][0] <= x[1][0] and y[1][1] < x[1][1]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator\n    # Randomly select 3 distinct segments and insert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Create 4 possible insertion configurations with 25% probability each\n    configs = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment3, segment1, segment4, segment2]),\n        np.concatenate([segment2, segment4, segment1, segment3]),\n        np.concatenate([segment4, segment2, segment3, segment1])\n    ]\n    new_solution = configs[random.randint(0, 3)]\n\n    # Feasibility validation and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a series of controlled swaps to fix\n        for _ in range(3):\n            i, j = random.sample(range(1, n), 2)\n            if new_solution[i] != new_solution[j]:  # Ensure no duplicates\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                if len(np.unique(new_solution)) == n:\n                    break\n\n    # Final validation to ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If still invalid, revert to a simple insertion\n        i = random.randint(1, n-1)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining 2-opt with a novel edge-swap strategy, ensuring feasibility through validation checks and fallback to simpler moves if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7886578902254491,
            0.18895715475082397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions based on a weighted sum of objectives, then applies a randomized segment reversal and edge-swap strategy with feasibility checks and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap with higher probability for larger segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply novel segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Check feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler swap of two adjacent nodes\n        i = random.randint(1, n - 1)\n        new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8962573628953617,
            0.2130967378616333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap with higher probability for larger segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply novel segment reversal and edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Check feasibility and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler swap of two adjacent nodes\n        i = random.randint(1, n - 1)\n        new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion that combines Pareto dominance and crowding distance, then applies a novel path inversion operator that inverts segments of the tour while preserving feasibility and potentially improving both objectives by leveraging the structure of the distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criterion(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        dominance = sum(1 for y in archive if y[1][0] < obj1 and y[1][1] < obj2)\n        crowding = (obj1 + obj2) * (1 + dominance)\n        return crowding\n\n    selected_solution = max(archive, key=selection_criterion)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path inversion operator\n    # Randomly select a segment to invert, considering both distance matrices\n    start, end = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[start:end]\n    inverted_segment = segment[::-1]\n\n    # Calculate potential improvement in both objectives\n    original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n    inverted_cost1 = distance_matrix_1[new_solution[start-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[end]]\n    delta1 = inverted_cost1 - original_cost1\n\n    original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n    inverted_cost2 = distance_matrix_2[new_solution[start-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[end]]\n    delta2 = inverted_cost2 - original_cost2\n\n    # Apply inversion if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[start:end] = inverted_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8987205019740436,
            1.228756308555603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criterion(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        dominance = sum(1 for y in archive if y[1][0] < obj1 and y[1][1] < obj2)\n        crowding = (obj1 + obj2) * (1 + dominance)\n        return crowding\n\n    selected_solution = max(archive, key=selection_criterion)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path inversion operator\n    # Randomly select a segment to invert, considering both distance matrices\n    start, end = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[start:end]\n    inverted_segment = segment[::-1]\n\n    # Calculate potential improvement in both objectives\n    original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[end]]\n    inverted_cost1 = distance_matrix_1[new_solution[start-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[end]]\n    delta1 = inverted_cost1 - original_cost1\n\n    original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[end]]\n    inverted_cost2 = distance_matrix_2[new_solution[start-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[end]]\n    delta2 = inverted_cost2 - original_cost2\n\n    # Apply inversion if it improves at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[start:end] = inverted_segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel algorithm that selects solutions from the archive based on a hybrid scoring function combining objective values, dominance count, and diversity metrics, then applies a multi-segment inversion operator with adaptive segment sizes to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol, obj):\n        dominance = sum(1 for (_, (o1, o2)) in archive if o1 < obj[0] and o2 < obj[1])\n        diversity = sum(abs(obj[0] - o1) + abs(obj[1] - o2) for (_, (o1, o2)) in archive)\n        return (obj[0] + obj[1]) * (1 + dominance) + 0.1 * diversity\n\n    selected_solution = max(archive, key=lambda x: score(x[0], x[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment inversion operator\n    k = min(4, n // 3)  # Adaptive number of segments\n    segments = sorted(random.sample(range(1, n), k-1))\n    segments = [0] + segments + [n]\n\n    # Create segments and invert them in a new order\n    segments_list = [new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)]\n    random.shuffle(segments_list)\n    new_solution = np.concatenate(segments_list)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple insertion to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.9623639285115168,
            4.944675981998444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol, obj):\n        dominance = sum(1 for (_, (o1, o2)) in archive if o1 < obj[0] and o2 < obj[1])\n        diversity = sum(abs(obj[0] - o1) + abs(obj[1] - o2) for (_, (o1, o2)) in archive)\n        return (obj[0] + obj[1]) * (1 + dominance) + 0.1 * diversity\n\n    selected_solution = max(archive, key=lambda x: score(x[0], x[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment inversion operator\n    k = min(4, n // 3)  # Adaptive number of segments\n    segments = sorted(random.sample(range(1, n), k-1))\n    segments = [0] + segments + [n]\n\n    # Create segments and invert them in a new order\n    segments_list = [new_solution[segments[i]:segments[i+1]] for i in range(len(segments)-1)]\n    random.shuffle(segments_list)\n    new_solution = np.concatenate(segments_list)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple insertion to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel segment inversion and reinsertion strategy to create neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + len([y for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment inversion and reinsertion operator\n    # Randomly select a segment and invert it, then reinsert at a new position\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = np.flip(new_solution[a:b])\n\n    # Remove the original segment\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Insert the inverted segment at a random position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9259237646739685,
            1.3500726819038391
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + len([y for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment inversion and reinsertion operator\n    # Randomly select a segment and invert it, then reinsert at a new position\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = np.flip(new_solution[a:b])\n\n    # Remove the original segment\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Insert the inverted segment at a random position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: Segment-based crossover with local refinement\n    # Randomly select 4 distinct segments and recombine them in a novel pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create five segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a novel pattern (4! = 24 possible permutations)\n    permutation = random.randint(0, 23)\n    if permutation == 0:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment5, segment3])\n    elif permutation == 1:\n        new_solution = np.concatenate([segment3, segment2, segment5, segment1, segment4])\n    elif permutation == 2:\n        new_solution = np.concatenate([segment5, segment1, segment3, segment2, segment4])\n    elif permutation == 3:\n        new_solution = np.concatenate([segment1, segment3, segment4, segment5, segment2])\n    elif permutation == 4:\n        new_solution = np.concatenate([segment4, segment5, segment2, segment3, segment1])\n    elif permutation == 5:\n        new_solution = np.concatenate([segment2, segment1, segment3, segment4, segment5])\n    elif permutation == 6:\n        new_solution = np.concatenate([segment3, segment5, segment1, segment4, segment2])\n    elif permutation == 7:\n        new_solution = np.concatenate([segment4, segment2, segment5, segment1, segment3])\n    elif permutation == 8:\n        new_solution = np.concatenate([segment5, segment3, segment2, segment4, segment1])\n    elif permutation == 9:\n        new_solution = np.concatenate([segment1, segment4, segment2, segment3, segment5])\n    elif permutation == 10:\n        new_solution = np.concatenate([segment2, segment3, segment5, segment4, segment1])\n    elif permutation == 11:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2, segment5])\n    elif permutation == 12:\n        new_solution = np.concatenate([segment4, segment1, segment5, segment3, segment2])\n    elif permutation == 13:\n        new_solution = np.concatenate([segment5, segment2, segment1, segment3, segment4])\n    elif permutation == 14:\n        new_solution = np.concatenate([segment1, segment5, segment3, segment2, segment4])\n    elif permutation == 15:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3, segment5])\n    elif permutation == 16:\n        new_solution = np.concatenate([segment3, segment2, segment4, segment5, segment1])\n    elif permutation == 17:\n        new_solution = np.concatenate([segment4, segment3, segment5, segment2, segment1])\n    elif permutation == 18:\n        new_solution = np.concatenate([segment5, segment1, segment2, segment4, segment3])\n    elif permutation == 19:\n        new_solution = np.concatenate([segment1, segment2, segment5, segment3, segment4])\n    elif permutation == 20:\n        new_solution = np.concatenate([segment2, segment5, segment4, segment1, segment3])\n    elif permutation == 21:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1, segment5])\n    elif permutation == 22:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment5, segment2])\n    else:\n        new_solution = np.concatenate([segment5, segment3, segment1, segment2, segment4])\n\n    # Local refinement: Apply a novel edge-swap based on distance matrices\n    for _ in range(3):  # Perform 3 local refinements\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost improvement potential\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (cost1_after < cost1_before * 0.95 or cost2_after < cost2_before * 0.95):\n            new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8410785478629912,
            1.3591257333755493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid operator: Segment-based crossover with local refinement\n    # Randomly select 4 distinct segments and recombine them in a novel pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create five segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Recombine segments in a novel pattern (4! = 24 possible permutations)\n    permutation = random.randint(0, 23)\n    if permutation == 0:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment5, segment3])\n    elif permutation == 1:\n        new_solution = np.concatenate([segment3, segment2, segment5, segment1, segment4])\n    elif permutation == 2:\n        new_solution = np.concatenate([segment5, segment1, segment3, segment2, segment4])\n    elif permutation == 3:\n        new_solution = np.concatenate([segment1, segment3, segment4, segment5, segment2])\n    elif permutation == 4:\n        new_solution = np.concatenate([segment4, segment5, segment2, segment3, segment1])\n    elif permutation == 5:\n        new_solution = np.concatenate([segment2, segment1, segment3, segment4, segment5])\n    elif permutation == 6:\n        new_solution = np.concatenate([segment3, segment5, segment1, segment4, segment2])\n    elif permutation == 7:\n        new_solution = np.concatenate([segment4, segment2, segment5, segment1, segment3])\n    elif permutation == 8:\n        new_solution = np.concatenate([segment5, segment3, segment2, segment4, segment1])\n    elif permutation == 9:\n        new_solution = np.concatenate([segment1, segment4, segment2, segment3, segment5])\n    elif permutation == 10:\n        new_solution = np.concatenate([segment2, segment3, segment5, segment4, segment1])\n    elif permutation == 11:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2, segment5])\n    elif permutation == 12:\n        new_solution = np.concatenate([segment4, segment1, segment5, segment3, segment2])\n    elif permutation == 13:\n        new_solution = np.concatenate([segment5, segment2, segment1, segment3, segment4])\n    elif permutation == 14:\n        new_solution = np.concatenate([segment1, segment5, segment3, segment2, segment4])\n    elif permutation == 15:\n        new_solution = np.concatenate([segment2, segment4, segment1, segment3, segment5])\n    elif permutation == 16:\n        new_solution = np.concatenate([segment3, segment2, segment4, segment5, segment1])\n    elif permutation == 17:\n        new_solution = np.concatenate([segment4, segment3, segment5, segment2, segment1])\n    elif permutation == 18:\n        new_solution = np.concatenate([segment5, segment1, segment2, segment4, segment3])\n    elif permutation == 19:\n        new_solution = np.concatenate([segment1, segment2, segment5, segment3, segment4])\n    elif permutation == 20:\n        new_solution = np.concatenate([segment2, segment5, segment4, segment1, segment3])\n    elif permutation == 21:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1, segment5])\n    elif permutation == 22:\n        new_solution = np.concatenate([segment4, segment1, segment3, segment5, segment2])\n    else:\n        new_solution = np.concatenate([segment5, segment3, segment1, segment2, segment4])\n\n    # Local refinement: Apply a novel edge-swap based on distance matrices\n    for _ in range(3):  # Perform 3 local refinements\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost improvement potential\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (cost1_after < cost1_before * 0.95 or cost2_after < cost2_before * 0.95):\n            new_solution[i:j] = np.flip(new_solution[i:j])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: segment inversion + edge insertion\n    # Select two random segments and invert them\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly insert a segment between two other segments\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8384156616061269,
            1.4345521330833435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid local search: segment inversion + edge insertion\n    # Select two random segments and invert them\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly insert a segment between two other segments\n    c, d = sorted(random.sample(range(1, n-1), 2))\n    segment = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:c], new_solution[d:], segment])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a random swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select two distinct segments from different parts of the tour\n    split1 = random.randint(1, n-2)\n    split2 = random.randint(split1+1, n-1)\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n\n    # Novel insertion: interleave segments in a different order\n    new_order = [segment2, segment1, segment3] if random.random() > 0.5 else [segment3, segment2, segment1]\n    new_solution = np.concatenate(new_order)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9055715117478292,
            0.22911733388900757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select two distinct segments from different parts of the tour\n    split1 = random.randint(1, n-2)\n    split2 = random.randint(split1+1, n-1)\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n\n    # Novel insertion: interleave segments in a different order\n    new_order = [segment2, segment1, segment3] if random.random() > 0.5 else [segment3, segment2, segment1]\n    new_solution = np.concatenate(new_order)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: combine segment reversal with edge reinsertion\n    if n > 4:\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n-3), 2))\n        c, d = sorted(random.sample(range(b+1, n), 2))\n\n        # Reverse segments and reinsert edges\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n        # Reinsert a random edge from the first segment into the second segment\n        if b - a > 1 and d - c > 1:\n            edge_pos = random.randint(a, b-1)\n            insert_pos = random.randint(c, d-1)\n            edge = new_solution[edge_pos]\n            new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+1:insert_pos], [edge], new_solution[insert_pos:]])\n\n    # Fallback to simple swap if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8909128520125462,
            0.20119547843933105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: combine segment reversal with edge reinsertion\n    if n > 4:\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n-3), 2))\n        c, d = sorted(random.sample(range(b+1, n), 2))\n\n        # Reverse segments and reinsert edges\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n        # Reinsert a random edge from the first segment into the second segment\n        if b - a > 1 and d - c > 1:\n            edge_pos = random.randint(a, b-1)\n            insert_pos = random.randint(c, d-1)\n            edge = new_solution[edge_pos]\n            new_solution = np.concatenate([new_solution[:edge_pos], new_solution[edge_pos+1:insert_pos], [edge], new_solution[insert_pos:]])\n\n    # Fallback to simple swap if invalid\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with a novel edge-swap strategy, ensuring feasibility through validation and fallback to simpler moves when needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: Combine segment reversal with edge rotation\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge rotation\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.roll(new_solution[c:d], 1)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8715061515191406,
            0.2208201289176941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel hybrid local search: Combine segment reversal with edge rotation\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge rotation\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.roll(new_solution[c:d], 1)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply segment reversal with probability 0.6\n    if random.random() < 0.6:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge reordering with probability 0.4\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8653585265977223,
            0.20558667182922363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply segment reversal with probability 0.6\n    if random.random() < 0.6:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge reordering with probability 0.4\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{\"This algorithm selects a solution from the archive with the highest combined objective value, then applies a novel 'multi-objective segment insertion' operator that inserts segments from one part of the tour into another while maintaining feasibility through careful segment selection and reinsertion.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-objective segment insertion operator\n    # Select a segment to cut out and a position to insert it\n    segment_length = random.randint(2, max(3, n // 4))\n    start_pos = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position that minimizes both objectives\n    best_pos = 0\n    best_cost = float('inf')\n\n    for i in range(1, len(new_solution)):\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(1, len(temp_solution)))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]  # Return to start\n\n        cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(1, len(temp_solution)))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]  # Return to start\n\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8859497268225058,
            0.5075609683990479
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-objective segment insertion operator\n    # Select a segment to cut out and a position to insert it\n    segment_length = random.randint(2, max(3, n // 4))\n    start_pos = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position that minimizes both objectives\n    best_pos = 0\n    best_cost = float('inf')\n\n    for i in range(1, len(new_solution)):\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(1, len(temp_solution)))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]  # Return to start\n\n        cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(1, len(temp_solution)))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]  # Return to start\n\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{The new algorithm will select a solution from the archive based on a hybrid of its objective values and diversity, then apply a novel multi-segment reversal and rotation operator that rearranges segments in a circular fashion while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment reversal and rotation operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reverse and rotate segments in a circular pattern\n    if random.random() < 0.5:\n        new_solution = np.concatenate([np.flip(segment2), segment1, np.flip(segment4), segment3])\n    else:\n        new_solution = np.concatenate([np.flip(segment3), np.flip(segment1), segment4, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply a random rotation if invalid\n        shift = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            -0.9978347454358565,
            1.4931952357292175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment reversal and rotation operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Extract segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reverse and rotate segments in a circular pattern\n    if random.random() < 0.5:\n        new_solution = np.concatenate([np.flip(segment2), segment1, np.flip(segment4), segment3])\n    else:\n        new_solution = np.concatenate([np.flip(segment3), np.flip(segment1), segment4, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Apply a random rotation if invalid\n        shift = random.randint(1, n-1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and distance metrics, then applies a hybrid local search that combines a novel edge-swap strategy with a modified 2-opt move, ensuring feasibility by validating the solution and reverting to a simpler move if invalid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / distance_matrix_1.mean() + x[1][1] / distance_matrix_2.mean()))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Novel edge-swap with distance-aware segment selection\n    # Select segments based on high-distance edges in either objective space\n    def get_high_distance_edges(solution, distance_matrix):\n        total = 0\n        edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            d = distance_matrix[solution[i], solution[j]]\n            edges.append((d, i))\n            total += d\n        edges.sort(reverse=True)\n        return [e[1] for e in edges[:2]]\n\n    edges1 = get_high_distance_edges(new_solution, distance_matrix_1)\n    edges2 = get_high_distance_edges(new_solution, distance_matrix_2)\n    a, b = sorted(edges1)\n    c, d = sorted(edges2)\n\n    # Apply novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a distance-aware 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.838989860457481,
            1.0139475464820862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] / distance_matrix_1.mean() + x[1][1] / distance_matrix_2.mean()))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Novel edge-swap with distance-aware segment selection\n    # Select segments based on high-distance edges in either objective space\n    def get_high_distance_edges(solution, distance_matrix):\n        total = 0\n        edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            d = distance_matrix[solution[i], solution[j]]\n            edges.append((d, i))\n            total += d\n        edges.sort(reverse=True)\n        return [e[1] for e in edges[:2]]\n\n    edges1 = get_high_distance_edges(new_solution, distance_matrix_1)\n    edges2 = get_high_distance_edges(new_solution, distance_matrix_2)\n    a, b = sorted(edges1)\n    c, d = sorted(edges2)\n\n    # Apply novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a distance-aware 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (obj[0] + 1e-6) + 1 / (obj[1] + 1e-6) for (_, obj) in archive]\n    selected_solution = archive[np.argmax(weights)][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c = random.randint(1, n-1)\n\n    # Reverse segment and insert at random position\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    # Insert a random edge if feasible\n    if len(np.unique(new_solution)) == n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j + 1)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7014047392710454,
            0.21765440702438354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (obj[0] + 1e-6) + 1 / (obj[1] + 1e-6) for (_, obj) in archive]\n    selected_solution = archive[np.argmax(weights)][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c = random.randint(1, n-1)\n\n    # Reverse segment and insert at random position\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b:]])\n\n    # Insert a random edge if feasible\n    if len(np.unique(new_solution)) == n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j:\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j + 1)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge-swap operations, with fallback to 2-opt if feasibility is violated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Edge-swap with segment reversal and node insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Randomly insert a node from one segment into another\n    if random.random() < 0.5 and b - a > 1 and d - c > 1:\n        insert_pos = random.randint(c, d-1)\n        node_to_insert = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt if invalid\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n        new_solution[j:k] = np.flip(new_solution[j:k])\n\n    return new_solution\n\n",
        "score": [
            -0.8711121334336931,
            0.19678246974945068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Edge-swap with segment reversal and node insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Randomly insert a node from one segment into another\n    if random.random() < 0.5 and b - a > 1 and d - c > 1:\n        insert_pos = random.randint(c, d-1)\n        node_to_insert = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:insert_pos], [node_to_insert], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 3-opt if invalid\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n        new_solution[j:k] = np.flip(new_solution[j:k])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm implements a novel \"multi-objective segment inversion and reordering\" strategy that selects a solution with high potential for improvement, identifies critical segments based on both objective values, inverts and reorders them while preserving feasibility, and then applies a probabilistic segment merging operation to further diversify the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify critical segments based on both objectives\n    segment_length = max(3, n // 5)\n    segment_starts = sorted(random.sample(range(1, n - segment_length), 3))\n\n    # Process each segment with different operations\n    for start in segment_starts:\n        segment = new_solution[start:start+segment_length]\n\n        # With 50% probability, invert the segment\n        if random.random() < 0.5:\n            segment = np.flip(segment)\n\n        # With 30% probability, rotate the segment\n        elif random.random() < 0.8:\n            rotate_amount = random.randint(1, segment_length-1)\n            segment = np.roll(segment, rotate_amount)\n\n        # Otherwise, shuffle the segment\n        else:\n            np.random.shuffle(segment)\n\n        new_solution[start:start+segment_length] = segment\n\n    # Apply probabilistic segment merging\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Merge segments in different configurations\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment1, segment3, segment2])\n        else:\n            new_solution = np.concatenate([segment2, segment1, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6962713239124771,
            0.21553480625152588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify critical segments based on both objectives\n    segment_length = max(3, n // 5)\n    segment_starts = sorted(random.sample(range(1, n - segment_length), 3))\n\n    # Process each segment with different operations\n    for start in segment_starts:\n        segment = new_solution[start:start+segment_length]\n\n        # With 50% probability, invert the segment\n        if random.random() < 0.5:\n            segment = np.flip(segment)\n\n        # With 30% probability, rotate the segment\n        elif random.random() < 0.8:\n            rotate_amount = random.randint(1, segment_length-1)\n            segment = np.roll(segment, rotate_amount)\n\n        # Otherwise, shuffle the segment\n        else:\n            np.random.shuffle(segment)\n\n        new_solution[start:start+segment_length] = segment\n\n    # Apply probabilistic segment merging\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Merge segments in different configurations\n        if random.random() < 0.5:\n            new_solution = np.concatenate([segment1, segment3, segment2])\n        else:\n            new_solution = np.concatenate([segment2, segment1, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion operator\n    # Identify segments where inversion could potentially reduce both objectives\n    segment_length = max(3, n // 5)\n    segment_start = random.randint(0, n - segment_length)\n    segment_end = segment_start + segment_length\n\n    # Calculate potential improvement for inversion\n    def segment_cost(solution, start, end):\n        cost1 = distance_matrix_1[solution[end-1], solution[start]]\n        cost2 = distance_matrix_2[solution[end-1], solution[start]]\n        for i in range(start, end-1):\n            cost1 += distance_matrix_1[solution[i], solution[i+1]]\n            cost2 += distance_matrix_2[solution[i], solution[i+1]]\n        return (cost1, cost2)\n\n    original_cost = segment_cost(new_solution, segment_start, segment_end)\n    inverted_segment = new_solution[segment_start:segment_end][::-1]\n    new_solution[segment_start:segment_end] = inverted_segment\n    inverted_cost = segment_cost(new_solution, segment_start, segment_end)\n\n    # If inversion doesn't improve at least one objective, try another segment\n    if (inverted_cost[0] >= original_cost[0] and inverted_cost[1] >= original_cost[1]):\n        # Try a different segment\n        segment_start = random.randint(0, n - segment_length)\n        segment_end = segment_start + segment_length\n        inverted_segment = new_solution[segment_start:segment_end][::-1]\n        new_solution[segment_start:segment_end] = inverted_segment\n\n    # Additional multi-objective aware perturbation\n    # Identify nodes with high potential for improvement in either objective\n    potential_nodes = []\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement if we move current node\n        move_cost_1 = (distance_matrix_1[prev_node, next_node] -\n                      (distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]))\n        move_cost_2 = (distance_matrix_2[prev_node, next_node] -\n                      (distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]))\n\n        if move_cost_1 < 0 or move_cost_2 < 0:\n            potential_nodes.append(i)\n\n    if potential_nodes:\n        # Select a random node from potential candidates\n        selected_node = random.choice(potential_nodes)\n        # Insert it in a new position that might improve both objectives\n        new_pos = random.randint(0, n-1)\n        if new_pos > selected_node:\n            new_pos += 1\n        new_solution = np.insert(new_solution, new_pos, new_solution[selected_node])\n        new_solution = np.delete(new_solution, selected_node if selected_node < new_pos else selected_node + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.8964455212828362,
            1.54599267244339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1][0], x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion operator\n    # Identify segments where inversion could potentially reduce both objectives\n    segment_length = max(3, n // 5)\n    segment_start = random.randint(0, n - segment_length)\n    segment_end = segment_start + segment_length\n\n    # Calculate potential improvement for inversion\n    def segment_cost(solution, start, end):\n        cost1 = distance_matrix_1[solution[end-1], solution[start]]\n        cost2 = distance_matrix_2[solution[end-1], solution[start]]\n        for i in range(start, end-1):\n            cost1 += distance_matrix_1[solution[i], solution[i+1]]\n            cost2 += distance_matrix_2[solution[i], solution[i+1]]\n        return (cost1, cost2)\n\n    original_cost = segment_cost(new_solution, segment_start, segment_end)\n    inverted_segment = new_solution[segment_start:segment_end][::-1]\n    new_solution[segment_start:segment_end] = inverted_segment\n    inverted_cost = segment_cost(new_solution, segment_start, segment_end)\n\n    # If inversion doesn't improve at least one objective, try another segment\n    if (inverted_cost[0] >= original_cost[0] and inverted_cost[1] >= original_cost[1]):\n        # Try a different segment\n        segment_start = random.randint(0, n - segment_length)\n        segment_end = segment_start + segment_length\n        inverted_segment = new_solution[segment_start:segment_end][::-1]\n        new_solution[segment_start:segment_end] = inverted_segment\n\n    # Additional multi-objective aware perturbation\n    # Identify nodes with high potential for improvement in either objective\n    potential_nodes = []\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement if we move current node\n        move_cost_1 = (distance_matrix_1[prev_node, next_node] -\n                      (distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]))\n        move_cost_2 = (distance_matrix_2[prev_node, next_node] -\n                      (distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]))\n\n        if move_cost_1 < 0 or move_cost_2 < 0:\n            potential_nodes.append(i)\n\n    if potential_nodes:\n        # Select a random node from potential candidates\n        selected_node = random.choice(potential_nodes)\n        # Insert it in a new position that might improve both objectives\n        new_pos = random.randint(0, n-1)\n        if new_pos > selected_node:\n            new_pos += 1\n        new_solution = np.insert(new_solution, new_pos, new_solution[selected_node])\n        new_solution = np.delete(new_solution, selected_node if selected_node < new_pos else selected_node + 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{A novel algorithm that combines adaptive segment selection with a multi-phase edge-reversal strategy, prioritizing high-potential regions of the solution space and ensuring feasibility through dynamic segment reconfiguration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on distance matrices\n    segment_sizes = [random.randint(2, min(5, n//3)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(1, n - sum(segment_sizes)), 3))\n    segments = [new_solution[segment_starts[i]:segment_starts[i]+segment_sizes[i]] for i in range(3)]\n\n    # Multi-phase edge-reversal with distance awareness\n    for i in range(3):\n        if random.random() < 0.6:\n            segments[i] = np.flip(segments[i])\n        else:\n            # Weighted edge reversal based on distance matrices\n            for j in range(len(segments[i])-1):\n                if (distance_matrix_1[segments[i][j], segments[i][j+1]] + distance_matrix_2[segments[i][j], segments[i][j+1]]) > \\\n                   (distance_matrix_1[segments[i][j+1], segments[i][j]] + distance_matrix_2[segments[i][j+1], segments[i][j]]):\n                    segments[i][j], segments[i][j+1] = segments[i][j+1], segments[i][j]\n\n    # Recombine segments with distance-based insertion\n    remaining_nodes = np.setdiff1d(np.arange(n), np.concatenate(segments))\n    new_solution = np.concatenate([segments[0], segments[1], segments[2], remaining_nodes])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Dynamic repair: insert missing nodes at positions with minimal distance impact\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(1, n):\n                if i not in new_solution:\n                    cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_2[new_solution[i-1], node]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8622924965864153,
            1.2223781943321228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on distance matrices\n    segment_sizes = [random.randint(2, min(5, n//3)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(1, n - sum(segment_sizes)), 3))\n    segments = [new_solution[segment_starts[i]:segment_starts[i]+segment_sizes[i]] for i in range(3)]\n\n    # Multi-phase edge-reversal with distance awareness\n    for i in range(3):\n        if random.random() < 0.6:\n            segments[i] = np.flip(segments[i])\n        else:\n            # Weighted edge reversal based on distance matrices\n            for j in range(len(segments[i])-1):\n                if (distance_matrix_1[segments[i][j], segments[i][j+1]] + distance_matrix_2[segments[i][j], segments[i][j+1]]) > \\\n                   (distance_matrix_1[segments[i][j+1], segments[i][j]] + distance_matrix_2[segments[i][j+1], segments[i][j]]):\n                    segments[i][j], segments[i][j+1] = segments[i][j+1], segments[i][j]\n\n    # Recombine segments with distance-based insertion\n    remaining_nodes = np.setdiff1d(np.arange(n), np.concatenate(segments))\n    new_solution = np.concatenate([segments[0], segments[1], segments[2], remaining_nodes])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Dynamic repair: insert missing nodes at positions with minimal distance impact\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        for node in missing:\n            best_pos = 0\n            min_cost = float('inf')\n            for i in range(1, n):\n                if i not in new_solution:\n                    cost = distance_matrix_1[new_solution[i-1], node] + distance_matrix_2[new_solution[i-1], node]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal followed by insertion\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]  # Reverse the segment\n\n        # Randomly select a node to insert elsewhere\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9000377834619508,
            1.5289738774299622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal followed by insertion\n    if n > 3:\n        # Randomly select a segment to reverse\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]  # Reverse the segment\n\n        # Randomly select a node to insert elsewhere\n        i = random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = random.randint(1, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel multi-segment inversion operator that reverses segments of the tour while ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert each segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9363651282241561,
            1.5074146389961243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion operator\n    # Randomly select 3 distinct segments and invert them\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Invert each segment\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[c:] = new_solution[c:][::-1]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment flips and edge swaps, with fallback to a simpler segment reversal if the move becomes infeasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge rotation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select segments and rotate edges\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and rotate edges\n    new_solution[a:b] = np.roll(new_solution[a:b], random.randint(-1, 1))\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9159766898656421,
            0.21571052074432373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge rotation\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select segments and rotate edges\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and rotate edges\n    new_solution[a:b] = np.roll(new_solution[a:b], random.randint(-1, 1))\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The new algorithm selects a solution from the archive using a hybrid selection criterion based on both objectives and their relative improvement potential, then applies a novel segment-based crossover with adaptive segment reversal and edge reordering to generate a high-quality neighbor solution while ensuring feasibility through a multi-phase validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = sorted_archive[0][0].copy()\n    n = len(selected_solution)\n\n    # Novel segment-based crossover with adaptive reversal\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments with different lengths\n    segments = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply adaptive reversal based on objective improvement potential\n    if random.random() < 0.7:  # Higher probability for beneficial reversals\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    if random.random() < 0.5:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Edge reordering based on distance improvement\n    for i in range(1, n-1):\n        if random.random() < 0.3:  # 30% chance to reorder edges\n            j = random.randint(1, n-1)\n            if j != i and j != i+1 and j != i-1:\n                # Swap edges with potential for distance reduction\n                if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]) < \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a fallback strategy\n        new_solution = selected_solution.copy()\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7599737743719505,
            0.24479645490646362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_solution = sorted_archive[0][0].copy()\n    n = len(selected_solution)\n\n    # Novel segment-based crossover with adaptive reversal\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments with different lengths\n    segments = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Apply adaptive reversal based on objective improvement potential\n    if random.random() < 0.7:  # Higher probability for beneficial reversals\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    if random.random() < 0.5:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Edge reordering based on distance improvement\n    for i in range(1, n-1):\n        if random.random() < 0.3:  # 30% chance to reorder edges\n            j = random.randint(1, n-1)\n            if j != i and j != i+1 and j != i-1:\n                # Swap edges with potential for distance reduction\n                if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]]) < \\\n                   (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, use a fallback strategy\n        new_solution = selected_solution.copy()\n        i = random.randint(1, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path inversion and segment rotation operator\n    # Randomly select two segments and invert one while rotating the other\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Invert the first segment\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Rotate the second segment by a random amount\n    rotation = random.randint(1, b - a)\n    new_solution[c:d] = np.roll(new_solution[c:d], rotation)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a circular shift to fix\n        shift = random.randint(1, n - 1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n",
        "score": [
            -0.9561773984825205,
            0.2079259157180786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path inversion and segment rotation operator\n    # Randomly select two segments and invert one while rotating the other\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Invert the first segment\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Rotate the second segment by a random amount\n    rotation = random.randint(1, b - a)\n    new_solution[c:d] = np.roll(new_solution[c:d], rotation)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a circular shift to fix\n        shift = random.randint(1, n - 1)\n        new_solution = np.roll(new_solution, shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objectives and dominance count, then applies a multi-segment relocation and inversion operator to generate a neighbor solution with enhanced exploration capabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment relocation and inversion operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Invert segments with 30% probability\n    if random.random() < 0.3:\n        segment2 = segment2[::-1]\n        segment3 = segment3[::-1]\n\n    # Recombine segments in a new order\n    new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9721133366494568,
            1.4669272303581238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment relocation and inversion operator\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Invert segments with 30% probability\n    if random.random() < 0.3:\n        segment2 = segment2[::-1]\n        segment3 = segment3[::-1]\n\n    # Recombine segments in a new order\n    new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects the solution with the highest combined objective value from the archive, then applies a novel hybrid local search that combines segment reversal with a dynamic edge-swap strategy, while ensuring feasibility by validating the solution and reverting to a simpler move if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to reverse and swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and dynamic edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.918967720991995,
            0.23191481828689575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to reverse and swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and dynamic edge-swap\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid metric of objective values and distance from the Pareto front, then applies a novel multi-segment inversion and reordering strategy while ensuring feasibility through a combination of segment validation and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion strategy\n    # Randomly select 4 distinct segments and invert them in a specific pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create four segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Apply alternating inversion pattern\n    segment2 = np.flip(segment2)\n    segment4 = np.flip(segment4)\n\n    # Reorder segments in a specific pattern\n    new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment swap to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9648556566583483,
            1.5834328532218933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment inversion strategy\n    # Randomly select 4 distinct segments and invert them in a specific pattern\n    segments = sorted(random.sample(range(1, n), 4))\n    a, b, c, d = segments[0], segments[1], segments[2], segments[3]\n\n    # Create four segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Apply alternating inversion pattern\n    segment2 = np.flip(segment2)\n    segment4 = np.flip(segment4)\n\n    # Reorder segments in a specific pattern\n    new_solution = np.concatenate([segment3, segment1, segment5, segment2, segment4])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a segment swap to fix\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0186994856988998,
            1.5465465188026428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0186994856988998,
            1.5465465188026428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objectives while considering dominance relationships, then applies a multi-segment relocation operator with adaptive segment selection and a dominance-aware recombination strategy to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective, second objective\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) *\n                          (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation operator\n    # Select segments based on their potential for improvement\n    segment_points = sorted(random.sample(range(1, n), 3))\n    a, b, c = segment_points[0], segment_points[1], segment_points[2]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Dominance-aware recombination\n    # Evaluate potential configurations based on objective dominance\n    configs = [\n        (np.concatenate([segment2, segment1, segment4, segment3]),),\n        (np.concatenate([segment3, segment4, segment2, segment1]),),\n        (np.concatenate([segment1, segment3, segment2, segment4]),),\n        (np.concatenate([segment4, segment2, segment3, segment1]),)\n    ]\n\n    # Calculate dominance for each configuration\n    dominance_scores = []\n    for config in configs:\n        total_cost1 = sum(distance_matrix_1[config[0][i], config[0][i+1]] for i in range(n-1)) + distance_matrix_1[config[0][-1], config[0][0]]\n        total_cost2 = sum(distance_matrix_2[config[0][i], config[0][i+1]] for i in range(n-1)) + distance_matrix_2[config[0][-1], config[0][0]]\n        dominance = sum(1 for sol in archive if sol[1][0] < total_cost1 and sol[1][1] < total_cost2)\n        dominance_scores.append(dominance)\n\n    # Select configuration with highest dominance score\n    best_config = configs[dominance_scores.index(min(dominance_scores))][0]\n\n    # Apply the best configuration\n    new_solution = best_config.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a dominance-aware swap\n        for i in range(n):\n            for j in range(i+1, n):\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                temp_cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                temp_cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                if sum(1 for sol in archive if sol[1][0] < temp_cost1 and sol[1][1] < temp_cost2) < sum(1 for sol in archive if sol[1][0] < total_cost1 and sol[1][1] < total_cost2):\n                    new_solution = temp\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9460957333366076,
            1.563064455986023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective, second objective\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) *\n                          (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment relocation operator\n    # Select segments based on their potential for improvement\n    segment_points = sorted(random.sample(range(1, n), 3))\n    a, b, c = segment_points[0], segment_points[1], segment_points[2]\n\n    # Create segments\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Dominance-aware recombination\n    # Evaluate potential configurations based on objective dominance\n    configs = [\n        (np.concatenate([segment2, segment1, segment4, segment3]),),\n        (np.concatenate([segment3, segment4, segment2, segment1]),),\n        (np.concatenate([segment1, segment3, segment2, segment4]),),\n        (np.concatenate([segment4, segment2, segment3, segment1]),)\n    ]\n\n    # Calculate dominance for each configuration\n    dominance_scores = []\n    for config in configs:\n        total_cost1 = sum(distance_matrix_1[config[0][i], config[0][i+1]] for i in range(n-1)) + distance_matrix_1[config[0][-1], config[0][0]]\n        total_cost2 = sum(distance_matrix_2[config[0][i], config[0][i+1]] for i in range(n-1)) + distance_matrix_2[config[0][-1], config[0][0]]\n        dominance = sum(1 for sol in archive if sol[1][0] < total_cost1 and sol[1][1] < total_cost2)\n        dominance_scores.append(dominance)\n\n    # Select configuration with highest dominance score\n    best_config = configs[dominance_scores.index(min(dominance_scores))][0]\n\n    # Apply the best configuration\n    new_solution = best_config.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a dominance-aware swap\n        for i in range(n):\n            for j in range(i+1, n):\n                temp = new_solution.copy()\n                temp[i], temp[j] = temp[j], temp[i]\n                temp_cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                temp_cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                if sum(1 for sol in archive if sol[1][0] < temp_cost1 and sol[1][1] < temp_cost2) < sum(1 for sol in archive if sol[1][0] < total_cost1 and sol[1][1] < total_cost2):\n                    new_solution = temp\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{A novel local search operator that combines segment reversal with edge reordering based on objective-aware distance metrics to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Objective-aware segment reversal with edge reordering\n    # Select a segment to reverse based on combined distance improvement potential\n    segment_length = random.randint(3, min(10, n-2))\n    start = random.randint(0, n - segment_length)\n\n    # Calculate combined distance improvement potential for the segment\n    segment = selected_solution[start:start+segment_length]\n    current_dist = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]] +\n                    distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]])\n    reversed_dist = (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]] +\n                     distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]])\n\n    # Apply segment reversal if it improves both objectives\n    if reversed_dist < current_dist:\n        new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Additional edge reordering based on objective-aware distance\n    # Select two edges to swap based on their combined distance\n    i, j = sorted(random.sample(range(1, n), 2))\n    edge1_dist = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]]\n    edge2_dist = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # Swap edges if it improves both objectives\n    if edge1_dist + edge2_dist > (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9035822884905151,
            0.1971721649169922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Objective-aware segment reversal with edge reordering\n    # Select a segment to reverse based on combined distance improvement potential\n    segment_length = random.randint(3, min(10, n-2))\n    start = random.randint(0, n - segment_length)\n\n    # Calculate combined distance improvement potential for the segment\n    segment = selected_solution[start:start+segment_length]\n    current_dist = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]] +\n                    distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]])\n    reversed_dist = (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]] +\n                     distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]])\n\n    # Apply segment reversal if it improves both objectives\n    if reversed_dist < current_dist:\n        new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Additional edge reordering based on objective-aware distance\n    # Select two edges to swap based on their combined distance\n    i, j = sorted(random.sample(range(1, n), 2))\n    edge1_dist = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]]\n    edge2_dist = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n    # Swap edges if it improves both objectives\n    if edge1_dist + edge2_dist > (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                 distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{A novel algorithm that combines a weighted crowding-distance-based selection with a hybrid local search that includes segment reversal and edge swapping, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(obj1, obj2):\n        return (obj1 + obj2) * 0.5\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x[1][0], x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swap\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.6757256237803008,
            0.20664244890213013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def crowding_distance(obj1, obj2):\n        return (obj1 + obj2) * 0.5\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x[1][0], x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal and edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swap\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to extract and invert\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = np.flip(new_solution[a:b])\n\n    # Randomly select a position to insert the inverted segment\n    c = random.randint(1, n - len(segment))\n\n    # Remove the original segment and insert the inverted one\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.insert(new_solution, c, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8606826676481728,
            0.2107136845588684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to extract and invert\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = np.flip(new_solution[a:b])\n\n    # Randomly select a position to insert the inverted segment\n    c = random.randint(1, n - len(segment))\n\n    # Remove the original segment and insert the inverted one\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.insert(new_solution, c, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment inversion with edge insertion\n    # Randomly select two segments and invert them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Randomly select an edge to insert elsewhere\n    e, f = sorted(random.sample(range(1, n), 2))\n    edge = new_solution[e:f]\n\n    # Remove the edge and insert it at a random position\n    new_solution = np.concatenate([new_solution[:e], new_solution[f:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9247107436587163,
            1.5115097761154175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine segment inversion with edge insertion\n    # Randomly select two segments and invert them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Randomly select an edge to insert elsewhere\n    e, f = sorted(random.sample(range(1, n), 2))\n    edge = new_solution[e:f]\n\n    # Remove the edge and insert it at a random position\n    new_solution = np.concatenate([new_solution[:e], new_solution[f:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, edge)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator: randomly select 4 segments and insert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with a dynamic permutation strategy based on distance improvements\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment4, segment2, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2])\n\n    # Ensure feasibility by checking for duplicates and fixing with a random swap if needed\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8835694831054022,
            1.4642921090126038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment insertion operator: randomly select 4 segments and insert them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments with a dynamic permutation strategy based on distance improvements\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment1, segment4, segment2, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment1, segment4, segment2])\n\n    # Ensure feasibility by checking for duplicates and fixing with a random swap if needed\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-segment relocation operator\n    # Randomly select 3 distinct segments and relocate them in a new configuration\n    segments = sorted(random.sample(range(1, n), 3))\n    a, b, c = segments[0], segments[1], segments[2]\n\n    # Create three segments and relocate them in a new order\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order (with 50% probability of each permutation)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([segment2, segment1, segment4, segment3])\n    else:\n        new_solution = np.concatenate([segment3, segment4, segment2, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in the archive\n    def crowding_distance(sol):\n        obj1, obj2 = sol[1]\n        neighbors = [s for s in archive if s[1] != sol[1]]\n        if not neighbors:\n            return 0\n        min1 = min(s[1][0] for s in neighbors)\n        max1 = max(s[1][0] for s in neighbors)\n        min2 = min(s[1][1] for s in neighbors)\n        max2 = max(s[1][1] for s in neighbors)\n        dist1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0\n        dist2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0\n        return dist1 + dist2\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-objective path crossover operator\n    # Select two crossover points and create a new path by combining segments from both objectives\n    if n > 3:\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Decide which objective to prioritize for the middle segment\n        if random.random() < 0.5:\n            # Prioritize first objective\n            obj1_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            obj2_cost = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            if obj1_cost < obj2_cost:\n                new_solution = np.concatenate([segment1, segment3, segment2])\n            else:\n                new_solution = np.concatenate([segment3, segment1, segment2])\n        else:\n            # Prioritize second objective\n            obj1_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            obj2_cost = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            if obj2_cost < obj1_cost:\n                new_solution = np.concatenate([segment2, segment1, segment3])\n            else:\n                new_solution = np.concatenate([segment2, segment3, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9216000379680928,
            4.363684713840485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in the archive\n    def crowding_distance(sol):\n        obj1, obj2 = sol[1]\n        neighbors = [s for s in archive if s[1] != sol[1]]\n        if not neighbors:\n            return 0\n        min1 = min(s[1][0] for s in neighbors)\n        max1 = max(s[1][0] for s in neighbors)\n        min2 = min(s[1][1] for s in neighbors)\n        max2 = max(s[1][1] for s in neighbors)\n        dist1 = (obj1 - min1) / (max1 - min1) if max1 != min1 else 0\n        dist2 = (obj2 - min2) / (max2 - min2) if max2 != min2 else 0\n        return dist1 + dist2\n\n    selected_solution = max(archive, key=lambda x: crowding_distance(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel multi-objective path crossover operator\n    # Select two crossover points and create a new path by combining segments from both objectives\n    if n > 3:\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Decide which objective to prioritize for the middle segment\n        if random.random() < 0.5:\n            # Prioritize first objective\n            obj1_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            obj2_cost = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            if obj1_cost < obj2_cost:\n                new_solution = np.concatenate([segment1, segment3, segment2])\n            else:\n                new_solution = np.concatenate([segment3, segment1, segment2])\n        else:\n            # Prioritize second objective\n            obj1_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            obj2_cost = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n            if obj2_cost < obj1_cost:\n                new_solution = np.concatenate([segment2, segment1, segment3])\n            else:\n                new_solution = np.concatenate([segment2, segment3, segment1])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective trade-off, then applies a multi-segment permutation operator with adaptive segment sizes and probabilistic edge reconnection to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment permutation with adaptive sizes\n    num_segments = random.randint(2, min(4, n // 3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = np.split(new_solution[1:], segment_indices)\n\n    # Randomly permute segments with probability based on size\n    if random.random() < 0.4:\n        random.shuffle(segments)\n        new_solution[1:] = np.concatenate(segments)\n\n    # Probabilistic edge reconnection\n    for _ in range(random.randint(1, 3)):\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.6:\n            new_solution[i:j] = np.roll(new_solution[i:j], random.randint(1, j-i))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping conflicting nodes\n        duplicates = np.where(np.diff(new_solution) == 0)[0] + 1\n        for idx in duplicates:\n            swap_candidates = [i for i in range(1, n) if i not in new_solution[:idx]]\n            if swap_candidates:\n                new_solution[idx] = random.choice(swap_candidates)\n\n    return new_solution\n\n",
        "score": [
            -0.9441640805337776,
            1.3189213871955872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment permutation with adaptive sizes\n    num_segments = random.randint(2, min(4, n // 3))\n    segment_indices = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = np.split(new_solution[1:], segment_indices)\n\n    # Randomly permute segments with probability based on size\n    if random.random() < 0.4:\n        random.shuffle(segments)\n        new_solution[1:] = np.concatenate(segments)\n\n    # Probabilistic edge reconnection\n    for _ in range(random.randint(1, 3)):\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.6:\n            new_solution[i:j] = np.roll(new_solution[i:j], random.randint(1, j-i))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping conflicting nodes\n        duplicates = np.where(np.diff(new_solution) == 0)[0] + 1\n        for idx in duplicates:\n            swap_candidates = [i for i in range(1, n) if i not in new_solution[:idx]]\n            if swap_candidates:\n                new_solution[idx] = random.choice(swap_candidates)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining segment inversion with a probabilistic node exchange operation to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(sorted_archive))\n    for m in range(2):  # For each objective\n        objectives = [x[1][m] for x in sorted_archive]\n        min_obj, max_obj = min(objectives), max(objectives)\n        if min_obj == max_obj:\n            continue\n        for i in range(1, len(sorted_archive)-1):\n            crowding[i] += (sorted_archive[i+1][1][m] - sorted_archive[i-1][1][m]) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment inversion with probabilistic node exchange\n    segment_size = max(2, random.randint(1, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Segment inversion\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Probabilistic node exchange\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9531178138267312,
            0.23306626081466675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n\n    # Calculate crowding distances\n    crowding = np.zeros(len(sorted_archive))\n    for m in range(2):  # For each objective\n        objectives = [x[1][m] for x in sorted_archive]\n        min_obj, max_obj = min(objectives), max(objectives)\n        if min_obj == max_obj:\n            continue\n        for i in range(1, len(sorted_archive)-1):\n            crowding[i] += (sorted_archive[i+1][1][m] - sorted_archive[i-1][1][m]) / (max_obj - min_obj)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment inversion with probabilistic node exchange\n    segment_size = max(2, random.randint(1, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Segment inversion\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Probabilistic node exchange\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge-swap: swap two randomly selected edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Revert to simple segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9327129369640469,
            0.2115291953086853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge-swap: swap two randomly selected edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Revert to simple segment reversal if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm selects the best solution from the archive based on a novel weighted sum of objectives (prioritizing solutions with balanced improvement potential) and applies a hybrid local search combining segment reversal with a novel edge-reconnection strategy to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * (x[1][0]/x[1][1] if x[1][1] != 0 else 1)))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reconnection\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse segments and reconnect edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Novel edge reconnection\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler segment reversal\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9058523298620793,
            0.2878401279449463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * (x[1][0]/x[1][1] if x[1][1] != 0 else 1)))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reconnection\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse segments and reconnect edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Novel edge reconnection\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler segment reversal\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Novel local search: Multi-segment shuffle with objective-aware segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify segments with high objective cost (potential for improvement)\n    segment_costs = []\n    for i in range(1, n):\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        segment_costs.append(cost1 + cost2)\n\n    # Select top-k segments with highest cost\n    k = max(2, n // 5)  # At least 2 segments, up to 1/5 of tour\n    high_cost_indices = np.argsort(segment_costs)[-k:]\n\n    # Shuffle these high-cost segments\n    for i in high_cost_indices:\n        a, b = i, i + 1\n        if b >= n:\n            b = n - 1\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i = random.randint(1, n - 2)\n        new_solution[i:i+2] = np.flip(new_solution[i:i+2])\n\n    return new_solution\n\n",
        "score": [
            -0.7987912022570065,
            0.24113279581069946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Novel local search: Multi-segment shuffle with objective-aware segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify segments with high objective cost (potential for improvement)\n    segment_costs = []\n    for i in range(1, n):\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        segment_costs.append(cost1 + cost2)\n\n    # Select top-k segments with highest cost\n    k = max(2, n // 5)  # At least 2 segments, up to 1/5 of tour\n    high_cost_indices = np.argsort(segment_costs)[-k:]\n\n    # Shuffle these high-cost segments\n    for i in high_cost_indices:\n        a, b = i, i + 1\n        if b >= n:\n            b = n - 1\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i = random.randint(1, n - 2)\n        new_solution[i:i+2] = np.flip(new_solution[i:i+2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a novel hybrid local search combining segment reversal and edge reordering, ensuring feasibility through validation and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] / (distance_matrix_1.sum() + 1e-10)) + (x[1][1] / (distance_matrix_2.sum() + 1e-10)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse two segments and reorder edges between them\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge reordering: swap two random edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a segment reversal\n        k, l = sorted(random.sample(range(1, n-1), 2))\n        new_solution[k:l] = np.flip(new_solution[k:l])\n\n    return new_solution\n\n",
        "score": [
            -0.8542426507195789,
            0.24538010358810425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] / (distance_matrix_1.sum() + 1e-10)) + (x[1][1] / (distance_matrix_2.sum() + 1e-10)))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    c, d = sorted(random.sample(range(1, n-1), 2))\n\n    # Reverse two segments and reorder edges between them\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge reordering: swap two random edges\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a segment reversal\n        k, l = sorted(random.sample(range(1, n-1), 2))\n        new_solution[k:l] = np.flip(new_solution[k:l])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining a novel node-chain reordering with a dynamic segment rotation operator to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Node-chain reordering with dynamic segment rotation\n    chain_length = random.randint(3, min(6, n // 3))\n    start = random.randint(1, n - chain_length)\n\n    # Extract and reorder a chain of nodes\n    chain = new_solution[start:start+chain_length]\n    reordered_chain = np.roll(chain, random.randint(1, chain_length-1))\n\n    # Apply dynamic segment rotation\n    if random.random() < 0.7:\n        segment_size = random.randint(2, min(5, n // 4))\n        segment_start = random.randint(1, n - segment_size)\n        segment = new_solution[segment_start:segment_start+segment_size]\n        rotated_segment = np.roll(segment, random.randint(1, segment_size-1))\n        new_solution[segment_start:segment_start+segment_size] = rotated_segment\n\n    # Insert reordered chain back\n    new_solution[start:start+chain_length] = reordered_chain\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes that create duplicates\n        duplicates = np.where(np.bincount(new_solution) > 1)[0]\n        for d in duplicates:\n            positions = np.where(new_solution == d)[0]\n            if len(positions) > 1:\n                i, j = positions[0], positions[1]\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9578493211332997,
            1.5162502527236938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Node-chain reordering with dynamic segment rotation\n    chain_length = random.randint(3, min(6, n // 3))\n    start = random.randint(1, n - chain_length)\n\n    # Extract and reorder a chain of nodes\n    chain = new_solution[start:start+chain_length]\n    reordered_chain = np.roll(chain, random.randint(1, chain_length-1))\n\n    # Apply dynamic segment rotation\n    if random.random() < 0.7:\n        segment_size = random.randint(2, min(5, n // 4))\n        segment_start = random.randint(1, n - segment_size)\n        segment = new_solution[segment_start:segment_start+segment_size]\n        rotated_segment = np.roll(segment, random.randint(1, segment_size-1))\n        new_solution[segment_start:segment_start+segment_size] = rotated_segment\n\n    # Insert reordered chain back\n    new_solution[start:start+chain_length] = reordered_chain\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes that create duplicates\n        duplicates = np.where(np.bincount(new_solution) > 1)[0]\n        for d in duplicates:\n            positions = np.where(new_solution == d)[0]\n            if len(positions) > 1:\n                i, j = positions[0], positions[1]\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Novel local search: Apply a multi-segment inversion with adaptive segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly determine the number of segments to invert (between 2 and 4)\n    num_segments = random.randint(2, 4)\n\n    # Generate non-overlapping segments and invert them\n    segments = []\n    for _ in range(num_segments):\n        a, b = sorted(random.sample(range(1, n), 2))\n        segments.append((a, b))\n\n    # Sort segments by start index to avoid overlaps\n    segments.sort()\n\n    # Apply inversions in order\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a single segment inversion\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.795956192514123,
            0.22842419147491455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Novel local search: Apply a multi-segment inversion with adaptive segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly determine the number of segments to invert (between 2 and 4)\n    num_segments = random.randint(2, 4)\n\n    # Generate non-overlapping segments and invert them\n    segments = []\n    for _ in range(num_segments):\n        a, b = sorted(random.sample(range(1, n), 2))\n        segments.append((a, b))\n\n    # Sort segments by start index to avoid overlaps\n    segments.sort()\n\n    # Apply inversions in order\n    for a, b in segments:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a single segment inversion\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{A novel algorithm that selects the least crowded solution in the objective space and applies a multi-segment inversion strategy with adaptive segment length to explore diverse regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for (sol, obj) in archive])\n        crowding = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmin(crowding)\n        selected_solution = archive[selected_idx][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment inversion\n    num_segments = random.randint(2, min(4, n//2))\n    segment_lengths = sorted(random.sample(range(2, n//2), num_segments))\n    segment_lengths.append(n)\n\n    current_pos = 1\n    for length in segment_lengths:\n        next_pos = min(current_pos + length, n)\n        if next_pos - current_pos > 1:\n            new_solution[current_pos:next_pos] = np.flip(new_solution[current_pos:next_pos])\n        current_pos = next_pos\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to single segment inversion if needed\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8790807444987853,
            0.2219889760017395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for (sol, obj) in archive])\n        crowding = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmin(crowding)\n        selected_solution = archive[selected_idx][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive multi-segment inversion\n    num_segments = random.randint(2, min(4, n//2))\n    segment_lengths = sorted(random.sample(range(2, n//2), num_segments))\n    segment_lengths.append(n)\n\n    current_pos = 1\n    for length in segment_lengths:\n        next_pos = min(current_pos + length, n)\n        if next_pos - current_pos > 1:\n            new_solution[current_pos:next_pos] = np.flip(new_solution[current_pos:next_pos])\n        current_pos = next_pos\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to single segment inversion if needed\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines adaptive node swapping with dynamic segment relinking to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive node swapping with segment relinking\n    segment_size = max(2, min(5, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Adaptive node swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(start, end), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment relinking\n    if random.random() < 0.5:\n        relink_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+relink_size]\n        new_solution = np.concatenate([new_solution[:start], segment[-1:], segment[:-1], new_solution[start+relink_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two nodes in the affected segment\n        i, j = random.sample(range(start, end), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9262657937054088,
            1.493664801120758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: adaptive node swapping with segment relinking\n    segment_size = max(2, min(5, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Adaptive node swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(start, end), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic segment relinking\n    if random.random() < 0.5:\n        relink_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+relink_size]\n        new_solution = np.concatenate([new_solution[:start], segment[-1:], segment[:-1], new_solution[start+relink_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two nodes in the affected segment\n        i, j = random.sample(range(start, end), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{An algorithm that selects a solution from the archive based on a combined objective and diversity metric, then applies a hybrid local search operator that combines segment-based inversion with adaptive node swaps and insertions to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.4:\n        # Segment-based inversion with adaptive size\n        segment_size = max(2, min(6, random.randint(1, n // 3)))\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n    else:\n        # Adaptive node swaps and insertions\n        if random.random() < 0.7:\n            # Swap two nodes\n            i, j = random.sample(range(1, n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Insert a node at a new position\n            node = random.choice(new_solution[1:-1])\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9767953107611653,
            1.4955833554267883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.4:\n        # Segment-based inversion with adaptive size\n        segment_size = max(2, min(6, random.randint(1, n // 3)))\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n    else:\n        # Adaptive node swaps and insertions\n        if random.random() < 0.7:\n            # Swap two nodes\n            i, j = random.sample(range(1, n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Insert a node at a new position\n            node = random.choice(new_solution[1:-1])\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            pos = random.randint(1, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a dynamic segment relocation operator with adaptive segment sizes and a probabilistic swap mechanism to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment relocation with adaptive size\n    segment_size = max(3, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Relocate segment to a new position\n    if random.random() < 0.7:\n        new_pos = random.randint(1, n - segment_size)\n        if new_pos != start:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Probabilistic swap mechanism\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8994856412206942,
            1.4488388299942017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment relocation with adaptive size\n    segment_size = max(3, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Relocate segment to a new position\n    if random.random() < 0.7:\n        new_pos = random.randint(1, n - segment_size)\n        if new_pos != start:\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Probabilistic swap mechanism\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random segments to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Recombine segments in a novel order\n    new_solution[a:] = np.concatenate((segment2, segment1, segment3))\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8375473416453207,
            0.17956578731536865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select three random segments to modify\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Recombine segments in a novel order\n    new_solution[a:] = np.concatenate((segment2, segment1, segment3))\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{A new algorithm that uses a weighted sum of objectives with adaptive weights, selects solutions with high potential for improvement, and applies a hybrid local search combining segment reversal and edge swapping while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = [w * (obj[0] + obj[1]) for (sol, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swap between segments\n    if b < c:\n        temp = new_solution[b:c].copy()\n        new_solution[b:c] = new_solution[a:a+len(temp)]\n        new_solution[a:a+len(temp)] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9094023664863518,
            0.20648741722106934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = [w * (obj[0] + obj[1]) for (sol, obj), w in zip(archive, weights)]\n    selected_idx = np.argmax(weighted_scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swap between segments\n    if b < c:\n        temp = new_solution[b:c].copy()\n        new_solution[b:c] = new_solution[a:a+len(temp)]\n        new_solution[a:a+len(temp)] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a novel hybrid operator that combines segment rotation with adaptive edge swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: adaptive segment rotation with edge swaps\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n\n    # Segment rotation with adaptive probability\n    if random.random() < (segment_size / (n // 2)):\n        rotate_amount = random.randint(1, segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotated = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n        new_solution[start:start+segment_size] = rotated\n\n    # Adaptive edge swaps based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(1, n-1), 2)\n        if i > j:\n            i, j = j, i\n        # Calculate cost change in both objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]])\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes that create duplicates\n        counts = np.bincount(new_solution)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n        for d in duplicates:\n            for m in missing:\n                if d in new_solution and m not in new_solution:\n                    idx = np.where(new_solution == d)[0][1]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.805707307464312,
            1.4841307997703552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: adaptive segment rotation with edge swaps\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n\n    # Segment rotation with adaptive probability\n    if random.random() < (segment_size / (n // 2)):\n        rotate_amount = random.randint(1, segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotated = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n        new_solution[start:start+segment_size] = rotated\n\n    # Adaptive edge swaps based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(1, n-1), 2)\n        if i > j:\n            i, j = j, i\n        # Calculate cost change in both objectives\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] +\n                    distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]])\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes that create duplicates\n        counts = np.bincount(new_solution)\n        duplicates = np.where(counts > 1)[0]\n        missing = np.where(counts == 0)[0]\n        for d in duplicates:\n            for m in missing:\n                if d in new_solution and m not in new_solution:\n                    idx = np.where(new_solution == d)[0][1]\n                    new_solution[idx] = m\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a normalized Pareto dominance score combined with a diversity metric, then applies a hybrid local search operator combining segment inversion and edge insertion with dynamically adjusted segment sizes and probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        dominated = sum(1 for y in archive if y[1][0] < obj1 and y[1][1] < obj2)\n        non_dominated = sum(1 for y in archive if y[1][0] <= obj1 and y[1][1] <= obj2)\n        diversity = sum(1 for y in archive if abs(y[1][0] - obj1) < 0.1 and abs(y[1][1] - obj2) < 0.1)\n        return (1 - dominated / len(archive)) * (1 + diversity) * (0.6 * obj1 + 0.4 * obj2)\n\n    selected_solution = max(archive, key=selection_score)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n\n    # Segment inversion with adaptive probability\n    if random.random() < (segment_size / n) * 0.8:\n        new_solution[start:start+segment_size] = np.flip(new_solution[start:start+segment_size])\n\n    # Edge insertion with probability\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6782088711989915,
            2.3085725903511047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(sol_obj):\n        obj1, obj2 = sol_obj[1]\n        dominated = sum(1 for y in archive if y[1][0] < obj1 and y[1][1] < obj2)\n        non_dominated = sum(1 for y in archive if y[1][0] <= obj1 and y[1][1] <= obj2)\n        diversity = sum(1 for y in archive if abs(y[1][0] - obj1) < 0.1 and abs(y[1][1] - obj2) < 0.1)\n        return (1 - dominated / len(archive)) * (1 + diversity) * (0.6 * obj1 + 0.4 * obj2)\n\n    selected_solution = max(archive, key=selection_score)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n\n    # Segment inversion with adaptive probability\n    if random.random() < (segment_size / n) * 0.8:\n        new_solution[start:start+segment_size] = np.flip(new_solution[start:start+segment_size])\n\n    # Edge insertion with probability\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{A novel algorithm that combines a multi-objective selection criterion with a hybrid local search strategy, which first evaluates solutions based on their Pareto dominance and then applies a combination of segment reversal and edge insertion moves to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge insertion: move a random segment to a new position\n    i, j = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[i:j].copy()\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(1, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8915475177548073,
            0.20953726768493652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge insertion: move a random segment to a new position\n    i, j = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[i:j].copy()\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(1, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search that combines segment reversal and a novel edge-swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first and second objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge-swap: Swap two edges with different nodes\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9927553435325058,
            0.22104007005691528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first and second objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with edge-swap\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and swap edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge-swap: Swap two edges with different nodes\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel cross-segment relocation operator that intelligently merges and splits segments of the tour to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Cross-segment relocation operator\n    if n > 4:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(1, n-2), 2))\n\n        # Ensure segments are distinct and non-overlapping\n        if a < c < b < d:\n            # Merge and split segments\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n\n            # Create new order: original before a, segment2, segment1, original after d\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[d:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9263076464581498,
            1.4528838396072388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Cross-segment relocation operator\n    if n > 4:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-2), 2))\n        c, d = sorted(random.sample(range(1, n-2), 2))\n\n        # Ensure segments are distinct and non-overlapping\n        if a < c < b < d:\n            # Merge and split segments\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n\n            # Create new order: original before a, segment2, segment1, original after d\n            new_solution = np.concatenate([\n                new_solution[:a],\n                segment2,\n                segment1,\n                new_solution[d:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to fix\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware objective combination, then applies a novel segment relocation and rotation hybrid operator with adaptive segment sizes and edge reordering to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    extracted_segment = new_solution[start:end]\n\n    if random.random() < 0.6:\n        new_position = random.randint(1, n - segment_size)\n        new_solution = np.concatenate([new_solution[:new_position], extracted_segment, new_solution[new_position:start], new_solution[end:]])\n\n    if random.random() < 0.4:\n        rotate_size = random.randint(1, segment_size)\n        rotated_segment = np.concatenate([extracted_segment[rotate_size:], extracted_segment[:rotate_size]])\n        new_solution[start:end] = rotated_segment\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9279404469470514,
            1.5916465520858765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    extracted_segment = new_solution[start:end]\n\n    if random.random() < 0.6:\n        new_position = random.randint(1, n - segment_size)\n        new_solution = np.concatenate([new_solution[:new_position], extracted_segment, new_solution[new_position:start], new_solution[end:]])\n\n    if random.random() < 0.4:\n        rotate_size = random.randint(1, segment_size)\n        rotated_segment = np.concatenate([extracted_segment[rotate_size:], extracted_segment[:rotate_size]])\n        new_solution[start:end] = rotated_segment\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a dynamic segment relocation operator with adaptive segment sizes and probabilistic edge swapping to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Dynamic segment relocation with adaptive size\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    if random.random() < 0.7:\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        segment = new_solution[start:end]\n\n        # Relocate segment to a new position\n        new_pos = random.randint(1, n - segment_size)\n        if new_pos >= start:\n            new_pos += segment_size\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.5:\n            # Swap edges (cross edges)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Swap nodes (swap entire positions)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9237664619802617,
            1.4007132053375244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Dynamic segment relocation with adaptive size\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    if random.random() < 0.7:\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        segment = new_solution[start:end]\n\n        # Relocate segment to a new position\n        new_pos = random.randint(1, n - segment_size)\n        if new_pos >= start:\n            new_pos += segment_size\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Probabilistic edge swapping\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.5:\n            # Swap edges (cross edges)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Swap nodes (swap entire positions)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a dynamic weighted combination of objectives and neighborhood diversity, then applies a hybrid segment relocation and inversion operator with adaptive segment sizes and probabilistic segment merging to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4] if random.random() < 0.5 else [0.4, 0.6]\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) *\n                           (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Hybrid segment relocation and inversion\n    if random.random() < 0.7:\n        segment = new_solution[start:end]\n        insert_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Probabilistic segment merging\n    if random.random() < 0.4 and n > 6:\n        merge_size = random.randint(1, min(4, n // 6))\n        merge_start = random.randint(1, n - merge_size - 1)\n        new_solution[merge_start:merge_start+merge_size] = np.roll(new_solution[merge_start:merge_start+merge_size], 1)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9625878159026726,
            1.4259312748908997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4] if random.random() < 0.5 else [0.4, 0.6]\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) *\n                           (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Hybrid segment relocation and inversion\n    if random.random() < 0.7:\n        segment = new_solution[start:end]\n        insert_pos = random.randint(0, n - segment_size)\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Probabilistic segment merging\n    if random.random() < 0.4 and n > 6:\n        merge_size = random.randint(1, min(4, n // 6))\n        merge_start = random.randint(1, n - merge_size - 1)\n        new_solution[merge_start:merge_start+merge_size] = np.roll(new_solution[merge_start:merge_start+merge_size], 1)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a novel path-splitting and merging strategy to create a neighbor by dividing the tour into segments, reordering them, and reconnecting while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Split the tour into three segments\n    split1 = random.randint(1, n-2)\n    split2 = random.randint(split1+1, n-1)\n\n    # Create three segments\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n\n    # Reorder segments with probability 0.5\n    if random.random() < 0.5:\n        segment1, segment2, segment3 = segment2, segment3, segment1\n    else:\n        segment1, segment2, segment3 = segment3, segment1, segment2\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([segment1, segment2, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9298934759781146,
            0.18774455785751343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Split the tour into three segments\n    split1 = random.randint(1, n-2)\n    split2 = random.randint(split1+1, n-1)\n\n    # Create three segments\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n\n    # Reorder segments with probability 0.5\n    if random.random() < 0.5:\n        segment1, segment2, segment3 = segment2, segment3, segment1\n    else:\n        segment1, segment2, segment3 = segment3, segment1, segment2\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([segment1, segment2, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a hybrid local search strategy that combines segment reversal with a novel edge-swap operation, ensuring feasibility through validation checks and fallback to a simpler move if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with position-based edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply position-based edge swapping\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution and fix if invalid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7750060912958092,
            0.19021016359329224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with position-based edge swapping\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse two segments\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply position-based edge swapping\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution and fix if invalid\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Split the tour into three segments and reorder them\n    split_points = sorted(random.sample(range(1, n), 2))\n    a, b, c = split_points[0], split_points[1], n\n\n    # Create three segments and reorder them\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n\n    # Randomly permute the order of the segments\n    segments = [segment1, segment2, segment3]\n    random.shuffle(segments)\n\n    # Reconstruct the solution with reordered segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9022060323188108,
            0.19954532384872437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: Split the tour into three segments and reorder them\n    split_points = sorted(random.sample(range(1, n), 2))\n    a, b, c = split_points[0], split_points[1], n\n\n    # Create three segments and reorder them\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n\n    # Randomly permute the order of the segments\n    segments = [segment1, segment2, segment3]\n    random.shuffle(segments)\n\n    # Reconstruct the solution with reordered segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a hybrid local search combining segment reversal and a novel edge-swap strategy, ensuring feasibility through validation and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: combine segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c = random.randint(1, n-1)\n\n    # Reverse segment and insert it at a different position\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.850487385237024,
            0.09209954738616943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: combine segment reversal with edge insertion\n    a, b = sorted(random.sample(range(1, n), 2))\n    c = random.randint(1, n-1)\n\n    # Reverse segment and insert it at a different position\n    segment = np.flip(new_solution[a:b])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{Select the worst-performing solution in the archive based on the combined objective value and apply a novel local search that combines segment reversal with a probabilistic edge-swap strategy, ensuring feasibility through a repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: probabilistic segment reversal with edge-swap\n    for _ in range(2):  # Apply twice for stronger perturbation\n        a, b = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.7:  # 70% chance to reverse segment\n            new_solution[a:b] = np.flip(new_solution[a:b])\n        else:  # 30% chance to swap edges\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair mechanism: ensure no duplicates by shuffling duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    if len(duplicates) > 0:\n        for dup in duplicates:\n            dup_indices = np.where(new_solution == dup)[0]\n            for idx in dup_indices[1:]:\n                available_nodes = np.setdiff1d(np.arange(n), new_solution)\n                if len(available_nodes) > 0:\n                    new_solution[idx] = random.choice(available_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.8490782159871438,
            0.19214457273483276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel local search: probabilistic segment reversal with edge-swap\n    for _ in range(2):  # Apply twice for stronger perturbation\n        a, b = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.7:  # 70% chance to reverse segment\n            new_solution[a:b] = np.flip(new_solution[a:b])\n        else:  # 30% chance to swap edges\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Repair mechanism: ensure no duplicates by shuffling duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    if len(duplicates) > 0:\n        for dup in duplicates:\n            dup_indices = np.where(new_solution == dup)[0]\n            for idx in dup_indices[1:]:\n                available_nodes = np.setdiff1d(np.arange(n), new_solution)\n                if len(available_nodes) > 0:\n                    new_solution[idx] = random.choice(available_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-segment reversal strategy with a guided edge insertion mechanism to intelligently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment reversal strategy\n    k = random.randint(2, min(5, n//2))  # Number of segments to reverse\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    for i in range(1, len(segments)):\n        start, end = segments[i-1], segments[i]\n        if start < end:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Guided edge insertion mechanism\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a guided insertion\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        while j == i or j == (i+1)%n:\n            j = random.randint(1, n-1)\n\n        # Calculate potential improvements in both objectives\n        def cost_change(sol, i, j, distance_matrix):\n            old_cost = (distance_matrix[sol[i-1], sol[i]] +\n                        distance_matrix[sol[j-1], sol[j]])\n            new_cost = (distance_matrix[sol[i-1], sol[j]] +\n                        distance_matrix[sol[j-1], sol[i]])\n            return new_cost - old_cost\n\n        delta1 = cost_change(new_solution, i, j, distance_matrix_1)\n        delta2 = cost_change(new_solution, i, j, distance_matrix_2)\n\n        if delta1 + delta2 < 0:  # If improvement in both objectives\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8437069989808468,
            0.18787795305252075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment reversal strategy\n    k = random.randint(2, min(5, n//2))  # Number of segments to reverse\n    segments = sorted(random.sample(range(1, n), k))\n    segments = [0] + segments + [n]\n\n    for i in range(1, len(segments)):\n        start, end = segments[i-1], segments[i]\n        if start < end:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Guided edge insertion mechanism\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a guided insertion\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        while j == i or j == (i+1)%n:\n            j = random.randint(1, n-1)\n\n        # Calculate potential improvements in both objectives\n        def cost_change(sol, i, j, distance_matrix):\n            old_cost = (distance_matrix[sol[i-1], sol[i]] +\n                        distance_matrix[sol[j-1], sol[j]])\n            new_cost = (distance_matrix[sol[i-1], sol[j]] +\n                        distance_matrix[sol[j-1], sol[i]])\n            return new_cost - old_cost\n\n        delta1 = cost_change(new_solution, i, j, distance_matrix_1)\n        delta2 = cost_change(new_solution, i, j, distance_matrix_2)\n\n        if delta1 + delta2 < 0:  # If improvement in both objectives\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal and edge swapping with probabilistic acceptance criteria to ensure feasible and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with probabilistic edge swaps\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Probabilistic edge swap\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9480078194941206,
            0.20474731922149658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with probabilistic edge swaps\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Probabilistic edge swap\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge reordering with a novel feasibility check mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply novel hybrid local search\n    # Randomly select two segments and perform segment reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments with higher probability if they improve both objectives\n    if (distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[d-1], new_solution[c]] <\n        distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) and \\\n       (distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[d-1], new_solution[c]] <\n        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]):\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n    else:\n        # If no improvement, perform simpler edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9474215780981133,
            0.19293349981307983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply novel hybrid local search\n    # Randomly select two segments and perform segment reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments with higher probability if they improve both objectives\n    if (distance_matrix_1[new_solution[b-1], new_solution[a]] + distance_matrix_1[new_solution[d-1], new_solution[c]] <\n        distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) and \\\n       (distance_matrix_2[new_solution[b-1], new_solution[a]] + distance_matrix_2[new_solution[d-1], new_solution[c]] <\n        distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]):\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n    else:\n        # If no improvement, perform simpler edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and a node to reinsert\n    a, b = sorted(random.sample(range(1, n), 2))\n    k = random.randint(1, n - 1)\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply node insertion: remove node at k and reinsert it at a random position\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility (though insertion should naturally maintain it)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8478016166282011,
            0.20047134160995483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and a node to reinsert\n    a, b = sorted(random.sample(range(1, n), 2))\n    k = random.randint(1, n - 1)\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply node insertion: remove node at k and reinsert it at a random position\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility (though insertion should naturally maintain it)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines node insertion, segment reversal, and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Node insertion\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n    else:\n        # Segment reversal with adaptive size\n        segment_size = max(2, min(4, random.randint(1, n // 3)))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive edge swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9452988654431835,
            1.4320635795593262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Node insertion\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n    else:\n        # Segment reversal with adaptive size\n        segment_size = max(2, min(4, random.randint(1, n // 3)))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive edge swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{A new algorithm that selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel path-splicing operator that combines segments from different solutions in the archive to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Path-splicing operator: combine segments from other solutions\n    if len(archive) > 1 and random.random() < 0.5:\n        other_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], selected_solution)])\n\n        # Select two random segments from the other solution\n        seg1_start = random.randint(0, n - 2)\n        seg1_end = random.randint(seg1_start + 1, n - 1)\n        seg1 = other_solution[seg1_start:seg1_end]\n\n        seg2_start = random.randint(0, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n        seg2 = other_solution[seg2_start:seg2_end]\n\n        # Insert segments into the current solution\n        pos1 = random.randint(0, n - len(seg1))\n        pos2 = random.randint(0, n - len(seg2))\n\n        new_solution = np.concatenate([\n            new_solution[:pos1], seg1, new_solution[pos1 + len(seg1):]\n        ])\n        new_solution = np.concatenate([\n            new_solution[:pos2], seg2, new_solution[pos2 + len(seg2):]\n        ])\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Truncate to ensure correct length\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -1.001964953321072,
            2.0337727665901184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Path-splicing operator: combine segments from other solutions\n    if len(archive) > 1 and random.random() < 0.5:\n        other_solution = random.choice([x[0] for x in archive if not np.array_equal(x[0], selected_solution)])\n\n        # Select two random segments from the other solution\n        seg1_start = random.randint(0, n - 2)\n        seg1_end = random.randint(seg1_start + 1, n - 1)\n        seg1 = other_solution[seg1_start:seg1_end]\n\n        seg2_start = random.randint(0, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n        seg2 = other_solution[seg2_start:seg2_end]\n\n        # Insert segments into the current solution\n        pos1 = random.randint(0, n - len(seg1))\n        pos2 = random.randint(0, n - len(seg2))\n\n        new_solution = np.concatenate([\n            new_solution[:pos1], seg1, new_solution[pos1 + len(seg1):]\n        ])\n        new_solution = np.concatenate([\n            new_solution[:pos2], seg2, new_solution[pos2 + len(seg2):]\n        ])\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Truncate to ensure correct length\n    new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a Pareto-dominance-inspired selection criterion and applies a hybrid local search operator combining segment swaps with adaptive segment sizes and probabilistic edge insertions to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(5, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Segment swap with adaptive probability\n    if random.random() < (segment_size / (n // 3)):\n        swap_pos = random.randint(1, n - segment_size)\n        new_solution[start:end], new_solution[swap_pos:swap_pos+segment_size] = new_solution[swap_pos:swap_pos+segment_size].copy(), new_solution[start:end].copy()\n\n    # Probabilistic edge insertion\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        if abs(i - j) > 1:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7962624709459518,
            1.459353506565094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(5, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Segment swap with adaptive probability\n    if random.random() < (segment_size / (n // 3)):\n        swap_pos = random.randint(1, n - segment_size)\n        new_solution[start:end], new_solution[swap_pos:swap_pos+segment_size] = new_solution[swap_pos:swap_pos+segment_size].copy(), new_solution[start:end].copy()\n\n    # Probabilistic edge insertion\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        if abs(i - j) > 1:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by reversing a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on an adaptive weighted combination of objectives and solution diversity, then applies a hybrid local search operator combining segment rotation and dynamic segment inversion with probabilistic segment selection to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = (0.6, 0.4) if np.random.random() < 0.5 else (0.4, 0.6)\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) * (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = random.randint(2, min(7, n // 3))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Probabilistic segment rotation\n    if random.random() < 0.7:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Dynamic segment inversion with adaptive probability\n    if random.random() < (segment_size / (n // 2)) * 0.8:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes with worst improvement potential\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9765638190971732,
            1.6787083148956299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = (0.6, 0.4) if np.random.random() < 0.5 else (0.4, 0.6)\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) * (1 + 0.5 * sum(1 for y in archive if y[1][0] < x[1][0] or y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = random.randint(2, min(7, n // 3))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Probabilistic segment rotation\n    if random.random() < 0.7:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Dynamic segment inversion with adaptive probability\n    if random.random() < (segment_size / (n // 2)) * 0.8:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes with worst improvement potential\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score and diversity, then applies a hybrid local search combining adaptive segment inversion with probabilistic node swaps to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]) for x in archive])\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(4, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Adaptive segment operation\n    if random.random() < 0.7:\n        if random.random() < 0.5:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n        else:\n            segment = new_solution[start:end]\n            k = random.randint(1, len(segment)-1)\n            new_solution[start:end] = np.concatenate([segment[k:], segment[:k]])\n\n    # Probabilistic node swaps\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9094330074081381,
            1.4278078079223633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]) for x in archive])\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.argmax(scores)\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(4, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Adaptive segment operation\n    if random.random() < 0.7:\n        if random.random() < 0.5:\n            new_solution[start:end] = np.flip(new_solution[start:end])\n        else:\n            segment = new_solution[start:end]\n            k = random.randint(1, len(segment)-1)\n            new_solution[start:end] = np.concatenate([segment[k:], segment[:k]])\n\n    # Probabilistic node swaps\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a Pareto front dominance score and applies a hybrid operator combining segment inversion with adaptive node swapping to generate diverse neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid operator: adaptive segment inversion with node swapping\n    segment_size = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with higher probability for larger segments\n    if random.random() < segment_size / (n / 2):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive node swapping based on distance matrices\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9364381344180299,
            1.4293407797813416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid operator: adaptive segment inversion with node swapping\n    segment_size = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with higher probability for larger segments\n    if random.random() < segment_size / (n / 2):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive node swapping based on distance matrices\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{An algorithm that selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search operator combining segment inversion, rotation, and adaptive node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Segment inversion with adaptive probability\n    if random.random() < (segment_size / n):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive node swaps\n    if random.random() < 0.4:\n        num_swaps = random.randint(1, min(3, n // 4))\n        for _ in range(num_swaps):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotation\n    if random.random() < 0.5:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping conflicting nodes\n        duplicates = np.unique(new_solution, return_counts=True)[1] > 1\n        conflicting = np.where(duplicates[new_solution])[0]\n        for i in conflicting:\n            j = np.where(new_solution == new_solution[i])[0][1]\n            k = random.choice(range(n))\n            while k in conflicting or new_solution[k] == new_solution[i]:\n                k = random.choice(range(n))\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6755598026843251,
            1.1687909960746765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Segment inversion with adaptive probability\n    if random.random() < (segment_size / n):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive node swaps\n    if random.random() < 0.4:\n        num_swaps = random.randint(1, min(3, n // 4))\n        for _ in range(num_swaps):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment rotation\n    if random.random() < 0.5:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping conflicting nodes\n        duplicates = np.unique(new_solution, return_counts=True)[1] > 1\n        conflicting = np.where(duplicates[new_solution])[0]\n        for i in conflicting:\n            j = np.where(new_solution == new_solution[i])[0][1]\n            k = random.choice(range(n))\n            while k in conflicting or new_solution[k] == new_solution[i]:\n                k = random.choice(range(n))\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{A novel approach that combines a biased random walk with a dynamic edge insertion strategy to explore the solution space while maintaining feasibility by ensuring no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic edge insertion strategy\n    i = random.randint(1, n-2)\n    j = random.randint(1, n-2)\n    while j == i or j == i+1 or j == i-1:\n        j = random.randint(1, n-2)\n\n    # Insert node at position j after position i\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Biased random walk: move to a nearby position with probability\n    if random.random() < 0.3:\n        k = random.choice([i-1, i+1])\n        if 0 < k < n-1:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9130076643701621,
            0.1416257619857788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic edge insertion strategy\n    i = random.randint(1, n-2)\n    j = random.randint(1, n-2)\n    while j == i or j == i+1 or j == i-1:\n        j = random.randint(1, n-2)\n\n    # Insert node at position j after position i\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Biased random walk: move to a nearby position with probability\n    if random.random() < 0.3:\n        k = random.choice([i-1, i+1])\n        if 0 < k < n-1:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge insertion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select a node to insert elsewhere\n    node_to_move = random.choice(new_solution[1:-1])\n    idx = np.where(new_solution == node_to_move)[0][0]\n    new_solution = np.delete(new_solution, idx)\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    return new_solution\n\n",
        "score": [
            -0.8363879008807479,
            0.21460235118865967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge insertion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Randomly select a node to insert elsewhere\n    node_to_move = random.choice(new_solution[1:-1])\n    idx = np.where(new_solution == node_to_move)[0][0]\n    new_solution = np.delete(new_solution, idx)\n    insert_pos = random.randint(1, n-1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment reversal\n        c, d = sorted(random.sample(range(1, n-1), 2))\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective ranking, then applies a novel adaptive segment relocation operator that dynamically adjusts segment sizes and positions to explore the solution space more effectively, while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] > x[1][0] and y[1][1] > x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment relocation\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Relocate segment to a new position\n    new_pos = random.randint(1, n - segment_size)\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Insert at new position\n    if new_pos < start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic repair if infeasible\n    if len(np.unique(new_solution)) != n or new_pos >= len(new_solution):\n        # Apply a simple but effective repair\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8978823822933468,
            1.2697712779045105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] > x[1][0] and y[1][1] > x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment relocation\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Relocate segment to a new position\n    new_pos = random.randint(1, n - segment_size)\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Insert at new position\n    if new_pos < start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Probabilistic repair if infeasible\n    if len(np.unique(new_solution)) != n or new_pos >= len(new_solution):\n        # Apply a simple but effective repair\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects the solution with the best combined objective value from the archive, then applies a novel hybrid local search that combines a multi-segment inversion with an adaptive edge-reconnection strategy, ensuring feasibility by maintaining a valid TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive step sizes\n    num_segments = random.randint(2, min(5, n // 3))\n    segment_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = [0] + segment_points + [n]\n\n    for i in range(len(segments) - 1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.7:  # Invert with 70% probability\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive edge reconnection\n    for _ in range(random.randint(1, 3)):\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        if a != c and b != d:\n            # Cross-swap edges to reconnect segments\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by repairing the tour structure\n        visited = set()\n        repaired = []\n        for node in new_solution:\n            if node not in visited:\n                visited.add(node)\n                repaired.append(node)\n        # Pad with missing nodes if needed\n        missing = [node for node in range(n) if node not in visited]\n        repaired.extend(missing)\n        new_solution = np.array(repaired)\n\n    return new_solution\n\n",
        "score": [
            -0.8177019854730276,
            0.20687103271484375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with adaptive step sizes\n    num_segments = random.randint(2, min(5, n // 3))\n    segment_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = [0] + segment_points + [n]\n\n    for i in range(len(segments) - 1):\n        start, end = segments[i], segments[i+1]\n        if random.random() < 0.7:  # Invert with 70% probability\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive edge reconnection\n    for _ in range(random.randint(1, 3)):\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n        if a != c and b != d:\n            # Cross-swap edges to reconnect segments\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by repairing the tour structure\n        visited = set()\n        repaired = []\n        for node in new_solution:\n            if node not in visited:\n                visited.add(node)\n                repaired.append(node)\n        # Pad with missing nodes if needed\n        missing = [node for node in range(n) if node not in visited]\n        repaired.extend(missing)\n        new_solution = np.array(repaired)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a normalized objective score weighted by non-dominated solutions and their diversity, then applies a multi-segment inversion with dynamic segment sizes and adaptive rotation probabilities to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(x[1][0] for x in archive)\n    max_obj1 = max(x[1][0] for x in archive)\n    min_obj2 = min(x[1][1] for x in archive)\n    max_obj2 = max(x[1][1] for x in archive)\n\n    def score(sol):\n        obj1_norm = (sol[1][0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        obj2_norm = (sol[1][1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        nd_count = sum(1 for y in archive if y[1][0] <= sol[1][0] and y[1][1] <= sol[1][1])\n        return (0.6 * obj1_norm + 0.4 * obj2_norm) * (1 + nd_count)\n\n    selected_solution = max(archive, key=score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion with dynamic sizes\n    num_segments = random.randint(1, min(3, n // 5))\n    for _ in range(num_segments):\n        segment_size = max(2, min(7, random.randint(1, n // 3)))\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        if random.random() < (segment_size / (n // 2)):\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive rotation with probability based on segment size\n    if random.random() < 0.4:\n        rotate_size = random.randint(1, min(5, n // 4))\n        start_pos = random.randint(1, n - rotate_size)\n        segment = new_solution[start_pos:start_pos+rotate_size]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            segment[1:],\n            segment[0:1],\n            new_solution[start_pos+rotate_size:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9228065316775187,
            1.5653839707374573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(x[1][0] for x in archive)\n    max_obj1 = max(x[1][0] for x in archive)\n    min_obj2 = min(x[1][1] for x in archive)\n    max_obj2 = max(x[1][1] for x in archive)\n\n    def score(sol):\n        obj1_norm = (sol[1][0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        obj2_norm = (sol[1][1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        nd_count = sum(1 for y in archive if y[1][0] <= sol[1][0] and y[1][1] <= sol[1][1])\n        return (0.6 * obj1_norm + 0.4 * obj2_norm) * (1 + nd_count)\n\n    selected_solution = max(archive, key=score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment inversion with dynamic sizes\n    num_segments = random.randint(1, min(3, n // 5))\n    for _ in range(num_segments):\n        segment_size = max(2, min(7, random.randint(1, n // 3)))\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        if random.random() < (segment_size / (n // 2)):\n            new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive rotation with probability based on segment size\n    if random.random() < 0.4:\n        rotate_size = random.randint(1, min(5, n // 4))\n        start_pos = random.randint(1, n - rotate_size)\n        segment = new_solution[start_pos:start_pos+rotate_size]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            segment[1:],\n            segment[0:1],\n            new_solution[start_pos+rotate_size:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects the best solution from the archive based on a combined objective score, then applies a novel hybrid local search that combines segment reversal with a probabilistic edge swap to generate diverse neighbors while ensuring feasibility through validation and fallback to a simpler move if needed.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments for reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Probabilistic edge swap for diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.888406975378907,
            0.23633891344070435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments for reversal\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Probabilistic edge swap for diversity\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and solution quality, then applies a hybrid local search combining a novel segment relocation with adaptive edge reordering to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment relocation with adaptive size\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Relocate segment to a new position\n    new_pos = random.randint(1, n - segment_size)\n    segment = new_solution[start:end].copy()\n\n    if new_pos < start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n    else:\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive edge reordering based on distance matrices\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        # Reorder edges based on combined distance improvement\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost += distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost += distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9717166026332735,
            1.4123429656028748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel segment relocation with adaptive size\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Relocate segment to a new position\n    new_pos = random.randint(1, n - segment_size)\n    segment = new_solution[start:end].copy()\n\n    if new_pos < start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start], new_solution[end:]])\n    else:\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive edge reordering based on distance matrices\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        # Reorder edges based on combined distance improvement\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost += distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost += distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a non-dominated sorting approach, then applies a hybrid local search operator combining edge insertion and adaptive segment rotation to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Edge insertion\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n    else:\n        # Adaptive segment rotation\n        segment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(1, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotated_segment = np.roll(segment, random.randint(1, segment_size-1))\n        new_solution = np.concatenate([new_solution[:start], rotated_segment, new_solution[start+segment_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8253579467774278,
            0.25580066442489624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_solution = archive[0][0].copy()\n    else:\n        selected_solution = random.choice(non_dominated)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.5:\n        # Edge insertion\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n    else:\n        # Adaptive segment rotation\n        segment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(1, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotated_segment = np.roll(segment, random.randint(1, segment_size-1))\n        new_solution = np.concatenate([new_solution[:start], rotated_segment, new_solution[start+segment_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and swap them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8566877919038238,
            0.21239697933197021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and swap them\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{An algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines segment inversion with a novel adaptive node reinsertion strategy to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion with dynamic size\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    if random.random() < 0.7:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Novel adaptive node reinsertion\n    if random.random() < 0.5:\n        reinsert_pos = random.randint(0, n - 1)\n        reinsert_node = new_solution[reinsert_pos]\n        new_solution = np.delete(new_solution, reinsert_pos)\n        new_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, new_pos, reinsert_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0132961077072467,
            1.5470151901245117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment inversion with dynamic size\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    if random.random() < 0.7:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Novel adaptive node reinsertion\n    if random.random() < 0.5:\n        reinsert_pos = random.randint(0, n - 1)\n        reinsert_node = new_solution[reinsert_pos]\n        new_solution = np.delete(new_solution, reinsert_pos)\n        new_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, new_pos, reinsert_node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes based on distance improvement\n        i, j = random.sample(range(n), 2)\n        if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] <\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on non-dominated sorting and crowding distance, then applies a hybrid of segment reversal and node insertion with adaptive segment sizes and insertion points to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]:\n                if archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1]:\n                    dominating_sets[i].append(j)\n            elif archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1]:\n                dominated_count[i] += 1\n\n        if dominated_count[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while len(fronts[current_front]) > 0:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_count[j] -= 1\n                if dominated_count[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first front with highest crowding distance\n    if len(fronts[0]) > 1:\n        objectives = [archive[i][1] for i in fronts[0]]\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n        crowding_distances = [0.0] * len(fronts[0])\n        for i in range(len(fronts[0])):\n            if i == 0 or i == len(fronts[0]) - 1:\n                crowding_distances[i] = float('inf')\n            else:\n                crowding_distances[i] = (sorted_obj1[i+1][0] - sorted_obj1[i-1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0]) + \\\n                                      (sorted_obj2[i+1][1] - sorted_obj2[i-1][1]) / (sorted_obj2[-1][1] - sorted_obj2[0])\n\n        selected_index = fronts[0][np.argmax(crowding_distances)]\n    else:\n        selected_index = fronts[0][0]\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Segment reversal with probability\n    if random.random() < 0.5:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Node insertion with probability\n    if random.random() < 0.3:\n        node_to_insert = new_solution[random.randint(0, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(0, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9139973456795881,
            5.078760921955109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]:\n                if archive[i][1][0] < archive[j][1][0] or archive[i][1][1] < archive[j][1][1]:\n                    dominating_sets[i].append(j)\n            elif archive[j][1][0] <= archive[i][1][0] and archive[j][1][1] <= archive[i][1][1]:\n                dominated_count[i] += 1\n\n        if dominated_count[i] == 0:\n            fronts.append([i])\n\n    current_front = 0\n    while len(fronts[current_front]) > 0:\n        next_front = []\n        for i in fronts[current_front]:\n            for j in dominating_sets[i]:\n                dominated_count[j] -= 1\n                if dominated_count[j] == 0:\n                    next_front.append(j)\n        current_front += 1\n        fronts.append(next_front)\n\n    # Select from the first front with highest crowding distance\n    if len(fronts[0]) > 1:\n        objectives = [archive[i][1] for i in fronts[0]]\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n        crowding_distances = [0.0] * len(fronts[0])\n        for i in range(len(fronts[0])):\n            if i == 0 or i == len(fronts[0]) - 1:\n                crowding_distances[i] = float('inf')\n            else:\n                crowding_distances[i] = (sorted_obj1[i+1][0] - sorted_obj1[i-1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0]) + \\\n                                      (sorted_obj2[i+1][1] - sorted_obj2[i-1][1]) / (sorted_obj2[-1][1] - sorted_obj2[0])\n\n        selected_index = fronts[0][np.argmax(crowding_distances)]\n    else:\n        selected_index = fronts[0][0]\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Segment reversal with probability\n    if random.random() < 0.5:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Node insertion with probability\n    if random.random() < 0.3:\n        node_to_insert = new_solution[random.randint(0, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(0, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to remove and invert\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    segment = np.flip(segment)\n\n    # Remove the segment and insert it at a new random position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(1, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment inversion\n        new_solution = selected_solution.copy()\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.9519210098639119,
            0.196672260761261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to remove and invert\n    a, b = sorted(random.sample(range(1, n), 2))\n    segment = new_solution[a:b]\n    segment = np.flip(segment)\n\n    # Remove the segment and insert it at a new random position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(1, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler segment inversion\n        new_solution = selected_solution.copy()\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes solutions with better balance between objectives and higher diversity, then applies a hybrid local search operator combining segment inversion, rotation, and adaptive swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(x[1][0] for x in archive)\n    max_obj1 = max(x[1][0] for x in archive)\n    min_obj2 = min(x[1][1] for x in archive)\n    max_obj2 = max(x[1][1] for x in archive)\n\n    def score(x):\n        norm_obj1 = (x[1][0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (x[1][1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        diversity = sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])\n        return (0.6 * norm_obj1 + 0.4 * norm_obj2) * (1 + diversity)\n\n    selected_solution = max(archive, key=score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment operation\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Hybrid operations\n    if random.random() < 0.7:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n    elif random.random() < 0.4:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n    else:\n        i, j = random.sample(range(start, end), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8695707759867339,
            1.465941309928894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    min_obj1 = min(x[1][0] for x in archive)\n    max_obj1 = max(x[1][0] for x in archive)\n    min_obj2 = min(x[1][1] for x in archive)\n    max_obj2 = max(x[1][1] for x in archive)\n\n    def score(x):\n        norm_obj1 = (x[1][0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (x[1][1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        diversity = sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])\n        return (0.6 * norm_obj1 + 0.4 * norm_obj2) * (1 + diversity)\n\n    selected_solution = max(archive, key=score)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment operation\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Hybrid operations\n    if random.random() < 0.7:\n        new_solution[start:end] = np.flip(new_solution[start:end])\n    elif random.random() < 0.4:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n    else:\n        i, j = random.sample(range(start, end), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2) * 0.5)[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to swap (avoiding trivial cases)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    d, e, f = sorted(random.sample(range(1, n), 3))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n    new_solution[e:f] = np.flip(new_solution[e:f])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.934979935835586,
            0.2281009554862976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_cost1 = max(obj[0] for _, obj in archive)\n    max_cost2 = max(obj[1] for _, obj in archive)\n    selected_solution = max(archive, key=lambda x: (x[1][0]/max_cost1 + x[1][1]/max_cost2) * 0.5)[0].copy()\n\n    # Hybrid local search: Combine segment reversal with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to swap (avoiding trivial cases)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    d, e, f = sorted(random.sample(range(1, n), 3))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n    new_solution[e:f] = np.flip(new_solution[e:f])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining a novel path-splicing operator with an adaptive node-swapping strategy to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path-splicing operator\n    if random.random() < 0.7:\n        splice_points = sorted(random.sample(range(1, n), 2))\n        a, b = splice_points\n        # Extract segments and recombine with a twist\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Adaptive node-swapping strategy\n    if random.random() < 0.5:\n        # Select swap positions based on distance in both objectives\n        i = random.randint(1, n-1)\n        j = (i + random.randint(1, min(5, n//2))) % n\n        # Calculate combined distance improvement\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by rotating a random segment\n        start = random.randint(1, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[end:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9574300394664365,
            1.4810014963150024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path-splicing operator\n    if random.random() < 0.7:\n        splice_points = sorted(random.sample(range(1, n), 2))\n        a, b = splice_points\n        # Extract segments and recombine with a twist\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Adaptive node-swapping strategy\n    if random.random() < 0.5:\n        # Select swap positions based on distance in both objectives\n        i = random.randint(1, n-1)\n        j = (i + random.randint(1, min(5, n//2))) % n\n        # Calculate combined distance improvement\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by rotating a random segment\n        start = random.randint(1, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[end:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on edge cost in both objectives\n    def edge_cost(a, b):\n        return distance_matrix_1[a, b] + distance_matrix_2[a, b]\n\n    # Find three high-cost edges to optimize\n    edges = [(i, selected_solution[i], selected_solution[(i+1)%n]) for i in range(n)]\n    edges.sort(key=lambda x: -edge_cost(x[1], x[2]))\n    i1, i2, i3 = edges[0][0], edges[1][0], edges[2][0]\n\n    # Apply 3-opt move: reconnect three edges in a new configuration\n    if i1 < i2 < i3:\n        new_solution[i1:i2+1] = np.flip(new_solution[i1:i2+1])\n        new_solution[i2:i3+1] = np.flip(new_solution[i2:i3+1])\n    elif i1 < i3 < i2:\n        new_solution[i1:i3+1] = np.flip(new_solution[i1:i3+1])\n        new_solution[i3:i2+1] = np.flip(new_solution[i3:i2+1])\n    else:\n        new_solution[i3:i2+1] = np.flip(new_solution[i3:i2+1])\n        new_solution[i1:i3+1] = np.flip(new_solution[i1:i3+1])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler 2-opt move\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.9348055388755578,
            0.21203243732452393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment selection based on edge cost in both objectives\n    def edge_cost(a, b):\n        return distance_matrix_1[a, b] + distance_matrix_2[a, b]\n\n    # Find three high-cost edges to optimize\n    edges = [(i, selected_solution[i], selected_solution[(i+1)%n]) for i in range(n)]\n    edges.sort(key=lambda x: -edge_cost(x[1], x[2]))\n    i1, i2, i3 = edges[0][0], edges[1][0], edges[2][0]\n\n    # Apply 3-opt move: reconnect three edges in a new configuration\n    if i1 < i2 < i3:\n        new_solution[i1:i2+1] = np.flip(new_solution[i1:i2+1])\n        new_solution[i2:i3+1] = np.flip(new_solution[i2:i3+1])\n    elif i1 < i3 < i2:\n        new_solution[i1:i3+1] = np.flip(new_solution[i1:i3+1])\n        new_solution[i3:i2+1] = np.flip(new_solution[i3:i2+1])\n    else:\n        new_solution[i3:i2+1] = np.flip(new_solution[i3:i2+1])\n        new_solution[i1:i3+1] = np.flip(new_solution[i1:i3+1])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, apply a simpler 2-opt move\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[:5]\n    selected = random.choice(top_solutions)[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Adaptive crossover: randomly select segments from top solutions\n    for _ in range(random.randint(1, 3)):\n        donor = random.choice(top_solutions)[0]\n        a, b = sorted(random.sample(range(1, n), 2))\n\n        # Extract segment and insert while preserving order\n        segment = donor[a:b]\n        mask = np.isin(new_solution, segment, invert=True)\n        remaining = new_solution[mask]\n        new_solution = np.concatenate([remaining[:a], segment, remaining[a:]])\n\n    # Dynamic repair: ensure no duplicates and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a greedy repair\n        missing = set(range(n)) - set(new_solution)\n        for i in range(n):\n            if new_solution[i] not in range(n) or new_solution[i] in new_solution[:i]:\n                new_solution[i] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.9362741543404053,
            3.065193772315979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[:5]\n    selected = random.choice(top_solutions)[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Adaptive crossover: randomly select segments from top solutions\n    for _ in range(random.randint(1, 3)):\n        donor = random.choice(top_solutions)[0]\n        a, b = sorted(random.sample(range(1, n), 2))\n\n        # Extract segment and insert while preserving order\n        segment = donor[a:b]\n        mask = np.isin(new_solution, segment, invert=True)\n        remaining = new_solution[mask]\n        new_solution = np.concatenate([remaining[:a], segment, remaining[a:]])\n\n    # Dynamic repair: ensure no duplicates and fix if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a greedy repair\n        missing = set(range(n)) - set(new_solution)\n        for i in range(n):\n            if new_solution[i] not in range(n) or new_solution[i] in new_solution[:i]:\n                new_solution[i] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a hybrid of objective dominance and local search potential, then applies a dynamic k-opt operator with adaptive segment sizes and probabilistic edge swaps to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic k-opt with adaptive segment sizes\n    k = random.randint(2, min(5, n // 3))\n    segments = sorted(random.sample(range(1, n), k-1))\n\n    # Create segments and shuffle their order\n    segments = [0] + segments + [n]\n    segment_indices = list(range(len(segments)-1))\n    random.shuffle(segment_indices)\n\n    # Reconstruct solution with shuffled segments\n    temp_solution = []\n    for i in segment_indices:\n        start, end = segments[i], segments[i+1]\n        temp_solution.extend(new_solution[start:end])\n\n    new_solution = np.array(temp_solution)\n\n    # Probabilistic edge swaps based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if j < i:\n            i, j = j, i\n\n        # Calculate current and swapped distances\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        swapped_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (swapped_dist1 < current_dist1) or (swapped_dist2 < current_dist2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9472990173676933,
            1.4608193039894104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic k-opt with adaptive segment sizes\n    k = random.randint(2, min(5, n // 3))\n    segments = sorted(random.sample(range(1, n), k-1))\n\n    # Create segments and shuffle their order\n    segments = [0] + segments + [n]\n    segment_indices = list(range(len(segments)-1))\n    random.shuffle(segment_indices)\n\n    # Reconstruct solution with shuffled segments\n    temp_solution = []\n    for i in segment_indices:\n        start, end = segments[i], segments[i+1]\n        temp_solution.extend(new_solution[start:end])\n\n    new_solution = np.array(temp_solution)\n\n    # Probabilistic edge swaps based on distance improvement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if j < i:\n            i, j = j, i\n\n        # Calculate current and swapped distances\n        current_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        swapped_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        current_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (swapped_dist1 < current_dist1) or (swapped_dist2 < current_dist2):\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects the first solution from the archive and generates a neighbor by swapping the first two nodes, then applies a novel local search strategy that combines segment reversal with edge swapping to improve both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Initial swap of first two nodes\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    # Novel local search: segment reversal with edge optimization\n    n = len(new_solution)\n    if n > 3:\n        # Select two random segments and reverse them\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n        # Edge optimization: swap edges if it improves both objectives\n        for i in range(1, n-2):\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n\n            # Try swapping edges\n            temp = new_solution[i]\n            new_solution[i] = new_solution[i+1]\n            new_solution[i+1] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n\n            if new_cost1 >= current_cost1 or new_cost2 >= current_cost2:\n                # Revert if not improving both objectives\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7710786258521376,
            0.23759490251541138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Initial swap of first two nodes\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    # Novel local search: segment reversal with edge optimization\n    n = len(new_solution)\n    if n > 3:\n        # Select two random segments and reverse them\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n        # Edge optimization: swap edges if it improves both objectives\n        for i in range(1, n-2):\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n\n            # Try swapping edges\n            temp = new_solution[i]\n            new_solution[i] = new_solution[i+1]\n            new_solution[i+1] = temp\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i+1], new_solution[i+2]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i+1], new_solution[i+2]]\n\n            if new_cost1 >= current_cost1 or new_cost2 >= current_cost2:\n                # Revert if not improving both objectives\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator combining segment rotation with adaptive node insertion to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, random.randint(1, n // 3)))\n\n    # Hybrid local search: segment rotation with adaptive node insertion\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Rotate segment\n    rotate_pos = random.randint(1, segment_size - 1)\n    segment = new_solution[start:end]\n    rotated = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end] = rotated\n\n    # Adaptive node insertion\n    if random.random() < 0.4:\n        node1, node2 = random.sample(range(1, n), 2)\n        pos1, pos2 = new_solution.tolist().index(node1), new_solution.tolist().index(node2)\n        if pos1 < pos2:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8514882094934026,
            1.3571537733078003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, random.randint(1, n // 3)))\n\n    # Hybrid local search: segment rotation with adaptive node insertion\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Rotate segment\n    rotate_pos = random.randint(1, segment_size - 1)\n    segment = new_solution[start:end]\n    rotated = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[start:end] = rotated\n\n    # Adaptive node insertion\n    if random.random() < 0.4:\n        node1, node2 = random.sample(range(1, n), 2)\n        pos1, pos2 = new_solution.tolist().index(node1), new_solution.tolist().index(node2)\n        if pos1 < pos2:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.036417945356567,
            0.2145974040031433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.036417945356567,
            0.2145974040031433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a Pareto-frontier dominance score and a diversity bonus, then applies a dynamic segment rotation and inversion operator with adaptive segment sizes and probabilities to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solution with highest dominance count (most dominated) with diversity bonus\n    selected_idx = max(range(len(archive)), key=lambda i: dominance_counts[i] * (1 + sum(1 for j in range(len(archive)) if archive[j][1][0] < archive[i][1][0] and archive[j][1][1] < archive[i][1][1])))\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment rotation and inversion with adaptive parameters\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Segment rotation with probability based on segment size\n    if random.random() < (segment_size / (n // 1.5)):\n        rotate_amount = random.randint(1, segment_size - 1)\n        segment = new_solution[start:end]\n        new_solution[start:end] = np.roll(segment, rotate_amount)\n\n    # Segment inversion with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: swap two nodes with probability based on segment size\n    if random.random() < (segment_size / n):\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9500802164785728,
            3.0917874574661255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominance_counts = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        count = 0\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                count += 1\n        dominance_counts.append(count)\n\n    # Select solution with highest dominance count (most dominated) with diversity bonus\n    selected_idx = max(range(len(archive)), key=lambda i: dominance_counts[i] * (1 + sum(1 for j in range(len(archive)) if archive[j][1][0] < archive[i][1][0] and archive[j][1][1] < archive[i][1][1])))\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment rotation and inversion with adaptive parameters\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Segment rotation with probability based on segment size\n    if random.random() < (segment_size / (n // 1.5)):\n        rotate_amount = random.randint(1, segment_size - 1)\n        segment = new_solution[start:end]\n        new_solution[start:end] = np.roll(segment, rotate_amount)\n\n    # Segment inversion with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: swap two nodes with probability based on segment size\n    if random.random() < (segment_size / n):\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a non-linear combination of objectives and local improvement potential, then applies a hybrid segment rotation and insertion operator with dynamic segment sizes to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol):\n        obj1, obj2 = sol[1]\n        # Non-linear combination with emphasis on balanced solutions\n        combined = (obj1 * obj2) / (obj1 + obj2 + 1e-6)\n        # Add local improvement potential (difference between current and average objectives)\n        avg_obj1 = sum(x[1][0] for x in archive) / len(archive)\n        avg_obj2 = sum(x[1][1] for x in archive) / len(archive)\n        improvement_potential = (avg_obj1 - obj1) * 0.6 + (avg_obj2 - obj2) * 0.4\n        return combined * (1 + improvement_potential)\n\n    selected_solution = max(archive, key=lambda x: score(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment rotation and insertion\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Rotate segment with higher probability\n    if random.random() < 0.7:\n        k = random.randint(1, segment_size - 1)\n        segment = new_solution[start:end]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[start:end] = rotated\n\n    # Adaptive insertion of a different segment\n    if random.random() < 0.5:\n        insert_pos = random.randint(1, n - 1)\n        insert_size = random.randint(2, min(5, n // 4))\n        insert_start = random.randint(1, n - insert_size)\n        insert_segment = new_solution[insert_start:insert_start+insert_size]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            insert_segment,\n            new_solution[insert_pos:]\n        ])\n        # Remove duplicates by replacing them with missing nodes\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(len(new_solution)):\n            if new_solution[i] in unique_nodes:\n                continue\n            if len(missing_nodes) > 0:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes with high distance in both objectives\n        i = random.randint(1, n - 1)\n        j = np.argmax(distance_matrix_1[new_solution[i], new_solution] +\n                     distance_matrix_2[new_solution[i], new_solution])\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8610332813060659,
            4.037806928157806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol):\n        obj1, obj2 = sol[1]\n        # Non-linear combination with emphasis on balanced solutions\n        combined = (obj1 * obj2) / (obj1 + obj2 + 1e-6)\n        # Add local improvement potential (difference between current and average objectives)\n        avg_obj1 = sum(x[1][0] for x in archive) / len(archive)\n        avg_obj2 = sum(x[1][1] for x in archive) / len(archive)\n        improvement_potential = (avg_obj1 - obj1) * 0.6 + (avg_obj2 - obj2) * 0.4\n        return combined * (1 + improvement_potential)\n\n    selected_solution = max(archive, key=lambda x: score(x))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment rotation and insertion\n    segment_size = max(2, min(7, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Rotate segment with higher probability\n    if random.random() < 0.7:\n        k = random.randint(1, segment_size - 1)\n        segment = new_solution[start:end]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        new_solution[start:end] = rotated\n\n    # Adaptive insertion of a different segment\n    if random.random() < 0.5:\n        insert_pos = random.randint(1, n - 1)\n        insert_size = random.randint(2, min(5, n // 4))\n        insert_start = random.randint(1, n - insert_size)\n        insert_segment = new_solution[insert_start:insert_start+insert_size]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            insert_segment,\n            new_solution[insert_pos:]\n        ])\n        # Remove duplicates by replacing them with missing nodes\n        unique_nodes = np.unique(new_solution)\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(len(new_solution)):\n            if new_solution[i] in unique_nodes:\n                continue\n            if len(missing_nodes) > 0:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping nodes with high distance in both objectives\n        i = random.randint(1, n - 1)\n        j = np.argmax(distance_matrix_1[new_solution[i], new_solution] +\n                     distance_matrix_2[new_solution[i], new_solution])\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a dynamic combination of objectives and spatial properties, then applies a hybrid local search operator combining adaptive segment rotation with a novel node insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5] if random.random() < 0.5 else [0.3, 0.7]\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) *\n                          (1 + np.mean([distance_matrix_1[x[0][i]][x[0][i+1]] + distance_matrix_2[x[0][i]][x[0][i+1]] for i in range(len(x[0])-1)])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment rotation\n    segment_size = random.randint(2, min(6, n // 3))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n\n    new_solution[start:end] = rotated_segment\n\n    # Novel node insertion strategy\n    if random.random() < 0.4:\n        # Select a node to relocate\n        node_pos = random.randint(1, n - 1)\n        node = new_solution[node_pos]\n\n        # Find insertion position based on spatial proximity in both objectives\n        candidate_positions = []\n        for i in range(1, n):\n            if i != node_pos:\n                dist1 = distance_matrix_1[new_solution[i-1]][node] + distance_matrix_1[node][new_solution[i]]\n                dist2 = distance_matrix_2[new_solution[i-1]][node] + distance_matrix_2[node][new_solution[i]]\n                candidate_positions.append((i, dist1 + dist2))\n\n        if candidate_positions:\n            best_pos = min(candidate_positions, key=lambda x: x[1])[0]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9085693979942467,
            2.5964237451553345
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.5, 0.5] if random.random() < 0.5 else [0.3, 0.7]\n    selected_solution = max(archive, key=lambda x: (weights[0] * x[1][0] + weights[1] * x[1][1]) *\n                          (1 + np.mean([distance_matrix_1[x[0][i]][x[0][i+1]] + distance_matrix_2[x[0][i]][x[0][i+1]] for i in range(len(x[0])-1)])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment rotation\n    segment_size = random.randint(2, min(6, n // 3))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, rotation)\n\n    new_solution[start:end] = rotated_segment\n\n    # Novel node insertion strategy\n    if random.random() < 0.4:\n        # Select a node to relocate\n        node_pos = random.randint(1, n - 1)\n        node = new_solution[node_pos]\n\n        # Find insertion position based on spatial proximity in both objectives\n        candidate_positions = []\n        for i in range(1, n):\n            if i != node_pos:\n                dist1 = distance_matrix_1[new_solution[i-1]][node] + distance_matrix_1[node][new_solution[i]]\n                dist2 = distance_matrix_2[new_solution[i-1]][node] + distance_matrix_2[node][new_solution[i]]\n                candidate_positions.append((i, dist1 + dist2))\n\n        if candidate_positions:\n            best_pos = min(candidate_positions, key=lambda x: x[1])[0]\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel path recombination operator that combines segments from multiple solutions to generate a high-quality neighbor, while ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by first objective\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        crowding_distances = {sol[0].tobytes(): 0 for sol in archive}\n\n        # Calculate crowding distances\n        for obj_idx in range(2):\n            sorted_archive = sorted(archive, key=lambda x: x[1][obj_idx])\n            min_val = sorted_archive[0][1][obj_idx]\n            max_val = sorted_archive[-1][1][obj_idx]\n\n            if max_val == min_val:\n                continue\n\n            crowding_distances[sorted_archive[0][0].tobytes()] = float('inf')\n            crowding_distances[sorted_archive[-1][0].tobytes()] = float('inf')\n\n            for i in range(1, len(sorted_archive)-1):\n                dist = (sorted_archive[i+1][1][obj_idx] - sorted_archive[i-1][1][obj_idx]) / (max_val - min_val)\n                crowding_distances[sorted_archive[i][0].tobytes()] += dist\n\n        # Select solution with minimum crowding distance (most under-explored)\n        selected_solution = min(archive, key=lambda x: crowding_distances[x[0].tobytes()])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path recombination operator\n    if len(archive) > 1:\n        # Select another random solution from archive\n        other_solution = random.choice([sol for sol in archive if not np.array_equal(sol[0], selected_solution)])[0]\n\n        # Find common segments between solutions\n        common_segments = []\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = selected_solution[i:j+1]\n                seg2 = other_solution[i:j+1]\n                if np.array_equal(seg1, seg2):\n                    common_segments.append((i, j))\n\n        if common_segments:\n            # Select a random common segment to preserve\n            start, end = random.choice(common_segments)\n            preserved_segment = selected_solution[start:end+1]\n\n            # Reconstruct solution by alternating between preserved and new segments\n            new_solution = np.zeros_like(selected_solution)\n            new_solution[start:end+1] = preserved_segment\n\n            # Fill remaining positions with nodes from other solution\n            remaining_nodes = [node for node in other_solution if node not in preserved_segment]\n            pos = 0\n            for i in range(n):\n                if i < start or i > end:\n                    new_solution[i] = remaining_nodes[pos]\n                    pos += 1\n        else:\n            # If no common segments, perform a probabilistic segment swap\n            swap_size = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - swap_size)\n            end = start + swap_size\n\n            if random.random() < 0.7:  # Higher probability for larger segments\n                # Swap segments with another random solution\n                other_solution = random.choice([sol for sol in archive if not np.array_equal(sol[0], selected_solution)])[0]\n                new_solution[start:end] = other_solution[start:end]\n\n    # Ensure feasibility with probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        # Fix by inserting missing nodes at random positions\n        missing_nodes = [node for node in range(n) if node not in new_solution]\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n",
        "score": [
            -0.922147463286423,
            1.2540271878242493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by first objective\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        crowding_distances = {sol[0].tobytes(): 0 for sol in archive}\n\n        # Calculate crowding distances\n        for obj_idx in range(2):\n            sorted_archive = sorted(archive, key=lambda x: x[1][obj_idx])\n            min_val = sorted_archive[0][1][obj_idx]\n            max_val = sorted_archive[-1][1][obj_idx]\n\n            if max_val == min_val:\n                continue\n\n            crowding_distances[sorted_archive[0][0].tobytes()] = float('inf')\n            crowding_distances[sorted_archive[-1][0].tobytes()] = float('inf')\n\n            for i in range(1, len(sorted_archive)-1):\n                dist = (sorted_archive[i+1][1][obj_idx] - sorted_archive[i-1][1][obj_idx]) / (max_val - min_val)\n                crowding_distances[sorted_archive[i][0].tobytes()] += dist\n\n        # Select solution with minimum crowding distance (most under-explored)\n        selected_solution = min(archive, key=lambda x: crowding_distances[x[0].tobytes()])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel path recombination operator\n    if len(archive) > 1:\n        # Select another random solution from archive\n        other_solution = random.choice([sol for sol in archive if not np.array_equal(sol[0], selected_solution)])[0]\n\n        # Find common segments between solutions\n        common_segments = []\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = selected_solution[i:j+1]\n                seg2 = other_solution[i:j+1]\n                if np.array_equal(seg1, seg2):\n                    common_segments.append((i, j))\n\n        if common_segments:\n            # Select a random common segment to preserve\n            start, end = random.choice(common_segments)\n            preserved_segment = selected_solution[start:end+1]\n\n            # Reconstruct solution by alternating between preserved and new segments\n            new_solution = np.zeros_like(selected_solution)\n            new_solution[start:end+1] = preserved_segment\n\n            # Fill remaining positions with nodes from other solution\n            remaining_nodes = [node for node in other_solution if node not in preserved_segment]\n            pos = 0\n            for i in range(n):\n                if i < start or i > end:\n                    new_solution[i] = remaining_nodes[pos]\n                    pos += 1\n        else:\n            # If no common segments, perform a probabilistic segment swap\n            swap_size = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - swap_size)\n            end = start + swap_size\n\n            if random.random() < 0.7:  # Higher probability for larger segments\n                # Swap segments with another random solution\n                other_solution = random.choice([sol for sol in archive if not np.array_equal(sol[0], selected_solution)])[0]\n                new_solution[start:end] = other_solution[start:end]\n\n    # Ensure feasibility with probabilistic repair\n    if len(np.unique(new_solution)) != n:\n        # Fix by inserting missing nodes at random positions\n        missing_nodes = [node for node in range(n) if node not in new_solution]\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining both costs and their ratio, then applies a novel \"segment crossover\" operator that combines parts of the selected solution with random segments from other archive solutions while ensuring feasibility through careful merging and conflict resolution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment crossover with another random solution\n    other_solution = random.choice(archive)[0]\n    segment_size = max(2, min(5, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Extract segment from other solution\n    segment = other_solution[start:end]\n\n    # Merge segments while preserving uniqueness\n    merged = np.concatenate([new_solution[:start], segment, new_solution[end:]])\n    unique_nodes = np.unique(merged)\n\n    # If duplicates exist, resolve by replacing duplicates with missing nodes\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(len(merged)):\n            if merged[i] in segment and merged[i] in merged[:i]:\n                merged[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    # Apply probabilistic segment rotation\n    if random.random() < 0.4:\n        rotate_size = random.randint(1, segment_size)\n        segment = merged[start:start+rotate_size]\n        merged = np.concatenate([merged[:start], segment[1:], segment[0:1], merged[start+rotate_size:]])\n\n    return merged\n\n",
        "score": [
            -0.9278309022600578,
            0.5201134085655212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + abs(x[1][0] - x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment crossover with another random solution\n    other_solution = random.choice(archive)[0]\n    segment_size = max(2, min(5, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Extract segment from other solution\n    segment = other_solution[start:end]\n\n    # Merge segments while preserving uniqueness\n    merged = np.concatenate([new_solution[:start], segment, new_solution[end:]])\n    unique_nodes = np.unique(merged)\n\n    # If duplicates exist, resolve by replacing duplicates with missing nodes\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(len(merged)):\n            if merged[i] in segment and merged[i] in merged[:i]:\n                merged[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    # Apply probabilistic segment rotation\n    if random.random() < 0.4:\n        rotate_size = random.randint(1, segment_size)\n        segment = merged[start:start+rotate_size]\n        merged = np.concatenate([merged[:start], segment[1:], segment[0:1], merged[start+rotate_size:]])\n\n    return merged\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{A novel segment-swap and rotation operator that intelligently selects and rotates segments of the tour while maintaining feasibility by ensuring no nodes are skipped or revisited, with additional checks to prevent trivial swaps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to rotate\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Apply a novel rotation: move segment [a:b] to after c, and segment [b:c] to after a\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7488636580375984,
            0.1803244948387146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments to rotate\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Apply a novel rotation: move segment [a:b] to after c, and segment [b:c] to after a\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple segment reversal\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of normalized objective values, then applies a hybrid local search combining 2-opt with a novel edge-swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.7460890852359684,
            0.18420416116714478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel approach that intelligently selects solutions from the archive based on their objective diversity and applies a hybrid local search combining edge reordering with a probabilistic segment inversion strategy to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: probabilistic segment inversion with edge reordering\n    for _ in range(2):  # Apply twice for more exploration\n        a, b = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.7:  # 70% chance to invert segment\n            new_solution[a:b] = np.flip(new_solution[a:b])\n        else:  # 30% chance to reorder edges\n            segment = new_solution[a:b]\n            random.shuffle(segment)\n            new_solution[a:b] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7804913679490548,
            0.20579630136489868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: probabilistic segment inversion with edge reordering\n    for _ in range(2):  # Apply twice for more exploration\n        a, b = sorted(random.sample(range(1, n), 2))\n        if random.random() < 0.7:  # 70% chance to invert segment\n            new_solution[a:b] = np.flip(new_solution[a:b])\n        else:  # 30% chance to reorder edges\n            segment = new_solution[a:b]\n            random.shuffle(segment)\n            new_solution[a:b] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search operator that combines segment inversion with adaptive node swaps and probabilistic edge reinsertion to generate a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.7:\n        # Adaptive segment inversion\n        segment_size = max(2, min(5, random.randint(1, n // 3)))\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n    else:\n        # Probabilistic edge reinsertion\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Additional adaptive node swap\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.946545808080536,
            1.5220236778259277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.6 * x[1][0] + 0.4 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    if random.random() < 0.7:\n        # Adaptive segment inversion\n        segment_size = max(2, min(5, random.randint(1, n // 3)))\n        start = random.randint(1, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = np.flip(new_solution[start:end])\n    else:\n        # Probabilistic edge reinsertion\n        i, j = random.sample(range(1, n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Additional adaptive node swap\n    if random.random() < 0.4:\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective weighting that adapts to the current archive's Pareto front, then applies a hybrid local search combining adaptive segment inversion with a novel distance-aware node insertion to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate Pareto front and normalize objectives\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(obj)\n\n    if not pareto_front:\n        pareto_front = [archive[0][1]]\n\n    # Dynamic weighting based on Pareto front spread\n    obj1_range = max(obj[0] for obj in pareto_front) - min(obj[0] for obj in pareto_front)\n    obj2_range = max(obj[1] for obj in pareto_front) - min(obj[1] for obj in pareto_front)\n    weight1 = 0.5 + 0.4 * (obj1_range / (obj1_range + obj2_range)) if (obj1_range + obj2_range) > 0 else 0.5\n    weight2 = 1 - weight1\n\n    # Select solution with highest weighted score and diversity bonus\n    selected_solution = max(archive, key=lambda x: (weight1 * x[1][0] + weight2 * x[1][1]) *\n                           (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Step 2: Distance-aware node insertion\n    if random.random() < 0.4:\n        # Select a node to relocate\n        node_idx = random.randint(1, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = node_idx\n\n        for pos in range(1, n):\n            if pos == node_idx:\n                continue\n\n            # Calculate new distances\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            total_cost = weight1 * cost1 + weight2 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the node\n        if best_pos != node_idx:\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.877020649662205,
            1.6545299291610718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate Pareto front and normalize objectives\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(obj)\n\n    if not pareto_front:\n        pareto_front = [archive[0][1]]\n\n    # Dynamic weighting based on Pareto front spread\n    obj1_range = max(obj[0] for obj in pareto_front) - min(obj[0] for obj in pareto_front)\n    obj2_range = max(obj[1] for obj in pareto_front) - min(obj[1] for obj in pareto_front)\n    weight1 = 0.5 + 0.4 * (obj1_range / (obj1_range + obj2_range)) if (obj1_range + obj2_range) > 0 else 0.5\n    weight2 = 1 - weight1\n\n    # Select solution with highest weighted score and diversity bonus\n    selected_solution = max(archive, key=lambda x: (weight1 * x[1][0] + weight2 * x[1][1]) *\n                           (1 + sum(1 for y in archive if y[1][0] <= x[1][0] and y[1][1] <= x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, min(6, random.randint(1, n // 3)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Step 2: Distance-aware node insertion\n    if random.random() < 0.4:\n        # Select a node to relocate\n        node_idx = random.randint(1, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position that minimizes both objectives\n        min_cost = float('inf')\n        best_pos = node_idx\n\n        for pos in range(1, n):\n            if pos == node_idx:\n                continue\n\n            # Calculate new distances\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            total_cost = weight1 * cost1 + weight2 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the node\n        if best_pos != node_idx:\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt with a novel edge-swap strategy, ensuring feasibility by validating the solution and reverting to a simpler move if invalid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9170499929722141,
            0.18973565101623535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1.0 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining segment reversal and edge reordering while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Validate and fix if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or counts.max() > 1:\n        # Apply edge swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9844756479135714,
            0.21114599704742432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Segment reversal with edge reordering\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Validate and fix if needed\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or counts.max() > 1:\n        # Apply edge swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score, then applies a novel combination of segment rotations and edge insertions to generate a neighbor solution while ensuring feasibility through careful validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments and apply rotational moves\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    if random.random() < 0.5:\n        # Rotate segment [a:b] to position after c\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n    else:\n        # Rotate segment [b:c] to position after a\n        segment = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    # Apply edge insertion with probability\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.9200914758044013,
            0.14482998847961426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three segments and apply rotational moves\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    if random.random() < 0.5:\n        # Rotate segment [a:b] to position after c\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n    else:\n        # Rotate segment [b:c] to position after a\n        segment = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    # Apply edge insertion with probability\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if invalid\n        a, b = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a novel local search combining random segment rotations and strategic edge insertions to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(1, n), 2))\n    rotation_amount = random.randint(1, b - a)\n\n    # Apply segment rotation\n    new_solution[a:b] = np.roll(new_solution[a:b], rotation_amount)\n\n    # Apply strategic edge insertion\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 1:\n            # Insert the segment between two nodes\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[j:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9524211760066148,
            0.16117841005325317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to rotate\n    a, b = sorted(random.sample(range(1, n), 2))\n    rotation_amount = random.randint(1, b - a)\n\n    # Apply segment rotation\n    new_solution[a:b] = np.roll(new_solution[a:b], rotation_amount)\n\n    # Apply strategic edge insertion\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 1:\n            # Insert the segment between two nodes\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[j:]])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel algorithm that selects a solution from the archive based on a weighted combination of objectives and diversity, then applies a dynamic segment inversion operator with adaptive segment sizes to generate a neighbor solution.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (0.7 * x[1][0] + 0.3 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment inversion with adaptive size\n    segment_size = max(2, min(5, random.randint(1, n // 4)))\n    start = random.randint(1, n - segment_size)\n    end = start + segment_size\n\n    # Invert segment with probability based on segment size\n    if random.random() < (segment_size / (n // 2)):\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Additional adaptive move: rotate a segment\n    if random.random() < 0.3:\n        rotate_size = random.randint(1, segment_size)\n        segment = new_solution[start:start+rotate_size]\n        new_solution = np.concatenate([new_solution[:start], segment[1:], segment[0:1], new_solution[start+rotate_size:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by swapping two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{A novel algorithm that selects a solution from the archive using a diversity-aware objective combination, then applies a multi-segment perturbation operator with adaptive segment sizes and probabilistic segment swapping to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment perturbation\n    num_segments = random.randint(1, 3)\n    segment_sizes = [random.randint(2, n // (num_segments + 1)) for _ in range(num_segments)]\n\n    for size in segment_sizes:\n        start = random.randint(0, n - size)\n        end = start + size\n\n        # Apply segment operation with probability\n        if random.random() < 0.7:\n            # Option 1: Invert segment\n            new_solution[start:end] = np.flip(new_solution[start:end])\n        elif random.random() < 0.3:\n            # Option 2: Rotate segment\n            rotate_pos = random.randint(1, size - 1)\n            new_solution[start:end] = np.roll(new_solution[start:end], rotate_pos)\n\n    # Probabilistic segment swap\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by repairing with nearest neighbor\n        for i in range(n):\n            if i not in new_solution:\n                missing = i\n                best_pos = 0\n                min_dist = float('inf')\n                for j in range(n):\n                    if j > 0 and new_solution[j-1] != missing and new_solution[j] != missing:\n                        dist = distance_matrix_1[new_solution[j-1], missing] + distance_matrix_1[missing, new_solution[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = j\n                new_solution = np.insert(new_solution, best_pos, missing)\n\n    return new_solution\n\n",
        "score": [
            -0.9306857882777001,
            1.4844670295715332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (0.5 * x[1][0] + 0.5 * x[1][1]) * (1 + sum(1 for y in archive if y[1][0] < x[1][0] and y[1][1] < x[1][1])))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Multi-segment perturbation\n    num_segments = random.randint(1, 3)\n    segment_sizes = [random.randint(2, n // (num_segments + 1)) for _ in range(num_segments)]\n\n    for size in segment_sizes:\n        start = random.randint(0, n - size)\n        end = start + size\n\n        # Apply segment operation with probability\n        if random.random() < 0.7:\n            # Option 1: Invert segment\n            new_solution[start:end] = np.flip(new_solution[start:end])\n        elif random.random() < 0.3:\n            # Option 2: Rotate segment\n            rotate_pos = random.randint(1, size - 1)\n            new_solution[start:end] = np.roll(new_solution[start:end], rotate_pos)\n\n    # Probabilistic segment swap\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fix by repairing with nearest neighbor\n        for i in range(n):\n            if i not in new_solution:\n                missing = i\n                best_pos = 0\n                min_dist = float('inf')\n                for j in range(n):\n                    if j > 0 and new_solution[j-1] != missing and new_solution[j] != missing:\n                        dist = distance_matrix_1[new_solution[j-1], missing] + distance_matrix_1[missing, new_solution[j]]\n                        if dist < min_dist:\n                            min_dist = dist\n                            best_pos = j\n                new_solution = np.insert(new_solution, best_pos, missing)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment rotations and node insertion to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and rotate it\n    a, b = sorted(random.sample(range(1, n), 2))\n    k = random.randint(1, b - a)\n    new_solution[a:b] = np.roll(new_solution[a:b], k)\n\n    # Randomly select a node and insert it into a new position\n    if random.random() < 0.5:\n        i = random.randint(1, n - 1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(1, n - 1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9530160727704305,
            0.22659200429916382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and rotate it\n    a, b = sorted(random.sample(range(1, n), 2))\n    k = random.randint(1, b - a)\n    new_solution[a:b] = np.roll(new_solution[a:b], k)\n\n    # Randomly select a node and insert it into a new position\n    if random.random() < 0.5:\n        i = random.randint(1, n - 1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(1, n - 1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment rotations and node insertions to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply segment rotation\n    if random.random() < 0.5:\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment = new_solution[a:b]\n        new_solution[a:b] = np.roll(segment, c - a)\n\n    # Apply node insertion\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8807398666509876,
            0.21399569511413574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Apply segment rotation\n    if random.random() < 0.5:\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment = new_solution[a:b]\n        new_solution[a:b] = np.roll(segment, c - a)\n\n    # Apply node insertion\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(1, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-swap strategy: adaptive segment selection and partial reversal\n    k = random.randint(2, min(5, n // 2))  # Random segment length\n    i = random.randint(0, n - k - 1)\n    new_solution[i:i+k] = np.flip(new_solution[i:i+k])\n\n    # Additional swap for diversification\n    if random.random() < 0.3:\n        j = random.randint(0, n - 2)\n        new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler segment reversal if invalid\n        m = random.randint(2, min(4, n // 2))\n        p = random.randint(0, n - m - 1)\n        new_solution[p:p+m] = np.flip(new_solution[p:p+m])\n\n    return new_solution\n\n",
        "score": [
            -0.8772256916970865,
            0.20987427234649658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    selected_solution = max(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Novel edge-swap strategy: adaptive segment selection and partial reversal\n    k = random.randint(2, min(5, n // 2))  # Random segment length\n    i = random.randint(0, n - k - 1)\n    new_solution[i:i+k] = np.flip(new_solution[i:i+k])\n\n    # Additional swap for diversification\n    if random.random() < 0.3:\n        j = random.randint(0, n - 2)\n        new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # Revert to a simpler segment reversal if invalid\n        m = random.randint(2, min(4, n // 2))\n        p = random.randint(0, n - m - 1)\n        new_solution[p:p+m] = np.flip(new_solution[p:p+m])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This new algorithm selects the solution with the highest sum of objectives from the archive, then applies a hybrid local search combining random segment reversals and edge flips with adaptive probabilities to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with adaptive weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal with adaptive probability\n    if random.random() < 0.5:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with adaptive probability\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9573845961723149,
            0.19166386127471924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with adaptive weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal with adaptive probability\n    if random.random() < 0.5:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with adaptive probability\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This new algorithm selects the solution with the lowest combined objective score from the archive, then applies a novel local search operator that combines adaptive segment rotations with probabilistic edge insertions, ensuring feasibility through dynamic validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    segments = [sorted(random.sample(range(1, n), 2)) for _ in range(k)]\n    for a, b in segments:\n        if random.random() < 0.7:\n            rotation = random.randint(1, b-a)\n            new_solution[a:b] = np.roll(new_solution[a:b], rotation)\n\n    # Probabilistic edge insertion\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j-1:\n            temp = new_solution[j]\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = temp\n\n    # Dynamic validation and fallback\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8364185581522955,
            0.1682634949684143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment rotation\n    k = random.randint(2, min(5, n//2))\n    segments = [sorted(random.sample(range(1, n), 2)) for _ in range(k)]\n    for a, b in segments:\n        if random.random() < 0.7:\n            rotation = random.randint(1, b-a)\n            new_solution[a:b] = np.roll(new_solution[a:b], rotation)\n\n    # Probabilistic edge insertion\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if i != j-1:\n            temp = new_solution[j]\n            new_solution[i+1:j] = new_solution[i:j-1]\n            new_solution[i] = temp\n\n    # Dynamic validation and fallback\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of both objectives, then applies a novel segment rotation operator that reorders segments of the tour while ensuring feasibility by verifying no nodes are duplicated or skipped.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to rotate\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment rotation: move segment [a:b] to position c\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9873199556314988,
            0.0716472864151001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to rotate\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment rotation: move segment [a:b] to position c\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap of two random nodes\n        i, j = random.sample(range(1, n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and its structural diversity, then applies a novel hybrid local search combining adaptive segment relocations, probabilistic edge insertions, and objective-aware edge swaps to generate a neighbor solution while ensuring feasibility through comprehensive validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(sol_obj):\n        sol, obj = sol_obj\n        # Weighted objective score (70% first objective, 30% second)\n        obj_score = obj[0] * 0.7 + obj[1] * 0.3\n        # Structural diversity: count unique consecutive node pairs\n        unique_pairs = len(set(zip(sol[:-1], sol[1:])))\n        diversity_score = unique_pairs / len(sol)\n        return obj_score * diversity_score\n\n    selected_solution = max(archive, key=selection_score)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = max(2, int(n * 0.2))  # 20% of tour length\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Probabilistic edge insertion\n    if random.random() < 0.4:\n        insert_pos = random.randint(0, n - 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n        # Remove duplicates while preserving order\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    # Objective-aware edge swap\n    if random.random() < 0.5:\n        # Select edges based on their contribution to objectives\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        edge1 = (new_solution[i-1], new_solution[i])\n        edge2 = (new_solution[j], new_solution[j+1])\n\n        # Calculate objective contributions\n        def edge_cost(edge):\n            return (distance_matrix_1[edge[0], edge[1]] * 0.7 +\n                    distance_matrix_2[edge[0], edge[1]] * 0.3)\n\n        cost1 = edge_cost(edge1) + edge_cost(edge2)\n        new_edge1 = (new_solution[i-1], new_solution[j])\n        new_edge2 = (new_solution[i], new_solution[j+1])\n        cost2 = edge_cost(new_edge1) + edge_cost(new_edge2)\n\n        if cost2 < cost1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Rebuild solution from scratch if invalid\n        remaining = list(range(n))\n        new_solution = [remaining.pop(0)]\n        while remaining:\n            last = new_solution[-1]\n            # Select next node based on combined distance\n            candidates = [(node, distance_matrix_1[last, node] * 0.7 +\n                          distance_matrix_2[last, node] * 0.3)\n                         for node in remaining]\n            next_node = min(candidates, key=lambda x: x[1])[0]\n            new_solution.append(next_node)\n            remaining.remove(next_node)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.9038659588065104,
            0.7320073246955872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_score(sol_obj):\n        sol, obj = sol_obj\n        # Weighted objective score (70% first objective, 30% second)\n        obj_score = obj[0] * 0.7 + obj[1] * 0.3\n        # Structural diversity: count unique consecutive node pairs\n        unique_pairs = len(set(zip(sol[:-1], sol[1:])))\n        diversity_score = unique_pairs / len(sol)\n        return obj_score * diversity_score\n\n    selected_solution = max(archive, key=selection_score)[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = max(2, int(n * 0.2))  # 20% of tour length\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length].copy()\n\n    # Probabilistic edge insertion\n    if random.random() < 0.4:\n        insert_pos = random.randint(0, n - 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n        # Remove duplicates while preserving order\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    # Objective-aware edge swap\n    if random.random() < 0.5:\n        # Select edges based on their contribution to objectives\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        edge1 = (new_solution[i-1], new_solution[i])\n        edge2 = (new_solution[j], new_solution[j+1])\n\n        # Calculate objective contributions\n        def edge_cost(edge):\n            return (distance_matrix_1[edge[0], edge[1]] * 0.7 +\n                    distance_matrix_2[edge[0], edge[1]] * 0.3)\n\n        cost1 = edge_cost(edge1) + edge_cost(edge2)\n        new_edge1 = (new_solution[i-1], new_solution[j])\n        new_edge2 = (new_solution[i], new_solution[j+1])\n        cost2 = edge_cost(new_edge1) + edge_cost(new_edge2)\n\n        if cost2 < cost1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Final feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Rebuild solution from scratch if invalid\n        remaining = list(range(n))\n        new_solution = [remaining.pop(0)]\n        while remaining:\n            last = new_solution[-1]\n            # Select next node based on combined distance\n            candidates = [(node, distance_matrix_1[last, node] * 0.7 +\n                          distance_matrix_2[last, node] * 0.3)\n                         for node in remaining]\n            next_node = min(candidates, key=lambda x: x[1])[0]\n            new_solution.append(next_node)\n            remaining.remove(next_node)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{A novel local search algorithm that combines a multi-objective selection criterion with a hybrid segment-swap and edge-reversal strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge crossing\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and cross edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge crossing between segments\n    if random.random() < 0.5:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8879291489544482,
            0.19146209955215454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Combine segment reversal with edge crossing\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Reverse segments and cross edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge crossing between segments\n    if random.random() < 0.5:\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm selects a solution from the archive using a probabilistic approach that favors solutions with better performance in both objectives, then applies a novel local search operator that combines adaptive segment rotations and conditional edge swaps to generate a neighbor solution while maintaining feasibility through comprehensive validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - normalized.prod(axis=1)  # Favor solutions with balanced objectives\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n//4, random.randint(2, n//2)))\n    start = random.randint(1, n - segment_size)\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[start:start+segment_size]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_size] = rotated_segment\n\n    # Conditional edge swap based on objective improvement\n    i, j = sorted(random.sample(range(1, n), 2))\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check with fallback\n    if len(np.unique(new_solution)) != n:\n        # Apply a guaranteed feasible operation\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.9204516596753014,
            0.23111939430236816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 - normalized.prod(axis=1)  # Favor solutions with balanced objectives\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    selected_solution = archive[selected_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment rotation\n    segment_size = max(2, min(n//4, random.randint(2, n//2)))\n    start = random.randint(1, n - segment_size)\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[start:start+segment_size]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_size] = rotated_segment\n\n    # Conditional edge swap based on objective improvement\n    i, j = sorted(random.sample(range(1, n), 2))\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check with fallback\n    if len(np.unique(new_solution)) != n:\n        # Apply a guaranteed feasible operation\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A novel hybrid local search approach that selects a solution from the archive based on a weighted dominance metric, then applies a segment inversion and edge crossover strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion with edge crossover\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Invert segments and perform edge crossover\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Cross edges between segments\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler inversion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.8842674905311309,
            0.20969349145889282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Segment inversion with edge crossover\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Invert segments and perform edge crossover\n    segment1 = np.flip(new_solution[a:b])\n    segment2 = np.flip(new_solution[c:d])\n\n    # Cross edges between segments\n    new_solution[a:b] = segment1\n    new_solution[c:d] = segment2\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simpler inversion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objectives with adaptive weights, then applies a hybrid local search combining segment reversal and edge swapping with feasibility checks to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on relative objective values\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_total = sum(total_costs) / len(total_costs) if total_costs else 0\n    weights = [1 / (sum(obj) / avg_total) if avg_total > 0 else 1 for _, obj in archive]\n\n    # Select solution with probability proportional to its weight\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment reversal with edge swapping\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge swapping\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swapping between segments\n    if b < c:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8985380469334094,
            0.1995084285736084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate weights based on relative objective values\n    total_costs = [sum(obj) for _, obj in archive]\n    avg_total = sum(total_costs) / len(total_costs) if total_costs else 0\n    weights = [1 / (sum(obj) / avg_total) if avg_total > 0 else 1 for _, obj in archive]\n\n    # Select solution with probability proportional to its weight\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Segment reversal with edge swapping\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply segment reversal and edge swapping\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Edge swapping between segments\n    if b < c:\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This new algorithm selects the solution with the highest normalized objective score (using a different weighting scheme) from the archive, then applies a hybrid local search combining random segment reversals and edge swaps with adaptive probabilities to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj = max(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))[0].copy()\n\n    n = len(max_obj)\n    new_solution = max_obj.copy()\n\n    # Adaptive segment reversal\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Adaptive edge swap\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9331773804883055,
            0.21455347537994385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_obj = max(archive, key=lambda x: (x[1][0] * 0.5 + x[1][1] * 0.5))[0].copy()\n\n    n = len(max_obj)\n    new_solution = max_obj.copy()\n\n    # Adaptive segment reversal\n    if random.random() < 0.7:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Adaptive edge swap\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a hybrid local search combining segment reversals, edge insertions, and dynamic edge flips to generate a neighbor solution while ensuring feasibility through comprehensive validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * np.std(np.diff(x[0]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply dynamic segment reversal based on edge weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge insertion to improve connectivity\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Apply dynamic edge flips based on distance improvement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(1, n), 2))\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7117352650517069,
            1.4481490850448608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * np.std(np.diff(x[0]))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply dynamic segment reversal based on edge weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Apply edge insertion to improve connectivity\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Apply dynamic edge flips based on distance improvement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(1, n), 2))\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                   distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to swap (avoiding trivial cases)\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply a novel edge-swap: reverse segments and reorder edges\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Ensure feasibility by checking for duplicates and fixing if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects the solution with the highest combined objective score from the archive, then applies a hybrid local search combining random segment reversals and edge flips to generate a neighbor solution while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = max(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments with different weights\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Apply weighted segment reversal\n    if random.random() < 0.6:\n        new_solution[a:b] = np.flip(new_solution[a:b])\n    else:\n        new_solution[c:d] = np.flip(new_solution[c:d])\n\n    # Apply edge flip with probability\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"cluster-based\" local search that identifies and reorders node clusters in each objective space to improve both objectives simultaneously while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * (len(archive) / (1 + len(archive)))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify clusters in each objective space\n    def find_clusters(distance_matrix):\n        # Simple clustering based on distance thresholds\n        clusters = []\n        visited = set()\n        for i in range(n):\n            if i not in visited:\n                cluster = [i]\n                visited.add(i)\n                for j in range(i+1, n):\n                    if j not in visited and distance_matrix[selected_solution[i], selected_solution[j]] < 0.3 * np.mean(distance_matrix):\n                        cluster.append(j)\n                        visited.add(j)\n                if len(cluster) > 1:\n                    clusters.append(cluster)\n        return clusters\n\n    clusters1 = find_clusters(distance_matrix_1)\n    clusters2 = find_clusters(distance_matrix_2)\n\n    # Reorder clusters in both objective spaces\n    if clusters1 and random.random() < 0.5:\n        cluster = random.choice(clusters1)\n        start = random.randint(0, n - len(cluster))\n        new_solution[start:start+len(cluster)] = selected_solution[cluster]\n\n    if clusters2 and random.random() < 0.5:\n        cluster = random.choice(clusters2)\n        start = random.randint(0, n - len(cluster))\n        new_solution[start:start+len(cluster)] = selected_solution[cluster]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9128995520456947,
            1.1023021936416626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + 0.1 * (len(archive) / (1 + len(archive)))))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify clusters in each objective space\n    def find_clusters(distance_matrix):\n        # Simple clustering based on distance thresholds\n        clusters = []\n        visited = set()\n        for i in range(n):\n            if i not in visited:\n                cluster = [i]\n                visited.add(i)\n                for j in range(i+1, n):\n                    if j not in visited and distance_matrix[selected_solution[i], selected_solution[j]] < 0.3 * np.mean(distance_matrix):\n                        cluster.append(j)\n                        visited.add(j)\n                if len(cluster) > 1:\n                    clusters.append(cluster)\n        return clusters\n\n    clusters1 = find_clusters(distance_matrix_1)\n    clusters2 = find_clusters(distance_matrix_2)\n\n    # Reorder clusters in both objective spaces\n    if clusters1 and random.random() < 0.5:\n        cluster = random.choice(clusters1)\n        start = random.randint(0, n - len(cluster))\n        new_solution[start:start+len(cluster)] = selected_solution[cluster]\n\n    if clusters2 and random.random() < 0.5:\n        cluster = random.choice(clusters2)\n        start = random.randint(0, n - len(cluster))\n        new_solution[start:start+len(cluster)] = selected_solution[cluster]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    }
]