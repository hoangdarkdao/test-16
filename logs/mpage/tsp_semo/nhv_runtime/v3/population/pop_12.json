[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol_i, obj_i))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Step 2: Select a solution based on objective values and diversity\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized_obj = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = []\n    for sol, _ in pareto_front:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i], sol[(i+1)%len(sol)]), max(sol[i], sol[(i+1)%len(sol)])))\n        diversity_scores.append(len(unique_edges))\n    diversity_scores = np.array(diversity_scores) / (np.max(diversity_scores) + 1e-10)\n\n    selection_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Step 3: Multi-segment crossover operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random segments from the base solution\n    seg1_start = np.random.randint(0, n)\n    seg1_length = np.random.randint(2, min(4, n//2))\n    seg1_end = (seg1_start + seg1_length) % n\n\n    seg2_start = np.random.randint(0, n)\n    while abs(seg2_start - seg1_start) < 2 or abs(seg2_start - seg1_end) < 2:\n        seg2_start = np.random.randint(0, n)\n    seg2_length = np.random.randint(2, min(4, n//2))\n    seg2_end = (seg2_start + seg2_length) % n\n\n    # Extract segments\n    if seg1_start < seg1_end:\n        seg1 = new_solution[seg1_start:seg1_end]\n    else:\n        seg1 = np.concatenate([new_solution[seg1_start:], new_solution[:seg1_end]])\n\n    if seg2_start < seg2_end:\n        seg2 = new_solution[seg2_start:seg2_end]\n    else:\n        seg2 = np.concatenate([new_solution[seg2_start:], new_solution[:seg2_end]])\n\n    # Select a third segment from another solution in the archive\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    seg3_start = np.random.randint(0, n)\n    seg3_length = np.random.randint(2, min(4, n//2))\n    seg3_end = (seg3_start + seg3_length) % n\n\n    if seg3_start < seg3_end:\n        seg3 = other_sol[seg3_start:seg3_end]\n    else:\n        seg3 = np.concatenate([other_sol[seg3_start:], other_sol[:seg3_end]])\n\n    # Combine segments to form new solution\n    remaining_nodes = set(range(n)) - set(seg1) - set(seg2) - set(seg3)\n    new_solution = np.concatenate([seg1, seg2, seg3, np.array(list(remaining_nodes))])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0059111292081795,
               0.346810519695282
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining segment-based manipulation with a novel edge rotation strategy. It first selects a solution from the archive using a weighted objective function that prioritizes solutions with balanced improvements in both objectives, then applies a hybrid local search that involves rotating a randomly selected segment by a fixed number of positions and inserting it into a different position in the tour, while also performing a novel edge rotation operation that cyclically permutes edges between non-adjacent segments to explore diverse solutions. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment rotation if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment rotation and insertion with edge rotation\n    # Step 1: Select a random segment to rotate\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n\n    # Step 2: Insert the rotated segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], rotated_segment, base_solution[k:]])\n\n    # Step 3: Perform edge rotation between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        rotation_a = np.random.randint(1, len(segment_a))\n        rotation_b = np.random.randint(1, len(segment_b))\n        new_solution[a:b] = np.roll(segment_a, rotation_a)\n        new_solution[b:] = np.roll(segment_b, rotation_b)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment rotation\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        rotation = np.random.randint(1, j - i + 1)\n        new_solution[i:j+1] = np.roll(base_solution[i:j+1], rotation)\n\n    return new_solution\n\n",
          "score": [
               -0.9354692806128575,
               0.13754773139953613
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a hierarchical local search approach that combines a multi-objective-aware node clustering strategy with a novel edge contraction-expansion mechanism. It first identifies clusters of nodes based on their proximity in both objective spaces, then selectively contracts edges between distant clusters while expanding edges within clusters, followed by a probabilistic node reordering that prioritizes edges with balanced distance improvements across objectives. The method incorporates a dynamic cluster size adjustment based on the current solution's objective balance, ensuring exploration of diverse neighborhoods while maintaining feasibility through careful validation and fallback mechanisms.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives.sum(axis=1) + 1e-6)\n    weights = 1.0 / (obj_balance + 1e-6)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Cluster nodes based on both distance matrices\n    cluster_size = max(3, min(8, n // 3))\n    clusters = []\n    remaining = set(range(n))\n    while remaining:\n        center = np.random.choice(list(remaining))\n        cluster = [center]\n        remaining.remove(center)\n        for _ in range(cluster_size - 1):\n            if not remaining:\n                break\n            closest = min(remaining, key=lambda x: distance_matrix_1[center, x] + distance_matrix_2[center, x])\n            cluster.append(closest)\n            remaining.remove(closest)\n        clusters.append(cluster)\n\n    # Step 3: Edge contraction-expansion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        # Contract edges between cluster nodes\n        for i in range(len(cluster)):\n            for j in range(i+1, len(cluster)):\n                a, b = cluster[i], cluster[j]\n                if a > b:\n                    a, b = b, a\n                # Check if swapping a and b improves both objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Expand edges within cluster\n        for i in range(len(cluster)-1):\n            a, b = cluster[i], cluster[i+1]\n            if a > b:\n                a, b = b, a\n            # Check if moving b after a improves both objectives\n            if b != (a+1)%n:\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    # Move b after a\n                    node = new_solution[b]\n                    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n                    insert_pos = np.where(new_solution == new_solution[a])[0][0] + 1\n                    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Probabilistic node reordering based on objective balance\n    obj1, obj2 = archive[selected_idx][1]\n    if abs(obj1 - obj2) > 0.2 * (obj1 + obj2):\n        # More aggressive reordering when objectives are unbalanced\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            # Check if swapping segments improves both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            if delta1 + delta2 < 0:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 5: Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -1.0807467550296899,
               0.6731994152069092
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining a novel segment permutation strategy with a dynamic edge reassembly mechanism. It first selects a solution from the archive using a diversity-aware selection mechanism that prioritizes solutions with high variance in objective improvements, then applies a hybrid local search that involves permuting a randomly selected segment using a custom permutation pattern and inserting it into a different position in the tour, while also performing a dynamic edge reassembly operation that reconstructs edges between non-adjacent segments based on a probabilistic model that considers both distance matrices to explore promising regions of the solution space. The algorithm ensures feasibility by verifying no duplicates or missing nodes and includes a fallback mechanism to a simple segment permutation if the solution becomes invalid, with the permutation pattern dynamically adjusted based on the current solution's properties.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    obj_variance = np.var(objectives, axis=0)\n    weights = obj_variance / np.sum(obj_variance)\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment permutation and dynamic edge reassembly\n    # Step 1: Select a random segment to permute\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n\n    # Create a custom permutation pattern based on distance matrices\n    segment_distances = distance_matrix_1[segment, :][:, segment] + distance_matrix_2[segment, :][:, segment]\n    permutation = np.argsort(np.sum(segment_distances, axis=1))\n    permuted_segment = segment[permutation]\n\n    # Step 2: Insert the permuted segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], permuted_segment, base_solution[k:]])\n\n    # Step 3: Dynamic edge reassembly between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n\n        # Probabilistic reassembly based on distance matrices\n        a_distances = distance_matrix_1[segment_a, :] + distance_matrix_2[segment_a, :]\n        b_distances = distance_matrix_1[segment_b, :] + distance_matrix_2[segment_b, :]\n\n        a_prob = np.exp(-np.sum(a_distances, axis=1) / np.sum(a_distances))\n        b_prob = np.exp(-np.sum(b_distances, axis=1) / np.sum(b_distances))\n\n        a_permutation = np.argsort(a_prob)\n        b_permutation = np.argsort(b_prob)\n\n        new_solution[a:b] = segment_a[a_permutation]\n        new_solution[b:] = segment_b[b_permutation]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment permutation with dynamic pattern\n        segment = base_solution[i:j+1]\n        segment_distances = distance_matrix_1[segment, :][:, segment] + distance_matrix_2[segment, :][:, segment]\n        permutation = np.argsort(np.sum(segment_distances, axis=1))\n        new_solution[i:j+1] = segment[permutation]\n\n    return new_solution\n\n",
          "score": [
               -1.0044109690536933,
               0.21091383695602417
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of analyzing solution segments and their performance across objectives by introducing a novel \"objective-aware segment reassembly\" strategy. It first selects a solution from the archive based on a dynamic objective prioritization that adapts to the current state of the search, then decomposes the tour into segments while maintaining their relative order, and finally reconstructs the tour by reinserting segments in a position that optimizes a weighted combination of their individual segment costs in both objectives and their potential connection costs, while incorporating a probabilistic segment inversion mechanism that flips segments with high potential for improving both objectives simultaneously, all while ensuring feasibility by carefully tracking node coverage and maintaining the tour's connectivity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic objective prioritization based on archive diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_range = np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10\n    obj_weights = 1 / obj_range\n    obj_weights /= np.sum(obj_weights)\n\n    weighted_scores = np.dot(objectives, obj_weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition with order preservation\n    segment_length = max(2, n // 4)\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        segments.append(segment)\n\n    # Objective-aware segment reassembly\n    remaining_nodes = set(range(n))\n    new_solution = []\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while remaining_nodes:\n        best_segment = None\n        best_score = float('inf')\n\n        for seg in segments:\n            if not remaining_nodes.intersection(seg):\n                continue\n\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n\n            # Calculate connection cost to current path\n            last_in_new = new_solution[-1]\n            first_in_seg = seg[0]\n            connection_cost = (distance_matrix_1[last_in_new, first_in_seg] +\n                             distance_matrix_2[last_in_new, first_in_seg])\n\n            # Combined score with objective weights\n            total_score = (obj_weights[0] * seg_cost1 +\n                          obj_weights[1] * seg_cost2 +\n                          0.5 * connection_cost)\n\n            if total_score < best_score:\n                best_score = total_score\n                best_segment = seg\n\n        if best_segment is None:\n            # Fallback to nearest neighbor\n            candidates = list(remaining_nodes)\n            nearest = min(candidates, key=lambda x: (obj_weights[0] * distance_matrix_1[current_node, x] +\n                                                    obj_weights[1] * distance_matrix_2[current_node, x]))\n            new_solution.append(nearest)\n            remaining_nodes.remove(nearest)\n            current_node = nearest\n        else:\n            # Probabilistic segment inversion\n            if np.random.random() < 0.3:\n                best_segment = best_segment[::-1]\n\n            # Add the best segment\n            for node in best_segment:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = best_segment[-1]\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(new_solution) == n + 1 and len(np.unique(new_solution[:-1])) == n\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9374460926948939,
               0.16694027185440063
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search by combining segment-based manipulation with a novel path inversion strategy. It first selects a solution from the archive using a weighted objective function that prioritizes solutions with balanced improvements in both objectives, then applies a hybrid local search that involves inverting a randomly selected segment of the tour and inserting it at a different position, while also performing a novel path inversion operation that reverses the order of edges between non-adjacent segments to explore diverse solutions. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment inversion if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment inversion and insertion with path inversion\n    # Step 1: Select a random segment to invert\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n    inverted_segment = segment[::-1]\n\n    # Step 2: Insert the inverted segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], inverted_segment, base_solution[k:]])\n\n    # Step 3: Perform path inversion between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        inverted_a = segment_a[::-1]\n        inverted_b = segment_b[::-1]\n        new_solution[a:b] = inverted_a\n        new_solution[b:] = inverted_b\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.9088239710243505,
               0.10778272151947021
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the hybrid local search framework by integrating a novel \"segment fusion and splitting\" strategy. It first selects a solution from the archive using a dynamic weight-based selection that adapts to the relative improvement potential of each objective. Then, it applies a hybrid operation that fuses two randomly selected non-overlapping segments by reversing one and inserting it into the other, followed by a controlled splitting of the fused segment into two new segments with a novel edge crossover operation. The algorithm ensures feasibility by validating node uniqueness and employs a fallback to a simple segment swap if the solution becomes invalid, while also incorporating a dynamic segment size adjustment based on the current solution's objective values to balance exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    weights = np.array([obj2_avg / (obj1_avg + obj2_avg), obj1_avg / (obj1_avg + obj2_avg)])\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Segment fusion and splitting\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Fusion: reverse segment between a and b and insert into segment between c and d\n    segment1 = base_solution[a:b+1][::-1]\n    segment2 = base_solution[c:d+1]\n    fused_segment = np.concatenate([segment1, segment2])\n\n    # Splitting: split fused segment into two new segments with edge crossover\n    split_point = np.random.randint(1, len(fused_segment)-1)\n    new_segment1 = fused_segment[:split_point]\n    new_segment2 = fused_segment[split_point:]\n\n    # Reconstruct solution\n    new_solution = np.concatenate([\n        base_solution[:a],\n        new_segment1,\n        base_solution[b+1:c],\n        new_segment2,\n        base_solution[d+1:]\n    ])\n\n    # Dynamic segment size adjustment\n    if np.random.random() < 0.3:  # 30% chance to adjust segment sizes\n        k = np.random.randint(1, n//2)\n        new_solution = np.roll(new_solution, k)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment swap\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1], new_solution[j+1:i+1] = new_solution[j+1:i+1], new_solution[i:j+1]\n\n    return new_solution\n\n",
          "score": [
               -0.6708687806053801,
               0.09923422336578369
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective-aware path reconstruction strategy\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Phase 1: Identify critical nodes in each objective space\n    critical_nodes1 = np.argsort(np.sum(distance_matrix_1, axis=1))[:len(solutions)//2]\n    critical_nodes2 = np.argsort(np.sum(distance_matrix_2, axis=1))[:len(solutions)//2]\n    critical_nodes = np.unique(np.concatenate([critical_nodes1, critical_nodes2]))\n\n    # Phase 2: Select a solution with high diversity in objectives\n    obj_ranges = objectives.max(axis=0) - objectives.min(axis=0)\n    diversity_scores = np.prod(objectives / (obj_ranges + 1e-10), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Phase 3: Construct new solution by inserting critical nodes\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    current_node = base_solution[0]\n\n    while remaining_nodes:\n        new_solution.append(current_node)\n        remaining_nodes.remove(current_node)\n\n        # Find next node with best combined objective improvement\n        candidates = list(remaining_nodes)\n        if not candidates:\n            break\n\n        # Evaluate potential next nodes\n        candidate_scores = []\n        for candidate in candidates:\n            # Calculate potential improvement in both objectives\n            cost1 = distance_matrix_1[current_node, candidate]\n            cost2 = distance_matrix_2[current_node, candidate]\n\n            # Combine with critical node preference\n            is_critical = candidate in critical_nodes\n            score = (cost1 + cost2) * (1.5 if is_critical else 1.0)\n            candidate_scores.append(score)\n\n        # Select node with best combined score\n        next_idx = np.argmin(candidate_scores)\n        current_node = candidates[next_idx]\n\n    # Ensure Hamiltonian cycle\n    new_solution.append(new_solution[0])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9911737239425997,
               0.8463422656059265
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining edge assembly with a novel segment insertion strategy. It first selects a promising solution from the archive based on a weighted objective function that balances both objectives, then applies a hybrid local search that involves reversing a randomly selected segment and inserting it into a different position in the tour, while also performing a novel edge reconnection operation that swaps edges between non-adjacent segments to further improve the solution. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment reversal if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal and insertion with edge reconnection\n    # Step 1: Select a random segment to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1][::-1]\n\n    # Step 2: Insert the reversed segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], segment, base_solution[k:]])\n\n    # Step 3: Perform edge reconnection between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:] = new_solution[b:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8660185612302642,
               0.10953599214553833
          ]
     }
]