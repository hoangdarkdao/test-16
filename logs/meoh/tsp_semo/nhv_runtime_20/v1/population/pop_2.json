[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on potential improvement in both objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj[:, 0] * normalized_obj[:, 1]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search: segment rotation and node insertion\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Segment rotation\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n    new_solution[a:b+1] = rotated_segment\n\n    # Node insertion\n    if b - a > 1:\n        c = np.random.randint(a, b)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        new_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8977406268746986,
            0.5329287052154541
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its diversity and applies a novel local search that combines segment reversal and adaptive insertion, guided by the objectives' improvement potential, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment reversal\n    n = len(base_solution)\n    start, end = np.random.choice(n, size=2, replace=False)\n    start, end = min(start, end), max(start, end)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive insertion\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, size=2, replace=False)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = np.random.choice(n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8185823077634173,
            0.48852038383483887
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive segment insertion and conditional edge reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    selected = archive[best_idx][0].copy()\n    new_solution = selected.copy()\n\n    # Adaptive segment insertion\n    n = len(new_solution)\n    segment_length = max(2, min(n // 3, 5))\n    a = np.random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Conditional edge reversal\n    if np.random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Insert segment at new position\n    b = np.random.randint(0, n - segment_length)\n    if b > a:\n        b += segment_length\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+segment_length:b], segment, new_solution[b:]])\n\n    # Ensure feasibility by removing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7161059100816528,
            0.32208681106567383
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on potential improvement in both objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected = archive[np.random.choice(len(archive))][0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search: segment reversal and edge swap\n    n = len(new_solution)\n    a, b = np.random.choice(n, size=2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Segment reversal\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap\n    if b - a > 1:\n        c = np.random.randint(a, b)\n        new_solution[c], new_solution[c+1] = new_solution[c+1], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.9058581161155227,
            0.5731940269470215
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of non-dominated status and diversity, then applies a novel local search combining segment reversal with adaptive path insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated or diverse)\n    non_dominated = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(idx)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply novel local search: segment reversal with adaptive path insertion\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n    # Segment reversal\n    segment = new_solution[a:b+1][::-1]\n    new_solution[a:b+1] = segment\n\n    # Adaptive path insertion\n    if np.random.rand() < 0.7:\n        temp = new_solution.copy()\n        for i in range(c, d+1):\n            if i < len(temp) and temp[i] not in temp[:i]:\n                continue\n            # Find a valid position to insert\n            for j in range(len(temp)):\n                if temp[j] not in temp[:i]:\n                    temp[i], temp[j] = temp[j], temp[i]\n                    break\n        new_solution = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8484553688511265,
            0.5936729311943054
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines a randomized segment reversal with a multi-objective-aware edge insertion, ensuring feasibility while balancing exploration and exploitation in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined objective score (lower is better)\n        sorted_solutions = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution with probability inversely proportional to its rank\n        weights = [1 / (i + 1) for i in range(len(sorted_solutions))]\n        weights = np.array(weights) / np.sum(weights)\n        selected_idx = np.random.choice(len(sorted_solutions), p=weights)\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Segment reversal\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Multi-objective-aware edge insertion\n        # Randomly select a node to relocate\n        node_to_move = random.choice(new_solution)\n        # Find its position and remove it\n        pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.delete(new_solution, pos)\n\n        # Calculate insertion costs in both objectives\n        insertion_costs = []\n        for i in range(len(new_solution)):\n            a, b = new_solution[i-1], new_solution[i]\n            # Cost in first objective space\n            cost1 = distance_matrix_1[a, node_to_move] + distance_matrix_1[node_to_move, b] - distance_matrix_1[a, b]\n            # Cost in second objective space\n            cost2 = distance_matrix_2[a, node_to_move] + distance_matrix_2[node_to_move, b] - distance_matrix_2[a, b]\n            insertion_costs.append((cost1, cost2))\n\n        # Select insertion point with combined cost\n        combined_costs = [c1 + c2 for c1, c2 in insertion_costs]\n        # Prefer insertion points with lower combined cost (greedy)\n        min_cost = min(combined_costs)\n        candidates = [i for i, cost in enumerate(combined_costs) if cost == min_cost]\n        insert_pos = random.choice(candidates)\n\n        # Insert the node back\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.723705464561455,
            0.5579736232757568
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel hybrid local search combining segment rotations and node insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    selected = archive[selected_idx][0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n\n    # Novel hybrid local search: segment rotation and node insertion\n    if n > 3:\n        # Segment rotation\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n        if b - a > 1:\n            k = np.random.randint(1, b - a)\n            new_solution[a:b] = np.roll(new_solution[a:b], k)\n\n        # Node insertion\n        if n > 4:\n            i, j = np.random.choice(n, size=2, replace=False)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8507854066021172,
            0.5963020324707031
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on its dominance in the objective space, then applies a novel local search strategy that combines node insertion with a dynamic segment rotation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: dynamic segment rotation and node insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back\n    new_solution[a:b+1] = rotated_segment\n\n    # Randomly select a node and insert it elsewhere\n    if n > 3:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7468281771017797,
            0.5764278173446655
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive with high potential for improvement by evaluating its non-dominated neighbors and applies a hybrid local search combining edge-swapping and path-relinking to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge-swapping and path-relinking\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Edge-swapping\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path-relinking (partial crossover)\n    if np.random.rand() < 0.5:\n        temp = new_solution.copy()\n        for idx in range(min(k, l), max(k, l) + 1):\n            temp[idx] = base_solution[idx]\n        new_solution = temp\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8367066912509327,
            0.6212632656097412
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines a randomized segment reversal with a multi-objective-aware edge insertion to explore the solution space while balancing the two objectives, ensuring feasibility and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_index = np.random.choice(len(archive), p=np.linspace(1, 0.1, len(archive)) / np.linspace(1, 0.1, len(archive)).sum())\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized segment reversal + multi-objective edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Random segment reversal\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Multi-objective edge insertion\n    for _ in range(2):  # Perform 2 insertions\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if i == j:\n            continue\n\n        # Calculate insertion cost in both objectives\n        def insertion_cost(k):\n            cost1 = distance_matrix_1[new_solution[k-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[k]]\n            cost2 = distance_matrix_2[new_solution[k-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[k]]\n            return (cost1, cost2)\n\n        # Find best insertion point\n        best_k = -1\n        best_cost = (float('inf'), float('inf'))\n        for k in range(1, n):\n            if k == i or k == j:\n                continue\n            current_cost = insertion_cost(k)\n            if (current_cost[0] < best_cost[0] and current_cost[1] <= best_cost[1]) or \\\n               (current_cost[1] < best_cost[1] and current_cost[0] <= best_cost[0]):\n                best_k = k\n                best_cost = current_cost\n\n        if best_k != -1:\n            # Perform insertion\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:best_k], [node], new_solution[best_k:]])\n            new_solution = np.delete(new_solution, i if i < best_k else i+1)\n\n    return new_solution\n\n",
        "score": [
            -0.8285655654544267,
            0.7837492823600769
        ]
    }
]