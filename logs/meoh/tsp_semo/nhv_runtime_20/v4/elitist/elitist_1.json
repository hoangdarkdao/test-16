[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8713409949848904,
            0.37909936904907227
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8311942081231796,
            0.23212707042694092
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8311942081231796,
            0.23212707042694092
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8713409949848904,
            0.37909936904907227
        ]
    }
]