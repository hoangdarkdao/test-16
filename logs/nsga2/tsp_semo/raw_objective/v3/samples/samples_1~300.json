[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            6.76043022298579,
            7.4315515694780645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            6.76043022298579,
            7.4315515694780645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            6.76043022298579,
            7.4315515694780645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.910882867546672,
            6.797800312801045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.910882867546672,
            6.797800312801045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of its objectives, then applies a hybrid local search combining a novel edge-swap operator with a probabilistic edge-reversal strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted probability based on its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: novel edge-swap with probabilistic edge-reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random segments to swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform edge-swap between segments\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[c:d+1],\n        new_solution[b+1:c],\n        new_solution[a:b+1],\n        new_solution[d+1:]\n    ])\n\n    # Probabilistic edge-reversal for diversification\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.334627853796341,
            8.823254956496594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a weighted probability based on its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (1 + normalized_obj.sum(axis=1))\n    weights /= weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: novel edge-swap with probabilistic edge-reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select two random segments to swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform edge-swap between segments\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[c:d+1],\n        new_solution[b+1:c],\n        new_solution[a:b+1],\n        new_solution[d+1:]\n    ])\n\n    # Probabilistic edge-reversal for diversification\n    if np.random.rand() < 0.3:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback: simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective tournament selection with a segment-based relocation and inversion operator to explore high-quality regions of the Pareto front by intelligently relocating and reversing segments of the tour while balancing improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation and inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to relocate and invert\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 2, n - 1))  # Small segment for better exploration\n\n    segment = new_solution[seg_start:seg_end + 1]\n    segment = segment[::-1]  # Invert the segment\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            6.9736623853076,
            6.989651591693228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relocation and inversion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to relocate and invert\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 2, n - 1))  # Small segment for better exploration\n\n    segment = new_solution[seg_start:seg_end + 1]\n    segment = segment[::-1]  # Invert the segment\n\n    # Remove the segment from its original position\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end + 1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{This heuristic selects a solution from the archive with the highest sum of normalized objective values (indicating potential for improvement) and applies a hybrid local search combining 3-opt with a novel adaptive edge swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives (promising for improvement)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with adaptive edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Adaptive edge swaps based on distance matrices\n    for _ in range(3):  # Perform a few adaptive swaps\n        i, j = random.sample(range(1, n-1), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change in both objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[j+1]),\n            (new_solution[i], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[j+1]),\n            (new_solution[j], new_solution[i])\n        ]\n\n        cost1_change = sum(distance_matrix_1[a][b] - distance_matrix_1[a][b] for (a, b) in old_edges + new_edges)\n        cost2_change = sum(distance_matrix_2[a][b] - distance_matrix_2[a][b] for (a, b) in old_edges + new_edges)\n\n        # Accept if both objectives improve or one improves significantly\n        if (cost1_change < 0 and cost2_change < 0) or (abs(cost1_change) < 0.1 * objectives.mean() and abs(cost2_change) < 0.1 * objectives.mean()):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.85082088227125,
            10.584104533577369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives (promising for improvement)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with adaptive edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    a, b, c = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Adaptive edge swaps based on distance matrices\n    for _ in range(3):  # Perform a few adaptive swaps\n        i, j = random.sample(range(1, n-1), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change in both objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[j+1]),\n            (new_solution[i], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[j+1]),\n            (new_solution[j], new_solution[i])\n        ]\n\n        cost1_change = sum(distance_matrix_1[a][b] - distance_matrix_1[a][b] for (a, b) in old_edges + new_edges)\n        cost2_change = sum(distance_matrix_2[a][b] - distance_matrix_2[a][b] for (a, b) in old_edges + new_edges)\n\n        # Accept if both objectives improve or one improves significantly\n        if (cost1_change < 0 and cost2_change < 0) or (abs(cost1_change) < 0.1 * objectives.mean() and abs(cost2_change) < 0.1 * objectives.mean()):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine node insertion with segment rotation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Node insertion: move node i to position j\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Segment rotation: rotate a random segment by k positions\n    if i < j:\n        segment = new_solution[i:j]\n        rotated = np.roll(segment, k % len(segment))\n        new_solution[i:j] = rotated\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            8.805711853400476,
            8.368887678359602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine node insertion with segment rotation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Node insertion: move node i to position j\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Segment rotation: rotate a random segment by k positions\n    if i < j:\n        segment = new_solution[i:j]\n        rotated = np.roll(segment, k % len(segment))\n        new_solution[i:j] = rotated\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.318964386223638,
            6.297667744348535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.318964386223638,
            6.297667744348535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.301326944231567,
            7.222015579617734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.301326944231567,
            7.222015579617734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The algorithm selects a solution from the archive based on the combined distance improvement potential across both objectives, then applies a novel hybrid local search combining multi-swap operations and adaptive segment relocations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.sum(np.abs(objectives - np.min(objectives, axis=0)), axis=1)\n    selected_idx = np.random.choice(len(archive), p=improvement_potential/np.sum(improvement_potential))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-swap operation\n    k = np.random.randint(2, min(5, N//2))\n    indices = np.random.choice(N, size=k*2, replace=False).reshape(k, 2)\n    for i, j in indices:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment relocation\n    if N > 4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.964845938368436,
            7.879993667317967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.sum(np.abs(objectives - np.min(objectives, axis=0)), axis=1)\n    selected_idx = np.random.choice(len(archive), p=improvement_potential/np.sum(improvement_potential))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Multi-swap operation\n    k = np.random.randint(2, min(5, N//2))\n    indices = np.random.choice(N, size=k*2, replace=False).reshape(k, 2)\n    for i, j in indices:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive segment relocation\n    if N > 4:\n        a, b, c = sorted(np.random.choice(N, size=3, replace=False))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel segment-based local search strategy that combines edge insertions and segment rotations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection considering both objectives and diversity\n    objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    diversity = np.array([np.std([distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)]) for sol, _ in archive])\n    weights = objectives + diversity\n    weights = np.max(weights) - weights + 1e-6\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel segment-based local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Randomly insert a node at a different position\n    if N > 3:\n        i = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(N-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.978528763413378,
            6.6055048283466755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection considering both objectives and diversity\n    objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    diversity = np.array([np.std([distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)]) for sol, _ in archive])\n    weights = objectives + diversity\n    weights = np.max(weights) - weights + 1e-6\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel segment-based local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Randomly insert a node at a different position\n    if N > 3:\n        i = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(N-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive using a non-linear scoring function that prioritizes solutions with balanced objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a non-linear scoring function\n    scores = []\n    for _, obj in archive:\n        score = (obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-6)  # Harmonic mean-like scoring\n        scores.append(score)\n    scores = np.array(scores)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_len = min(3, N-1)\n    a = np.random.randint(0, N-segment_len)\n    b = a + segment_len\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap with probability based on objective balance\n    obj_balance = archive[selected_idx][1][0] / (archive[selected_idx][1][1] + 1e-6)\n    swap_prob = min(0.7, max(0.3, 1 - abs(obj_balance - 1)))\n    if np.random.random() < swap_prob and N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.5551484341066875,
            6.92636456168192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a non-linear scoring function\n    scores = []\n    for _, obj in archive:\n        score = (obj[0] * obj[1]) / (obj[0] + obj[1] + 1e-6)  # Harmonic mean-like scoring\n        scores.append(score)\n    scores = np.array(scores)\n    selected_idx = np.random.choice(len(archive), p=scores/np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_len = min(3, N-1)\n    a = np.random.randint(0, N-segment_len)\n    b = a + segment_len\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge swap with probability based on objective balance\n    obj_balance = archive[selected_idx][1][0] / (archive[selected_idx][1][1] + 1e-6)\n    swap_prob = min(0.7, max(0.3, 1 - abs(obj_balance - 1)))\n    if np.random.random() < swap_prob and N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment inversion: reverse a random segment\n    if k > i:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment relocation: move a random segment to a new position\n    if k > i:\n        segment = new_solution[i:k]\n        new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
        "score": [
            9.203473216052098,
            9.121370972124382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment relocation\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Edge exchange: swap edges between nodes i and j\n    if i != j:\n        new_solution[[i, j]] = new_solution[[j, i]]\n\n    # Segment relocation: move a random segment to a new position\n    if k > i:\n        segment = new_solution[i:k]\n        new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    # Ensure validity by checking for duplicates\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{The algorithm selects a solution from the archive using a diversity-aware selection strategy, then applies a hybrid local search combining node insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with highest diversity (max sum of distances)\n    diversity_scores = []\n    for sol, _ in archive:\n        total_dist = 0\n        for i in range(len(sol)-1):\n            total_dist += distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]]\n        diversity_scores.append(total_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to reinsert\n    if N > 2:\n        node_idx = np.random.randint(1, N-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(1, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly reverse a segment of size 2-3\n    if N > 3:\n        seg_size = np.random.randint(2, 4)\n        start = np.random.randint(0, N-seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.442082656192591,
            10.54308769484867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with highest diversity (max sum of distances)\n    diversity_scores = []\n    for sol, _ in archive:\n        total_dist = 0\n        for i in range(len(sol)-1):\n            total_dist += distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]]\n        diversity_scores.append(total_dist)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a node to reinsert\n    if N > 2:\n        node_idx = np.random.randint(1, N-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(1, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Randomly reverse a segment of size 2-3\n    if N > 3:\n        seg_size = np.random.randint(2, 4)\n        start = np.random.randint(0, N-seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{The algorithm selects a solution with the best trade-off between the two objectives using a weighted sum, then applies a novel local search operator combining segment rotations and edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using segment rotation and edge insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Randomly insert an edge between two non-adjacent nodes\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        while abs(i - j) == 1 or abs(i - j) == N - 1:\n            i, j = np.random.choice(N, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i+1:j] = new_solution[i:j-1][::-1]\n\n    # Ensure the solution is feasible\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.7254534766786,
            8.430701229799578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using segment rotation and edge insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    k = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Randomly insert an edge between two non-adjacent nodes\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        while abs(i - j) == 1 or abs(i - j) == N - 1:\n            i, j = np.random.choice(N, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i+1:j] = new_solution[i:j-1][::-1]\n\n    # Ensure the solution is feasible\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.297973162170725,
            6.433642942613873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.297973162170725,
            6.433642942613873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm selects a solution from the archive based on crowding distance in non-dominated fronts, then applies a hybrid local search operator combining edge swaps with adaptive path relinking to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Calculate crowding distance for non-dominated solutions\n        crowding_distances = []\n        for idx in fronts:\n            sol, obj = archive[idx]\n            distances = []\n            for j in fronts:\n                if j != idx:\n                    d1 = abs(archive[j][1][0] - obj[0])\n                    d2 = abs(archive[j][1][1] - obj[1])\n                    distances.append(np.sqrt(d1**2 + d2**2))\n            if distances:\n                crowding_distances.append(np.mean(distances))\n            else:\n                crowding_distances.append(float('inf'))\n\n        selected_idx = fronts[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge swap with adaptive path relinking\n    a, b = np.random.choice(N, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Edge swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive path relinking\n    if np.random.random() < 0.3:\n        c, d = np.random.choice(N, 2, replace=False)\n        if c > d:\n            c, d = d, c\n        segment = new_solution[c:d+1]\n        insert_pos = np.random.randint(0, N - len(segment) + 1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.323527987479229,
            7.0977510364034275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Calculate crowding distance for non-dominated solutions\n        crowding_distances = []\n        for idx in fronts:\n            sol, obj = archive[idx]\n            distances = []\n            for j in fronts:\n                if j != idx:\n                    d1 = abs(archive[j][1][0] - obj[0])\n                    d2 = abs(archive[j][1][1] - obj[1])\n                    distances.append(np.sqrt(d1**2 + d2**2))\n            if distances:\n                crowding_distances.append(np.mean(distances))\n            else:\n                crowding_distances.append(float('inf'))\n\n        selected_idx = fronts[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: edge swap with adaptive path relinking\n    a, b = np.random.choice(N, 2, replace=False)\n    if a > b:\n        a, b = b, a\n\n    # Edge swap\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive path relinking\n    if np.random.random() < 0.3:\n        c, d = np.random.choice(N, 2, replace=False)\n        if c > d:\n            c, d = d, c\n        segment = new_solution[c:d+1]\n        insert_pos = np.random.randint(0, N - len(segment) + 1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:]])\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of crowding distance and dominance, then applies a novel local search operator that combines node relocation with path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: combine dominance and crowding distance\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        # Calculate crowding distance for non-dominated solutions\n        objectives = np.array([archive[i][1] for i in non_dominated_indices])\n        crowding = np.zeros(len(non_dominated_indices))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated_indices)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = non_dominated_indices[np.argmax(crowding)]\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node relocation with path inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        start = np.random.randint(0, N-2)\n        end = np.random.randint(start+1, N)\n        segment = new_solution[start:end]\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(start, end))\n\n        # Insert the segment at a new random position\n        insert_pos = np.random.randint(0, N-(end-start))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Invert the relocated segment with probability 0.5\n        if np.random.rand() < 0.5:\n            new_solution[insert_pos:insert_pos+len(segment)] = new_solution[insert_pos:insert_pos+len(segment)][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.866148200373422,
            8.15002771713801
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: combine dominance and crowding distance\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        # Calculate crowding distance for non-dominated solutions\n        objectives = np.array([archive[i][1] for i in non_dominated_indices])\n        crowding = np.zeros(len(non_dominated_indices))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated_indices)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = non_dominated_indices[np.argmax(crowding)]\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node relocation with path inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        start = np.random.randint(0, N-2)\n        end = np.random.randint(start+1, N)\n        segment = new_solution[start:end]\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(start, end))\n\n        # Insert the segment at a new random position\n        insert_pos = np.random.randint(0, N-(end-start))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Invert the relocated segment with probability 0.5\n        if np.random.rand() < 0.5:\n            new_solution[insert_pos:insert_pos+len(segment)] = new_solution[insert_pos:insert_pos+len(segment)][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.723328986566678,
            6.126496113043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.723328986566678,
            6.126496113043
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search operator that combines a novel path inversion with adaptive node swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance (less explored region)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: path inversion with adaptive node swaps\n    if N > 3:\n        # Select a random segment to invert\n        start = np.random.randint(0, N-2)\n        end = np.random.randint(start+1, N)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform adaptive node swaps\n        for _ in range(np.random.randint(1, 3)):\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.18646491295013,
            9.108875081088295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance (less explored region)\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: path inversion with adaptive node swaps\n    if N > 3:\n        # Select a random segment to invert\n        start = np.random.randint(0, N-2)\n        end = np.random.randint(start+1, N)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform adaptive node swaps\n        for _ in range(np.random.randint(1, 3)):\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify less crowded regions of the Pareto front, then applies a novel local search operator that combines node swapping with adaptive path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    fronts = [[]]\n    fronts[0] = list(range(len(archive)))\n    crowding_distance = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distance[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance (less crowded region)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive node swapping with path inversion\n    if N > 3:\n        # Select two random nodes\n        i, j = np.random.choice(N, 2, replace=False)\n\n        # Swap the nodes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Invert a segment between the swapped nodes\n        if i < j:\n            start, end = i, j\n        else:\n            start, end = j, i\n\n        if end - start > 1:\n            segment_length = np.random.randint(1, end - start)\n            segment_start = np.random.randint(start, end - segment_length + 1)\n            new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.300185887529727,
            6.831936311174791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    fronts = [[]]\n    fronts[0] = list(range(len(archive)))\n    crowding_distance = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distance[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance (less crowded region)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive node swapping with path inversion\n    if N > 3:\n        # Select two random nodes\n        i, j = np.random.choice(N, 2, replace=False)\n\n        # Swap the nodes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Invert a segment between the swapped nodes\n        if i < j:\n            start, end = i, j\n        else:\n            start, end = j, i\n\n        if end - start > 1:\n            segment_length = np.random.randint(1, end - start)\n            segment_start = np.random.randint(start, end - segment_length + 1)\n            new_solution[segment_start:segment_start+segment_length] = new_solution[segment_start:segment_start+segment_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection to prioritize solutions in less crowded regions of the Pareto front, then applies a hybrid local search operator that combines adaptive segment inversions with dynamic edge swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, obj_i in enumerate(objectives):\n        for j, obj_j in enumerate(objectives):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Calculate crowding distance for non-dominated solutions\n        crowding_distances = np.zeros(len(fronts))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[fronts, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(fronts)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[fronts[sorted_idx[i+1]], m] - objectives[fronts[sorted_idx[i-1]], m]) / (objectives[fronts[sorted_idx[-1]], m] - objectives[fronts[sorted_idx[0]], m] + 1e-6)\n\n        selected_idx = fronts[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and dynamic edge swap\n    if N > 3:\n        # Adaptive segment inversion\n        k = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - k)\n        segment = new_solution[start:start+k]\n        new_solution[start:start+k] = segment[::-1]\n\n        # Dynamic edge swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        if abs(i - j) > 1 and abs(i - j) < N - 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.578729048107741,
            8.169496732443246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, obj_i in enumerate(objectives):\n        for j, obj_j in enumerate(objectives):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Calculate crowding distance for non-dominated solutions\n        crowding_distances = np.zeros(len(fronts))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[fronts, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(fronts)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[fronts[sorted_idx[i+1]], m] - objectives[fronts[sorted_idx[i-1]], m]) / (objectives[fronts[sorted_idx[-1]], m] - objectives[fronts[sorted_idx[0]], m] + 1e-6)\n\n        selected_idx = fronts[np.argmax(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion and dynamic edge swap\n    if N > 3:\n        # Adaptive segment inversion\n        k = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - k)\n        segment = new_solution[start:start+k]\n        new_solution[start:start+k] = segment[::-1]\n\n        # Dynamic edge swap\n        i, j = np.random.choice(N, size=2, replace=False)\n        if abs(i - j) > 1 and abs(i - j) < N - 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Novel local search operator: Adaptive segment reversal with edge swapping\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[start:start+k] = reversed_segment\n\n    # Edge swapping within the segment\n    if k > 2:\n        swap_pos = np.random.randint(1, k-1)\n        new_solution[start+swap_pos], new_solution[start+swap_pos+1] = new_solution[start+swap_pos+1], new_solution[start+swap_pos]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.409685544612718,
            7.018336755346663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Novel local search operator: Adaptive segment reversal with edge swapping\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[start:start+k] = reversed_segment\n\n    # Edge swapping within the segment\n    if k > 2:\n        swap_pos = np.random.randint(1, k-1)\n        new_solution[start+swap_pos], new_solution[start+swap_pos+1] = new_solution[start+swap_pos+1], new_solution[start+swap_pos]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search operator that combines segment inversions with adaptive edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    selected_idx = np.random.choice(np.argsort(-crowding_distances)[:max(1, len(archive)//3)])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment inversion\n    k = np.random.randint(2, min(4, N//3))\n    start = np.random.randint(0, N - k)\n    new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Edge swap with adaptive selection\n    i, j = np.random.choice(N, 2, replace=False)\n    if abs(i - j) > 1 and abs(i - j) < N - 1:\n        if np.random.rand() < 0.7:  # Higher probability for edge swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.009771485554832,
            7.2801867560129985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m] + 1e-10)\n\n    selected_idx = np.random.choice(np.argsort(-crowding_distances)[:max(1, len(archive)//3)])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment inversion\n    k = np.random.randint(2, min(4, N//3))\n    start = np.random.randint(0, N - k)\n    new_solution[start:start+k] = new_solution[start:start+k][::-1]\n\n    # Edge swap with adaptive selection\n    i, j = np.random.choice(N, 2, replace=False)\n    if abs(i - j) > 1 and abs(i - j) < N - 1:\n        if np.random.rand() < 0.7:  # Higher probability for edge swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective ranking, then applies a hybrid local search combining adaptive segment relocations with probabilistic edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using diversity-aware ranking\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        ranks[sorted_idx] += np.arange(len(archive))\n\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation with probabilistic edge insertion\n    if N > 3:\n        # Select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        seg_start = np.random.randint(0, N - seg_length)\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Find best insertion point\n        best_insert = 0\n        best_gain = 0\n        for i in range(N - seg_length + 1):\n            if i == seg_start:\n                continue\n\n            # Calculate gain for first objective\n            old_cost = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                        distance_matrix_1[new_solution[seg_start+seg_length-1], new_solution[(seg_start+seg_length)%N]])\n            new_cost = (distance_matrix_1[new_solution[seg_start-1], new_solution[(seg_start+seg_length)%N]] +\n                        distance_matrix_1[new_solution[i-1], segment[0]] +\n                        distance_matrix_1[segment[-1], new_solution[i]])\n\n            # Calculate gain for second objective\n            old_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                         distance_matrix_2[new_solution[seg_start+seg_length-1], new_solution[(seg_start+seg_length)%N]])\n            new_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[(seg_start+seg_length)%N]] +\n                         distance_matrix_2[new_solution[i-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[i]])\n\n            # Combined gain\n            gain = (new_cost - old_cost) + (new_cost2 - old_cost2)\n\n            if gain < best_gain:\n                best_gain = gain\n                best_insert = i\n\n        # Perform insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert],\n            segment,\n            new_solution[best_insert:]\n        ])[:N]\n\n        # With 30% probability, perform edge insertion\n        if np.random.random() < 0.3 and N > 4:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                [new_solution[j]],\n                new_solution[i+1:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.635130087203219,
            9.437754291567353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using diversity-aware ranking\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        ranks[sorted_idx] += np.arange(len(archive))\n\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Hybrid local search: adaptive segment relocation with probabilistic edge insertion\n    if N > 3:\n        # Select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        seg_start = np.random.randint(0, N - seg_length)\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Find best insertion point\n        best_insert = 0\n        best_gain = 0\n        for i in range(N - seg_length + 1):\n            if i == seg_start:\n                continue\n\n            # Calculate gain for first objective\n            old_cost = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                        distance_matrix_1[new_solution[seg_start+seg_length-1], new_solution[(seg_start+seg_length)%N]])\n            new_cost = (distance_matrix_1[new_solution[seg_start-1], new_solution[(seg_start+seg_length)%N]] +\n                        distance_matrix_1[new_solution[i-1], segment[0]] +\n                        distance_matrix_1[segment[-1], new_solution[i]])\n\n            # Calculate gain for second objective\n            old_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                         distance_matrix_2[new_solution[seg_start+seg_length-1], new_solution[(seg_start+seg_length)%N]])\n            new_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[(seg_start+seg_length)%N]] +\n                         distance_matrix_2[new_solution[i-1], segment[0]] +\n                         distance_matrix_2[segment[-1], new_solution[i]])\n\n            # Combined gain\n            gain = (new_cost - old_cost) + (new_cost2 - old_cost2)\n\n            if gain < best_gain:\n                best_gain = gain\n                best_insert = i\n\n        # Perform insertion\n        new_solution = np.concatenate([\n            new_solution[:best_insert],\n            segment,\n            new_solution[best_insert:]\n        ])[:N]\n\n        # With 30% probability, perform edge insertion\n        if np.random.random() < 0.3 and N > 4:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                [new_solution[j]],\n                new_solution[i+1:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and distance improvements, then applies a hybrid local search operator that combines node insertion with path segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        i, j = np.random.choice(N, 2, replace=False)\n        node_to_insert = new_solution[j]\n\n        new_solution = np.delete(new_solution, j)\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        start, end = sorted([i, insert_pos])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.288014991198866,
            6.246431321142923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        i, j = np.random.choice(N, 2, replace=False)\n        node_to_insert = new_solution[j]\n\n        new_solution = np.delete(new_solution, j)\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        start, end = sorted([i, insert_pos])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and distance improvements, then applies a hybrid local search operator that combines node insertion with path segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        i, j = np.random.choice(N, 2, replace=False)\n        node_to_insert = new_solution[j]\n\n        new_solution = np.delete(new_solution, j)\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        start, end = sorted([i, insert_pos])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.288014991198866,
            6.246431321142923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        i, j = np.random.choice(N, 2, replace=False)\n        node_to_insert = new_solution[j]\n\n        new_solution = np.delete(new_solution, j)\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        start, end = sorted([i, insert_pos])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid of dominance rank and objective-space diversity, then applies a novel local search operator that combines adaptive segment relocations with conditional path inversions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric: dominance rank + objective-space diversity\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    # Calculate dominance ranks\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                ranks[i] += 1\n\n    # Calculate objective-space diversity\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity[i] = np.sum(np.abs(objectives[i] - np.mean(objectives, axis=0)))\n\n    # Combine metrics (lower rank + higher diversity preferred)\n    selection_metric = ranks - 0.5 * diversity\n    selected_idx = np.argmin(selection_metric)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation with conditional inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while abs(j - i) < 2:\n        j = np.random.randint(0, N)\n\n    start, end = sorted([i, j])\n    segment = new_solution[start:end+1]\n\n    # Conditional inversion based on objective improvement\n    obj1_before = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n    obj2_before = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n\n    # Try inversion\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    obj1_after = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n    obj2_after = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n\n    # Accept if at least one objective improves\n    if not ((obj1_after < obj1_before) or (obj2_after < obj2_before)):\n        new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.465398853819018,
            10.600992859608718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric: dominance rank + objective-space diversity\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n\n    # Calculate dominance ranks\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                ranks[i] += 1\n\n    # Calculate objective-space diversity\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity[i] = np.sum(np.abs(objectives[i] - np.mean(objectives, axis=0)))\n\n    # Combine metrics (lower rank + higher diversity preferred)\n    selection_metric = ranks - 0.5 * diversity\n    selected_idx = np.argmin(selection_metric)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation with conditional inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while abs(j - i) < 2:\n        j = np.random.randint(0, N)\n\n    start, end = sorted([i, j])\n    segment = new_solution[start:end+1]\n\n    # Conditional inversion based on objective improvement\n    obj1_before = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n    obj2_before = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n\n    # Try inversion\n    inverted_segment = segment[::-1]\n    new_solution[start:end+1] = inverted_segment\n\n    obj1_after = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n    obj2_after = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%N]] for k in range(N))\n\n    # Accept if at least one objective improves\n    if not ((obj1_after < obj1_before) or (obj2_after < obj2_before)):\n        new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search operator combining node insertion with a limited 2-opt move to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_scores = weights * normalized_scores[:, 0] + (1 - weights) * normalized_scores[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search: node insertion with limited 2-opt\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to relocate\n        node_idx = np.random.randint(0, N)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node in a random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Apply limited 2-opt: reverse a small segment around the insertion point\n        segment_size = min(3, N - 2)\n        start = max(0, insert_pos - segment_size // 2)\n        end = min(N - 1, insert_pos + segment_size // 2)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.60067908108461,
            6.569771381562268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = objectives.min(axis=0)\n    max_vals = objectives.max(axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_scores = weights * normalized_scores[:, 0] + (1 - weights) * normalized_scores[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search: node insertion with limited 2-opt\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to relocate\n        node_idx = np.random.randint(0, N)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node in a random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Apply limited 2-opt: reverse a small segment around the insertion point\n        segment_size = min(3, N - 2)\n        start = max(0, insert_pos - segment_size // 2)\n        end = min(N - 1, insert_pos + segment_size // 2)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamic weighted combination of normalized objective values, then applies a hybrid local search that combines node insertion with path segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better dynamic weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_scores = weights * normalized_obj[:, 0] + (1 - weights) * normalized_obj[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search: node insertion with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select three nodes\n        i, j, k = np.random.choice(N, 3, replace=False)\n\n        # Insert node k between nodes i and j\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:j], new_solution[j+1:]])\n\n        # Reverse a random segment\n        start = np.random.randint(0, N-1)\n        end = np.random.randint(start+1, N)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.743096553381154,
            9.12028976851429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better dynamic weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.4, 0.6)\n    weighted_scores = weights * normalized_obj[:, 0] + (1 - weights) * normalized_obj[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search: node insertion with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select three nodes\n        i, j, k = np.random.choice(N, 3, replace=False)\n\n        # Insert node k between nodes i and j\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[k]], new_solution[i+1:j], new_solution[j+1:]])\n\n        # Reverse a random segment\n        start = np.random.randint(0, N-1)\n        end = np.random.randint(start+1, N)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.031024429137359,
            6.175923263307726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.031024429137359,
            6.175923263307726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective metric that combines normalized objective values with a diversity measure, then applies a novel local search operator that combines node insertion with adaptive path segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric: combine normalized objectives with diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.std(norm_objectives, axis=0)\n    hybrid_scores = np.sum(norm_objectives * diversity, axis=1)\n    selected_idx = np.argmin(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with adaptive rotation\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Select a random node to insert\n        node_to_insert = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_insert]\n\n        # Randomly select insertion position\n        insert_pos = np.random.randint(0, N-1)\n\n        # Insert the node\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Rotate a random segment around the inserted node\n        rotation_size = np.random.randint(1, min(5, N//2))\n        start = max(0, insert_pos - rotation_size)\n        end = min(N-1, insert_pos + rotation_size)\n        segment = new_solution[start:end+1]\n\n        # Adaptive rotation based on objective improvement\n        obj1_before = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        obj2_before = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n        obj1_after = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        obj2_after = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n        # Revert if rotation doesn't improve both objectives\n        if (obj1_after > obj1_before and obj2_after > obj2_before):\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.675923991671971,
            6.4326091010033215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric: combine normalized objectives with diversity\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity = np.std(norm_objectives, axis=0)\n    hybrid_scores = np.sum(norm_objectives * diversity, axis=1)\n    selected_idx = np.argmin(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with adaptive rotation\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Select a random node to insert\n        node_to_insert = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_insert]\n\n        # Randomly select insertion position\n        insert_pos = np.random.randint(0, N-1)\n\n        # Insert the node\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Rotate a random segment around the inserted node\n        rotation_size = np.random.randint(1, min(5, N//2))\n        start = max(0, insert_pos - rotation_size)\n        end = min(N-1, insert_pos + rotation_size)\n        segment = new_solution[start:end+1]\n\n        # Adaptive rotation based on objective improvement\n        obj1_before = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        obj2_before = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n        rotated_segment = np.roll(segment, 1)\n        new_solution[start:end+1] = rotated_segment\n\n        obj1_after = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        obj2_after = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n        # Revert if rotation doesn't improve both objectives\n        if (obj1_after > obj1_before and obj2_after > obj2_before):\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel hybrid metric combining objective values and diversity, then applies a novel local search operator that combines node insertion with adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n\n    # Add diversity component\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                diversity[i] += np.sum(archive[i][0] != archive[j][0])\n\n    hybrid_scores = weighted_scores + 0.2 * diversity\n    selected_idx = np.argmin(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with adaptive reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select three distinct nodes\n        i, j, k = np.random.choice(N, 3, replace=False)\n\n        # Insert node j after node i\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            [new_solution[j]],\n            new_solution[i+1:j],\n            new_solution[j+1:]\n        ])\n\n        # Adaptively reverse segment between k and the new position of j\n        new_pos_j = np.where(new_solution == base_solution[j])[0][0]\n        start, end = sorted([k, new_pos_j])\n\n        if end - start > 1:\n            if np.random.rand() < 0.5:  # 50% chance to reverse\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.49047634663068,
            8.010536998008316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n\n    # Add diversity component\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                diversity[i] += np.sum(archive[i][0] != archive[j][0])\n\n    hybrid_scores = weighted_scores + 0.2 * diversity\n    selected_idx = np.argmin(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with adaptive reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select three distinct nodes\n        i, j, k = np.random.choice(N, 3, replace=False)\n\n        # Insert node j after node i\n        new_solution = np.concatenate([\n            new_solution[:i+1],\n            [new_solution[j]],\n            new_solution[i+1:j],\n            new_solution[j+1:]\n        ])\n\n        # Adaptively reverse segment between k and the new position of j\n        new_pos_j = np.where(new_solution == base_solution[j])[0][0]\n        start, end = sorted([k, new_pos_j])\n\n        if end - start > 1:\n            if np.random.rand() < 0.5:  # 50% chance to reverse\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of diversity and objective improvement, then applies a novel local search operator that combines partial path relocation with adaptive segment swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: combine diversity and objective improvement\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    improvement_scores = 1 / (1 + np.sum(objectives, axis=1))\n    combined_scores = 0.6 * diversity_scores + 0.4 * improvement_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: partial path relocation with adaptive segment swaps\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        segment_size = np.random.randint(2, min(5, N-1))\n        start = np.random.randint(0, N - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Find a new position for the segment\n        new_pos = np.random.randint(0, N - segment_size)\n        while abs(new_pos - start) < segment_size:\n            new_pos = np.random.randint(0, N - segment_size)\n\n        # Remove the segment and insert it at the new position\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Adaptive segment swap\n        swap_start = np.random.randint(0, N - segment_size)\n        swap_end = swap_start + segment_size\n        if swap_end < N:\n            new_solution[swap_start:swap_end] = new_solution[swap_start:swap_end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.411916344262037,
            10.612319808283154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: combine diversity and objective improvement\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    improvement_scores = 1 / (1 + np.sum(objectives, axis=1))\n    combined_scores = 0.6 * diversity_scores + 0.4 * improvement_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: partial path relocation with adaptive segment swaps\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        segment_size = np.random.randint(2, min(5, N-1))\n        start = np.random.randint(0, N - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Find a new position for the segment\n        new_pos = np.random.randint(0, N - segment_size)\n        while abs(new_pos - start) < segment_size:\n            new_pos = np.random.randint(0, N - segment_size)\n\n        # Remove the segment and insert it at the new position\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Adaptive segment swap\n        swap_start = np.random.randint(0, N - segment_size)\n        swap_end = swap_start + segment_size\n        if swap_end < N:\n            new_solution[swap_start:swap_end] = new_solution[swap_start:swap_end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator that combines multi-segment reversals with adaptive node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using multi-segment reversal with adaptive insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Randomly select multiple segments to reverse\n        num_segments = np.random.randint(1, min(3, N//2))\n        segments = []\n        for _ in range(num_segments):\n            start = np.random.randint(0, N-1)\n            end = np.random.randint(start+1, min(start+3, N))\n            segments.append((start, end))\n\n        # Apply reversals\n        for start, end in segments:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.752625469931836,
            7.207532138370265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using multi-segment reversal with adaptive insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Randomly select multiple segments to reverse\n        num_segments = np.random.randint(1, min(3, N//2))\n        segments = []\n        for _ in range(num_segments):\n            start = np.random.randint(0, N-1)\n            end = np.random.randint(start+1, min(start+3, N))\n            segments.append((start, end))\n\n        # Apply reversals\n        for start, end in segments:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator that combines multi-segment reversals with adaptive node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using multi-segment reversal with adaptive insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Randomly select multiple segments to reverse\n        num_segments = np.random.randint(1, min(3, N//2))\n        segments = []\n        for _ in range(num_segments):\n            start = np.random.randint(0, N-1)\n            end = np.random.randint(start+1, min(start+3, N))\n            segments.append((start, end))\n\n        # Apply reversals\n        for start, end in segments:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.752625469931836,
            7.207532138370265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using multi-segment reversal with adaptive insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Randomly select multiple segments to reverse\n        num_segments = np.random.randint(1, min(3, N//2))\n        segments = []\n        for _ in range(num_segments):\n            start = np.random.randint(0, N-1)\n            end = np.random.randint(start+1, min(start+3, N))\n            segments.append((start, end))\n\n        # Apply reversals\n        for start, end in segments:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective value in either space, then applies a hybrid local search combining edge swaps with a probabilistic segment reversal to generate diverse neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with the worst objective in either space\n    objectives = np.array([obj for (_, obj) in archive])\n    worst_idx = np.argmax(np.max(objectives, axis=1))\n    base_solution = archive[worst_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Hybrid local search: edge swaps with probabilistic segment reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge swaps\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.4:\n            c, d = np.random.choice(N, 2, replace=False)\n            c, d = sorted([c, d])\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.482928964338084,
            10.536110993966695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with the worst objective in either space\n    objectives = np.array([obj for (_, obj) in archive])\n    worst_idx = np.argmax(np.max(objectives, axis=1))\n    base_solution = archive[worst_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Hybrid local search: edge swaps with probabilistic segment reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge swaps\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.4:\n            c, d = np.random.choice(N, 2, replace=False)\n            c, d = sorted([c, d])\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.496002494185099,
            8.748965748650448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.496002494185099,
            8.748965748650448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines adaptive segment swaps with dynamic edge flips to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_dist = np.zeros(len(archive))\n    for obj_idx in [0, 1]:\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n\n        if len(archive) > 2:\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment swap with dynamic edge flips\n    k = np.random.randint(2, min(6, N//2))\n    start1 = np.random.randint(0, N - k)\n    segment1 = new_solution[start1:start1+k]\n\n    start2 = np.random.randint(0, N - k)\n    segment2 = new_solution[start2:start2+k]\n\n    # Swap segments\n    new_solution = np.concatenate([new_solution[:start1], segment2, new_solution[start1+k:]])\n    new_solution = np.concatenate([new_solution[:start2], segment1, new_solution[start2+k:]])\n\n    # Dynamic edge flips\n    if np.random.random() < 0.5:\n        flip_pos = np.random.randint(0, N - 1)\n        new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.485188380422736,
            8.14706089231399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    crowding_dist = np.zeros(len(archive))\n    for obj_idx in [0, 1]:\n        sorted_idx = np.argsort(objectives[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = crowding_dist[sorted_idx[-1]] = np.inf\n\n        if len(archive) > 2:\n            for i in range(1, len(archive)-1):\n                crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], obj_idx] - objectives[sorted_idx[i-1], obj_idx]) / (objectives[sorted_idx[-1], obj_idx] - objectives[sorted_idx[0], obj_idx] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment swap with dynamic edge flips\n    k = np.random.randint(2, min(6, N//2))\n    start1 = np.random.randint(0, N - k)\n    segment1 = new_solution[start1:start1+k]\n\n    start2 = np.random.randint(0, N - k)\n    segment2 = new_solution[start2:start2+k]\n\n    # Swap segments\n    new_solution = np.concatenate([new_solution[:start1], segment2, new_solution[start1+k:]])\n    new_solution = np.concatenate([new_solution[:start2], segment1, new_solution[start2+k:]])\n\n    # Dynamic edge flips\n    if np.random.random() < 0.5:\n        flip_pos = np.random.randint(0, N - 1)\n        new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and diversity, then applies a novel local search operator that combines segment relocations with adaptive edge flips to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select based on diversity\n        selected_idx = np.argmin(np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1))\n    else:\n        # Select from non-dominated front with preference for less crowded regions\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Novel local search: segment relocation with adaptive edge flips\n    if N < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to relocate\n        seg_start = np.random.randint(0, N-2)\n        seg_end = np.random.randint(seg_start+1, N-1)\n\n        # Select a new position for the segment\n        new_pos = np.random.randint(0, N)\n        while new_pos >= seg_start and new_pos <= seg_end:\n            new_pos = np.random.randint(0, N)\n\n        # Extract and relocate the segment\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Adaptive edge flip: flip edges based on objective improvement\n        for _ in range(2):  # Limit flips to maintain efficiency\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n\n            # Calculate current and flipped costs\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            flipped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flipped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept flip if it improves at least one objective\n            if (flipped_cost1 < current_cost1) or (flipped_cost2 < current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.093326383566335,
            6.444872909250904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select based on diversity\n        selected_idx = np.argmin(np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1))\n    else:\n        # Select from non-dominated front with preference for less crowded regions\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Novel local search: segment relocation with adaptive edge flips\n    if N < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to relocate\n        seg_start = np.random.randint(0, N-2)\n        seg_end = np.random.randint(seg_start+1, N-1)\n\n        # Select a new position for the segment\n        new_pos = np.random.randint(0, N)\n        while new_pos >= seg_start and new_pos <= seg_end:\n            new_pos = np.random.randint(0, N)\n\n        # Extract and relocate the segment\n        segment = new_solution[seg_start:seg_end+1]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Adaptive edge flip: flip edges based on objective improvement\n        for _ in range(2):  # Limit flips to maintain efficiency\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n\n            # Calculate current and flipped costs\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            flipped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flipped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept flip if it improves at least one objective\n            if (flipped_cost1 < current_cost1) or (flipped_cost2 < current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and diversity, then applies a novel local search operator that combines segment relinking with adaptive node swapping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    diversity_scores = np.zeros(len(archive))\n\n    # Calculate diversity scores based on distance to other solutions\n    for i in range(len(archive)):\n        distances = []\n        for j in range(len(archive)):\n            if i != j:\n                # Calculate Hamming distance between solutions\n                diff = np.sum(archive[i][0] != archive[j][0])\n                distances.append(diff)\n        diversity_scores[i] = np.mean(distances) if distances else 0\n\n    # Combine objective and diversity scores\n    combined_scores = 0.6 * np.sum(normalized_obj, axis=1) + 0.4 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment relinking with adaptive node swapping\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Relink segments\n        segment = new_solution[a:b]\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        for i in range(a, b):\n            if np.random.random() < 0.2:  # 20% chance to swap\n                j = np.random.randint(a, b)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.304936739574213,
            6.295186945409561
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection strategy: combine objective improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    diversity_scores = np.zeros(len(archive))\n\n    # Calculate diversity scores based on distance to other solutions\n    for i in range(len(archive)):\n        distances = []\n        for j in range(len(archive)):\n            if i != j:\n                # Calculate Hamming distance between solutions\n                diff = np.sum(archive[i][0] != archive[j][0])\n                distances.append(diff)\n        diversity_scores[i] = np.mean(distances) if distances else 0\n\n    # Combine objective and diversity scores\n    combined_scores = 0.6 * np.sum(normalized_obj, axis=1) + 0.4 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment relinking with adaptive node swapping\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Relink segments\n        segment = new_solution[a:b]\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Adaptive node swapping\n        for i in range(a, b):\n            if np.random.random() < 0.2:  # 20% chance to swap\n                j = np.random.randint(a, b)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The algorithm selects a solution from the archive based on a hybrid selection criterion combining objective dominance and diversity, then applies a novel local search operator that combines adaptive 2-opt with segment relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion: combine dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    N = len(archive)\n\n    # Calculate dominance ranks\n    dominance_rank = np.zeros(N)\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominance_rank[i] += 1\n\n    # Calculate diversity metric (average distance to other solutions in objective space)\n    diversity = np.zeros(N)\n    for i in range(N):\n        distances = np.sqrt((objectives[i, 0] - objectives[:, 0])**2 + (objectives[i, 1] - objectives[:, 1])**2)\n        diversity[i] = np.mean(distances)\n\n    # Combine metrics (lower dominance rank and higher diversity preferred)\n    selection_score = dominance_rank - 0.5 * diversity\n    selected_idx = np.argmin(selection_score)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive 2-opt with segment relinking\n    N = len(new_solution)\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to relink\n    start, end = sorted([i, j])\n    segment = new_solution[start:end+1]\n\n    # Find best insertion point in remaining tour\n    best_cost = float('inf')\n    best_pos = -1\n    remaining_nodes = np.setdiff1d(np.arange(N), segment)\n\n    for pos in range(len(remaining_nodes)):\n        # Try inserting segment at different positions\n        for k in range(len(remaining_nodes)-len(segment)+1):\n            candidate = np.concatenate([\n                new_solution[:start],\n                segment,\n                new_solution[start:end],\n                new_solution[end:]\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = k\n\n    if best_pos != -1:\n        # Apply the best found relinking\n        new_solution = np.concatenate([\n            new_solution[:start],\n            segment,\n            new_solution[start:end],\n            new_solution[end:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.480761509835506,
            10.685825449837782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion: combine dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    N = len(archive)\n\n    # Calculate dominance ranks\n    dominance_rank = np.zeros(N)\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominance_rank[i] += 1\n\n    # Calculate diversity metric (average distance to other solutions in objective space)\n    diversity = np.zeros(N)\n    for i in range(N):\n        distances = np.sqrt((objectives[i, 0] - objectives[:, 0])**2 + (objectives[i, 1] - objectives[:, 1])**2)\n        diversity[i] = np.mean(distances)\n\n    # Combine metrics (lower dominance rank and higher diversity preferred)\n    selection_score = dominance_rank - 0.5 * diversity\n    selected_idx = np.argmin(selection_score)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive 2-opt with segment relinking\n    N = len(new_solution)\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to relink\n    start, end = sorted([i, j])\n    segment = new_solution[start:end+1]\n\n    # Find best insertion point in remaining tour\n    best_cost = float('inf')\n    best_pos = -1\n    remaining_nodes = np.setdiff1d(np.arange(N), segment)\n\n    for pos in range(len(remaining_nodes)):\n        # Try inserting segment at different positions\n        for k in range(len(remaining_nodes)-len(segment)+1):\n            candidate = np.concatenate([\n                new_solution[:start],\n                segment,\n                new_solution[start:end],\n                new_solution[end:]\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(N-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = k\n\n    if best_pos != -1:\n        # Apply the best found relinking\n        new_solution = np.concatenate([\n            new_solution[:start],\n            segment,\n            new_solution[start:end],\n            new_solution[end:]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.284836363990623,
            5.758579697138991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.284836363990623,
            5.758579697138991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines probabilistic edge flipping with adaptive segment reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    quality_scores = np.sum(normalized_obj, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * quality_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Probabilistic edge flipping with adaptive segment reversal\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        while j == i:\n            j = np.random.randint(0, N)\n\n        # Flip edge with probability based on distance improvement\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        prob1 = 1.0 if new_cost1 < current_cost1 else 0.1\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        prob2 = 1.0 if new_cost2 < current_cost2 else 0.1\n\n        if np.random.random() < max(prob1, prob2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if np.random.random() < 0.4:\n            segment_length = min(3, N // 2)\n            start = np.random.randint(0, N - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.926721789625281,
            7.099589109149262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    diversity_scores = np.std(normalized_obj, axis=1)\n    quality_scores = np.sum(normalized_obj, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * quality_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Probabilistic edge flipping with adaptive segment reversal\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        while j == i:\n            j = np.random.randint(0, N)\n\n        # Flip edge with probability based on distance improvement\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        prob1 = 1.0 if new_cost1 < current_cost1 else 0.1\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        prob2 = 1.0 if new_cost2 < current_cost2 else 0.1\n\n        if np.random.random() < max(prob1, prob2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if np.random.random() < 0.4:\n            segment_length = min(3, N // 2)\n            start = np.random.randint(0, N - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm combines diversity-aware selection with a novel segment-based relocation operator that intelligently reorders node segments based on their relative positions in both objective spaces, while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel segment-based relocation\n        segment_size = max(2, min(5, N // 3))\n        start = np.random.randint(0, N - segment_size)\n        end = start + segment_size\n\n        # Calculate segment quality based on both objectives\n        segment = new_solution[start:end]\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n\n        # Find best insertion point considering both objectives\n        best_pos = start\n        best_score = float('inf')\n\n        for pos in range(N - segment_size + 1):\n            if pos == start:\n                continue\n\n            # Calculate insertion cost\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < N else new_solution[0]\n\n            new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combined score considering both objectives\n            score = new_cost1 + new_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Apply relocation\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.64163423752226,
            9.386318570466383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    balance_scores = np.abs(normalized_obj[:, 0] - normalized_obj[:, 1])\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel segment-based relocation\n        segment_size = max(2, min(5, N // 3))\n        start = np.random.randint(0, N - segment_size)\n        end = start + segment_size\n\n        # Calculate segment quality based on both objectives\n        segment = new_solution[start:end]\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_size]] for i in range(segment_size))\n\n        # Find best insertion point considering both objectives\n        best_pos = start\n        best_score = float('inf')\n\n        for pos in range(N - segment_size + 1):\n            if pos == start:\n                continue\n\n            # Calculate insertion cost\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < N else new_solution[0]\n\n            new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] - distance_matrix_1[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combined score considering both objectives\n            score = new_cost1 + new_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Apply relocation\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining a novel segment reversal with a probabilistic edge swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity\n    solutions = [sol for (sol, _) in archive]\n    diversity_scores = []\n    for i in range(len(solutions)):\n        score = 0\n        for j in range(len(solutions)):\n            if i != j:\n                score += np.sum(solutions[i] != solutions[j])\n        diversity_scores.append(score)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Novel segment reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge swap\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.584145572107213,
            7.0097065191466355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity\n    solutions = [sol for (sol, _) in archive]\n    diversity_scores = []\n    for i in range(len(solutions)):\n        score = 0\n        for j in range(len(solutions)):\n            if i != j:\n                score += np.sum(solutions[i] != solutions[j])\n        diversity_scores.append(score)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Hybrid local search: segment reversal with probabilistic edge swap\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Novel segment reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge swap\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[j]\n                new_solution[j] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection strategy to prioritize solutions in less crowded regions of the Pareto front, then applies a hybrid local search operator that combines node swap with path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions in less crowded regions\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate crowding distances\n    sorted_indices1 = np.argsort(objectives[:, 0])\n    sorted_indices2 = np.argsort(objectives[:, 1])\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            left1 = objectives[sorted_indices1[i-1], 0]\n            right1 = objectives[sorted_indices1[i+1], 0]\n            left2 = objectives[sorted_indices2[i-1], 1]\n            right2 = objectives[sorted_indices2[i+1], 1]\n\n            crowding_distances[i] = (right1 - left1) + (right2 - left2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node swap with path reversal\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, size=2, replace=False)\n\n        # Swap the nodes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly decide whether to reverse a path between two nodes\n        if np.random.random() < 0.5:\n            start, end = sorted(np.random.choice(N, size=2, replace=False))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.00615858789346,
            8.256736926310356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions in less crowded regions\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate crowding distances\n    sorted_indices1 = np.argsort(objectives[:, 0])\n    sorted_indices2 = np.argsort(objectives[:, 1])\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            left1 = objectives[sorted_indices1[i-1], 0]\n            right1 = objectives[sorted_indices1[i+1], 0]\n            left2 = objectives[sorted_indices2[i-1], 1]\n            right2 = objectives[sorted_indices2[i+1], 1]\n\n            crowding_distances[i] = (right1 - left1) + (right2 - left2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node swap with path reversal\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, size=2, replace=False)\n\n        # Swap the nodes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly decide whether to reverse a path between two nodes\n        if np.random.random() < 0.5:\n            start, end = sorted(np.random.choice(N, size=2, replace=False))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection strategy that prioritizes solutions with both good objective values and high crowding distance, then applies a hybrid local search operator that combines node swapping with segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate crowding distances\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0])\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n\n    # Combine objective and crowding distance scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node swapping with segment inversion\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to invert\n        seg_length = np.random.randint(2, min(4, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.251164318794608,
            6.1079586393183325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate crowding distances\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0])\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n\n    # Combine objective and crowding distance scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node swapping with segment inversion\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to invert\n        seg_length = np.random.randint(2, min(4, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion combining dominance rank and objective space diversity, then applies a novel local search operator that combines adaptive edge swaps with probabilistic path inversions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select based on objective space diversity\n        selected_idx = np.argmax(np.std(objectives, axis=0))\n    else:\n        # Select from non-dominated front with preference for solutions in less crowded objective space\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate objective space diversity\n        diversity = np.max(np.std(front_objectives, axis=0))\n\n        # Select solution with highest diversity in less explored objective space\n        selected_idx = fronts[np.argmax(np.max(front_objectives, axis=1) * diversity)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with probabilistic path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to potentially invert\n    start, end = sorted([i, j])\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Additional adaptive edge swap\n    k = np.random.randint(0, N)\n    while k == i or k == j:\n        k = np.random.randint(0, N)\n    new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.4145920252863355,
            8.586446567602644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select based on objective space diversity\n        selected_idx = np.argmax(np.std(objectives, axis=0))\n    else:\n        # Select from non-dominated front with preference for solutions in less crowded objective space\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate objective space diversity\n        diversity = np.max(np.std(front_objectives, axis=0))\n\n        # Select solution with highest diversity in less explored objective space\n        selected_idx = fronts[np.argmax(np.max(front_objectives, axis=1) * diversity)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with probabilistic path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to potentially invert\n    start, end = sorted([i, j])\n    if np.random.rand() < 0.3:  # 30% chance to invert\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Additional adaptive edge swap\n    k = np.random.randint(0, N)\n    while k == i or k == j:\n        k = np.random.randint(0, N)\n    new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution structure, then applies a novel hybrid local search that combines segment inversion with adaptive edge swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate structural diversity (number of unique edges)\n    diversity_scores = []\n    for sol in solutions:\n        edges = set()\n        for i in range(N):\n            edges.add((sol[i], sol[(i+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Hybrid local search: segment inversion with adaptive edge swapping\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Adaptive edge swapping\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                # Calculate cost difference\n                old_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + \\\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + \\\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if new_cost < old_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.949224858791512,
            6.058642281539254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate structural diversity (number of unique edges)\n    diversity_scores = []\n    for sol in solutions:\n        edges = set()\n        for i in range(N):\n            edges.add((sol[i], sol[(i+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Hybrid local search: segment inversion with adaptive edge swapping\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Adaptive edge swapping\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                # Calculate cost difference\n                old_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + \\\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] + \\\n                           distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if new_cost < old_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity metrics, then applies a novel segment inversion and probabilistic edge insertion strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective and higher diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    diversity_scores = np.array(diversity_scores)\n\n    # Combine scores\n    combined_scores = weighted_scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion and probabilistic edge insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Segment inversion\n        if b - a > 1:\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j and abs(i-j) > 1:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.775663162679733,
            6.400964828369938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective and higher diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    diversity_scores = np.array(diversity_scores)\n\n    # Combine scores\n    combined_scores = weighted_scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion and probabilistic edge insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Segment inversion\n        if b - a > 1:\n            segment = new_solution[a:b]\n            new_solution[a:b] = segment[::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j and abs(i-j) > 1:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This algorithm selects a solution from the archive based on the Pareto dominance criterion, then applies a hybrid local search combining 3-opt with a probabilistic edge reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not is_dominated[i]]\n    if non_dominated_indices:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic edge reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.4663201333524185,
            7.011607152782409
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                is_dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not is_dominated[i]]\n    if non_dominated_indices:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic edge reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion that combines objective quality and solution structure, then applies a novel local search operator that combines adaptive segment inversion with probabilistic edge reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective and structure-based selection\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate structure-based scores (number of common edges with other solutions)\n    structure_scores = []\n    for i in range(len(solutions)):\n        common_edges = 0\n        for j in range(len(solutions)):\n            if i != j:\n                edges_i = set(zip(solutions[i], np.roll(solutions[i], -1)))\n                edges_j = set(zip(solutions[j], np.roll(solutions[j], -1)))\n                common_edges += len(edges_i & edges_j)\n        structure_scores.append(common_edges)\n\n    # Combine objective and structure scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * np.array(structure_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: adaptive segment inversion with probabilistic edge reversal\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Select segment to invert\n        seg_length = np.random.randint(2, min(7, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Apply inversion\n        new_solution[start:start+seg_length] = inverted_segment\n\n        # Probabilistic edge reversal\n        for i in range(N-1):\n            if np.random.random() < 0.3:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.598153870976684,
            7.4886456930177765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection: combine objective and structure-based selection\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate structure-based scores (number of common edges with other solutions)\n    structure_scores = []\n    for i in range(len(solutions)):\n        common_edges = 0\n        for j in range(len(solutions)):\n            if i != j:\n                edges_i = set(zip(solutions[i], np.roll(solutions[i], -1)))\n                edges_j = set(zip(solutions[j], np.roll(solutions[j], -1)))\n                common_edges += len(edges_i & edges_j)\n        structure_scores.append(common_edges)\n\n    # Combine objective and structure scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * np.array(structure_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: adaptive segment inversion with probabilistic edge reversal\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Select segment to invert\n        seg_length = np.random.randint(2, min(7, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Apply inversion\n        new_solution[start:start+seg_length] = inverted_segment\n\n        # Probabilistic edge reversal\n        for i in range(N-1):\n            if np.random.random() < 0.3:\n                new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge reversal with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge reversal with probabilistic node insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge reversal\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.588177056698409,
            6.341186489318877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge reversal with probabilistic node insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge reversal\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and tour structure entropy, then applies a novel local search operator that combines adaptive segment reversal with probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with good objectives and high structure entropy\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate structure entropy (measure of tour irregularity)\n    entropy_scores = []\n    for sol in solutions:\n        edges = [(sol[i], sol[(i+1)%N]) for i in range(N)]\n        edge_counts = {}\n        for e in edges:\n            edge_counts[tuple(sorted(e))] = edge_counts.get(tuple(sorted(e)), 0) + 1\n        entropy = -sum((count/N) * np.log(count/N + 1e-10) for count in edge_counts.values())\n        entropy_scores.append(entropy)\n\n    # Combine objective and entropy scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(entropy_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Adaptive segment reversal with probabilistic edge insertion\n        seg_length = min(3, N//3)\n        start = np.random.randint(0, N - seg_length)\n\n        # Reverse segment if it improves at least one objective\n        segment = new_solution[start:start+seg_length]\n        reversed_segment = segment[::-1]\n\n        # Calculate costs before and after reversal\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n        candidate = new_solution.copy()\n        candidate[start:start+seg_length] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n        new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution = candidate\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            if b - a > 1:\n                node = new_solution[a]\n                new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.186168799563086,
            6.314705541451938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with good objectives and high structure entropy\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate structure entropy (measure of tour irregularity)\n    entropy_scores = []\n    for sol in solutions:\n        edges = [(sol[i], sol[(i+1)%N]) for i in range(N)]\n        edge_counts = {}\n        for e in edges:\n            edge_counts[tuple(sorted(e))] = edge_counts.get(tuple(sorted(e)), 0) + 1\n        entropy = -sum((count/N) * np.log(count/N + 1e-10) for count in edge_counts.values())\n        entropy_scores.append(entropy)\n\n    # Combine objective and entropy scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(entropy_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Adaptive segment reversal with probabilistic edge insertion\n        seg_length = min(3, N//3)\n        start = np.random.randint(0, N - seg_length)\n\n        # Reverse segment if it improves at least one objective\n        segment = new_solution[start:start+seg_length]\n        reversed_segment = segment[::-1]\n\n        # Calculate costs before and after reversal\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n        candidate = new_solution.copy()\n        candidate[start:start+seg_length] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n        new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution = candidate\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            if b - a > 1:\n                node = new_solution[a]\n                new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a hybrid local search operator that combines a novel \"path inversion\" technique with a probabilistic edge reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    combined_scores = objectives[:, 0] + objectives[:, 1] - 0.3 * np.array(diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: path inversion with probabilistic edge reversal\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Path inversion: select a random segment and reverse it\n        start = np.random.randint(0, N)\n        end = np.random.randint(start, N)\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.5:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.814854000393363,
            5.84931930692752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    combined_scores = objectives[:, 0] + objectives[:, 1] - 0.3 * np.array(diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: path inversion with probabilistic edge reversal\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Path inversion: select a random segment and reverse it\n        start = np.random.randint(0, N)\n        end = np.random.randint(start, N)\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.5:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.155774520170909,
            6.186802583481456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection strategy that prioritizes solutions with good objective values and high crowding distance, then applies a hybrid local search operator that combines node reinsertion with path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate crowding distances\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    crowding_distances[sorted_indices[0]] = float('inf')\n    crowding_distances[sorted_indices[-1]] = float('inf')\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-10)\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    crowding_distances[sorted_indices[0]] = float('inf')\n    crowding_distances[sorted_indices[-1]] = float('inf')\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1] + 1e-10)\n\n    # Combine objective and crowding distance scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / crowding_distances)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node reinsertion with path reversal\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a node and its neighbors\n        node_idx = np.random.randint(0, N)\n        node = new_solution[node_idx]\n\n        # Remove the node and its neighbors\n        segment = new_solution[(node_idx-1)%N:node_idx+2]\n        new_solution = np.concatenate([new_solution[:(node_idx-1)%N], new_solution[node_idx+2:]])\n\n        # Reverse the segment and find best insertion point\n        reversed_segment = segment[::-1]\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert reversed segment at position pos\n            candidate = np.concatenate([new_solution[:pos], reversed_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert reversed segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.986220051715005,
            5.896880153839934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate crowding distances\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n    crowding_distances[sorted_indices[0]] = float('inf')\n    crowding_distances[sorted_indices[-1]] = float('inf')\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-10)\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    crowding_distances[sorted_indices[0]] = float('inf')\n    crowding_distances[sorted_indices[-1]] = float('inf')\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1] + 1e-10)\n\n    # Combine objective and crowding distance scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / crowding_distances)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node reinsertion with path reversal\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a node and its neighbors\n        node_idx = np.random.randint(0, N)\n        node = new_solution[node_idx]\n\n        # Remove the node and its neighbors\n        segment = new_solution[(node_idx-1)%N:node_idx+2]\n        new_solution = np.concatenate([new_solution[:(node_idx-1)%N], new_solution[node_idx+2:]])\n\n        # Reverse the segment and find best insertion point\n        reversed_segment = segment[::-1]\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert reversed segment at position pos\n            candidate = np.concatenate([new_solution[:pos], reversed_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert reversed segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-criteria selection that combines objective quality, structural diversity, and solution age, then applies a hybrid local search operator that combines adaptive edge flipping with probabilistic segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-criteria selection: objective quality, diversity, and age\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Solution age (index in archive, newer solutions have lower age)\n    ages = np.arange(len(archive))\n\n    # Combine scores with adaptive weights\n    obj_weights = np.random.uniform(0.5, 0.7)\n    div_weights = np.random.uniform(0.2, 0.4)\n    age_weights = 1 - obj_weights - div_weights\n\n    combined_scores = (obj_weights * (objectives[:, 0] + objectives[:, 1]) +\n                      div_weights * (1 / np.array(diversity_scores)) +\n                      age_weights * (ages / len(archive)))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: adaptive edge flipping with segment inversion\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Adaptive edge flipping\n        flip_length = min(4, N // 3)\n        start = np.random.randint(0, N - flip_length)\n        segment = new_solution[start:start+flip_length]\n\n        # Flip segment with probability based on its current quality\n        if np.random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.3:\n            inv_start = np.random.randint(0, N)\n            inv_end = np.random.randint(inv_start, N)\n            new_solution[inv_start:inv_end] = new_solution[inv_start:inv_end][::-1]\n\n        # Reinsert flipped segment\n        new_solution = np.concatenate([new_solution[:start], segment, new_solution[start+flip_length:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.806461216571176,
            5.9460835648201815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Multi-criteria selection: objective quality, diversity, and age\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Solution age (index in archive, newer solutions have lower age)\n    ages = np.arange(len(archive))\n\n    # Combine scores with adaptive weights\n    obj_weights = np.random.uniform(0.5, 0.7)\n    div_weights = np.random.uniform(0.2, 0.4)\n    age_weights = 1 - obj_weights - div_weights\n\n    combined_scores = (obj_weights * (objectives[:, 0] + objectives[:, 1]) +\n                      div_weights * (1 / np.array(diversity_scores)) +\n                      age_weights * (ages / len(archive)))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: adaptive edge flipping with segment inversion\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Adaptive edge flipping\n        flip_length = min(4, N // 3)\n        start = np.random.randint(0, N - flip_length)\n        segment = new_solution[start:start+flip_length]\n\n        # Flip segment with probability based on its current quality\n        if np.random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.3:\n            inv_start = np.random.randint(0, N)\n            inv_end = np.random.randint(inv_start, N)\n            new_solution[inv_start:inv_end] = new_solution[inv_start:inv_end][::-1]\n\n        # Reinsert flipped segment\n        new_solution = np.concatenate([new_solution[:start], segment, new_solution[start+flip_length:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining 3-opt with a probabilistic edge insertion to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    fronts = np.zeros(len(archive), dtype=int)\n    crowding_distances = np.zeros(len(archive))\n\n    # Simple non-dominated sorting (for crowding distance calculation)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                dominates = (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n                            (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])\n                if dominates:\n                    fronts[j] += 1\n\n    # Calculate crowding distance for non-dominated solutions\n    for i in range(len(archive)):\n        if fronts[i] == 0:\n            neighbors = np.where(fronts == 0)[0]\n            if len(neighbors) > 1:\n                sorted_idx = np.argsort(objectives[neighbors, 0])\n                sorted_neighbors = neighbors[sorted_idx]\n                crowding_distances[i] = objectives[sorted_neighbors[-1], 0] - objectives[sorted_neighbors[0], 0]\n                sorted_idx = np.argsort(objectives[neighbors, 1])\n                sorted_neighbors = neighbors[sorted_idx]\n                crowding_distances[i] += objectives[sorted_neighbors[-1], 1] - objectives[sorted_neighbors[0], 1]\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic edge insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.990188559368304,
            7.743504091016773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    fronts = np.zeros(len(archive), dtype=int)\n    crowding_distances = np.zeros(len(archive))\n\n    # Simple non-dominated sorting (for crowding distance calculation)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                dominates = (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n                            (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1])\n                if dominates:\n                    fronts[j] += 1\n\n    # Calculate crowding distance for non-dominated solutions\n    for i in range(len(archive)):\n        if fronts[i] == 0:\n            neighbors = np.where(fronts == 0)[0]\n            if len(neighbors) > 1:\n                sorted_idx = np.argsort(objectives[neighbors, 0])\n                sorted_neighbors = neighbors[sorted_idx]\n                crowding_distances[i] = objectives[sorted_neighbors[-1], 0] - objectives[sorted_neighbors[0], 0]\n                sorted_idx = np.argsort(objectives[neighbors, 1])\n                sorted_neighbors = neighbors[sorted_idx]\n                crowding_distances[i] += objectives[sorted_neighbors[-1], 1] - objectives[sorted_neighbors[0], 1]\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic edge insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.252339302702418,
            5.669518134292408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.252339302702418,
            5.669518134292408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware criterion, then applies a novel segment inversion with probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity\n    solutions = [sol for (sol, _) in archive]\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(len(sol)-1):\n            diversity += distance_matrix_1[sol[i]][sol[i+1]] + distance_matrix_2[sol[i]][sol[i+1]]\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion with probabilistic edge insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Segment inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.41722709402169,
            10.615841320227045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity\n    solutions = [sol for (sol, _) in archive]\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(len(sol)-1):\n            diversity += distance_matrix_1[sol[i]][sol[i+1]] + distance_matrix_2[sol[i]][sol[i+1]]\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion with probabilistic edge insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Segment inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and a novel \"edge correlation\" metric that measures how well edges align with both objectives, then applies a hybrid local search that combines segment reversal with edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate edge correlation scores (how well edges align with both objectives)\n    correlation_scores = []\n    for sol in solutions:\n        total_diff = 0\n        for i in range(N):\n            a, b = sol[i], sol[(i+1)%N]\n            diff = abs(distance_matrix_1[a, b] - distance_matrix_2[a, b])\n            total_diff += diff\n        correlation_scores.append(total_diff)\n\n    # Combine objective and correlation scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * np.array(correlation_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to reverse\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[start:start+seg_length] = reversed_segment\n\n        # Randomly swap two edges to introduce further diversity\n        if N > 4:\n            swap_pos1, swap_pos2 = np.random.choice(range(N), size=2, replace=False)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.886413935301372,
            6.511656298405525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate edge correlation scores (how well edges align with both objectives)\n    correlation_scores = []\n    for sol in solutions:\n        total_diff = 0\n        for i in range(N):\n            a, b = sol[i], sol[(i+1)%N]\n            diff = abs(distance_matrix_1[a, b] - distance_matrix_2[a, b])\n            total_diff += diff\n        correlation_scores.append(total_diff)\n\n    # Combine objective and correlation scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * np.array(correlation_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to reverse\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[start:start+seg_length] = reversed_segment\n\n        # Randomly swap two edges to introduce further diversity\n        if N > 4:\n            swap_pos1, swap_pos2 = np.random.choice(range(N), size=2, replace=False)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and solution quality metrics, then applies a novel hybrid local search combining edge reversal with adaptive segment insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective scores\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-8)\n    quality_scores = np.exp(-np.sum(normalized_obj, axis=1))\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel hybrid local search: edge reversal with adaptive segment insertion\n        # First perform edge reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Then perform adaptive segment insertion\n        seg_length = max(2, min(4, N//3))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that maximizes the improvement in both objectives\n        best_pos = start\n        best_improvement = 0\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate improvement in both objectives\n            original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%N]] for i in range(N))\n            original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%N]] for i in range(N))\n            new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.821505219809222,
            5.79928232353381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective scores\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-8)\n    quality_scores = np.exp(-np.sum(normalized_obj, axis=1))\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel hybrid local search: edge reversal with adaptive segment insertion\n        # First perform edge reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Then perform adaptive segment insertion\n        seg_length = max(2, min(4, N//3))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that maximizes the improvement in both objectives\n        best_pos = start\n        best_improvement = 0\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate improvement in both objectives\n            original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%N]] for i in range(N))\n            original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%N]] for i in range(N))\n            new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel local search operator that combines path inversion with a probabilistic edge exchange to explore the solution space while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions that are non-dominated and have better combined objective\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate dominance and objective scores\n    dominance_scores = np.zeros(len(solutions))\n    for i in range(len(solutions)):\n        dominated = False\n        for j in range(len(solutions)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                          (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            dominance_scores[i] = 1\n\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores * (1 - dominance_scores + 0.1))\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Novel local search: path inversion with probabilistic edge exchange\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Invert the path between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge exchange\n        if np.random.random() < 0.5:\n            c, d = np.random.choice(N, 2, replace=False)\n            if c != d:\n                # Exchange edges (a,c) and (b,d) with (a,d) and (b,c)\n                # Find positions of c and d in the solution\n                pos_c = np.where(new_solution == c)[0][0]\n                pos_d = np.where(new_solution == d)[0][0]\n\n                # Perform edge exchange\n                if pos_c < pos_d:\n                    new_solution[pos_c], new_solution[pos_d] = new_solution[pos_d], new_solution[pos_c]\n                else:\n                    # Handle circular case\n                    temp = new_solution[pos_c]\n                    new_solution[pos_c] = new_solution[pos_d]\n                    new_solution[pos_d] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.383698877626543,
            5.836232476689457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions that are non-dominated and have better combined objective\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate dominance and objective scores\n    dominance_scores = np.zeros(len(solutions))\n    for i in range(len(solutions)):\n        dominated = False\n        for j in range(len(solutions)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                          (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            dominance_scores[i] = 1\n\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores * (1 - dominance_scores + 0.1))\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Novel local search: path inversion with probabilistic edge exchange\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Invert the path between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge exchange\n        if np.random.random() < 0.5:\n            c, d = np.random.choice(N, 2, replace=False)\n            if c != d:\n                # Exchange edges (a,c) and (b,d) with (a,d) and (b,c)\n                # Find positions of c and d in the solution\n                pos_c = np.where(new_solution == c)[0][0]\n                pos_d = np.where(new_solution == d)[0][0]\n\n                # Perform edge exchange\n                if pos_c < pos_d:\n                    new_solution[pos_c], new_solution[pos_d] = new_solution[pos_d], new_solution[pos_c]\n                else:\n                    # Handle circular case\n                    temp = new_solution[pos_c]\n                    new_solution[pos_c] = new_solution[pos_d]\n                    new_solution[pos_d] = temp\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-aware selection strategy that prioritizes solutions with good objective values and high diversity in the objective space, then applies a hybrid local search operator that combines node swapping with segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    # Combine objective and crowding distance scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node swapping with segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, size=2, replace=False)\n\n        # Perform node swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment to invert\n        seg_start = np.random.randint(0, N - 2)\n        seg_length = np.random.randint(2, min(5, N - seg_start))\n        segment = new_solution[seg_start:seg_start+seg_length]\n        new_solution[seg_start:seg_start+seg_length] = segment[::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.859152537159875,
            7.055751288494828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    # Combine objective and crowding distance scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: node swapping with segment inversion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, size=2, replace=False)\n\n        # Perform node swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment to invert\n        seg_start = np.random.randint(0, N - 2)\n        seg_length = np.random.randint(2, min(5, N - seg_start))\n        segment = new_solution[seg_start:seg_start+seg_length]\n        new_solution[seg_start:seg_start+seg_length] = segment[::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining node clustering with a probabilistic segment rotation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * np.random.random(2), axis=0))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: node clustering with probabilistic segment rotation\n        cluster_size = max(2, N // 5)\n        start = np.random.randint(0, N - cluster_size + 1)\n        end = start + cluster_size\n\n        # Node clustering\n        cluster = new_solution[start:end]\n        np.random.shuffle(cluster)\n        new_solution[start:end] = cluster\n\n        # Probabilistic segment rotation\n        if np.random.random() < 0.6:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.278517125962725,
            8.718110906509544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity_scores * np.random.random(2), axis=0))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: node clustering with probabilistic segment rotation\n        cluster_size = max(2, N // 5)\n        start = np.random.randint(0, N - cluster_size + 1)\n        end = start + cluster_size\n\n        # Node clustering\n        cluster = new_solution[start:end]\n        np.random.shuffle(cluster)\n        new_solution[start:end] = cluster\n\n        # Probabilistic segment rotation\n        if np.random.random() < 0.6:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            segment = new_solution[a:b+1]\n            rotation = np.random.randint(1, len(segment))\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[a:b+1] = rotated_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This algorithm selects a solution from the archive based on a novelty-aware selection that prioritizes both objective quality and structural novelty, then applies a hybrid local search combining path inversion with adaptive segment swapping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize novelty and objective quality\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(solutions[0])\n\n    # Calculate novelty scores (number of unique edges not shared with other solutions)\n    novelty_scores = []\n    all_edges = set()\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        all_edges.update(edges)\n\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        novelty_scores.append(len(edges.intersection(all_edges)) / len(edges))\n\n    # Combine objective and novelty scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(novelty_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Hybrid local search: path inversion with adaptive segment swapping\n        # Select a segment to invert\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find best position to insert the inverted segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Adaptive segment swapping\n        if np.random.random() < 0.3:\n            a, b = np.random.choice(N, 2, replace=False)\n            a, b = sorted([a, b])\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.11445590578504,
            5.686677605646184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize novelty and objective quality\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(solutions[0])\n\n    # Calculate novelty scores (number of unique edges not shared with other solutions)\n    novelty_scores = []\n    all_edges = set()\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        all_edges.update(edges)\n\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        novelty_scores.append(len(edges.intersection(all_edges)) / len(edges))\n\n    # Combine objective and novelty scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(novelty_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Hybrid local search: path inversion with adaptive segment swapping\n        # Select a segment to invert\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find best position to insert the inverted segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Adaptive segment swapping\n        if np.random.random() < 0.3:\n            a, b = np.random.choice(N, 2, replace=False)\n            a, b = sorted([a, b])\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This algorithm selects a solution from the archive based on a quality-diversity trade-off, then applies a novel local search operator that combines adaptive segment inversion with objective-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using adaptive segment inversion with objective-aware edge swapping\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Randomly select a segment to invert\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Temporarily replace the segment\n        temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[start+seg_length:]])\n\n        # Perform objective-aware edge swapping\n        for _ in range(2):  # Perform a few swaps\n            # Select two random edges that don't overlap with the inverted segment\n            edge1 = np.random.randint(0, N)\n            edge2 = np.random.randint(0, N)\n            while abs(edge1 - edge2) < seg_length:\n                edge2 = np.random.randint(0, N)\n\n            # Evaluate swap\n            original_cost = (distance_matrix_1[temp_solution[edge1], temp_solution[(edge1+1)%N]] +\n                            distance_matrix_1[temp_solution[edge2], temp_solution[(edge2+1)%N]] +\n                            distance_matrix_2[temp_solution[edge1], temp_solution[(edge1+1)%N]] +\n                            distance_matrix_2[temp_solution[edge2], temp_solution[(edge2+1)%N]])\n\n            swapped_cost = (distance_matrix_1[temp_solution[edge1], temp_solution[edge2]] +\n                            distance_matrix_1[temp_solution[(edge1+1)%N], temp_solution[(edge2+1)%N]] +\n                            distance_matrix_2[temp_solution[edge1], temp_solution[edge2]] +\n                            distance_matrix_2[temp_solution[(edge1+1)%N], temp_solution[(edge2+1)%N]])\n\n            if swapped_cost < original_cost:\n                # Perform the swap\n                temp_solution[edge1], temp_solution[edge2] = temp_solution[edge2], temp_solution[edge1]\n\n        new_solution = temp_solution\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.715651625064494,
            6.496869333853134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using adaptive segment inversion with objective-aware edge swapping\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Randomly select a segment to invert\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Temporarily replace the segment\n        temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[start+seg_length:]])\n\n        # Perform objective-aware edge swapping\n        for _ in range(2):  # Perform a few swaps\n            # Select two random edges that don't overlap with the inverted segment\n            edge1 = np.random.randint(0, N)\n            edge2 = np.random.randint(0, N)\n            while abs(edge1 - edge2) < seg_length:\n                edge2 = np.random.randint(0, N)\n\n            # Evaluate swap\n            original_cost = (distance_matrix_1[temp_solution[edge1], temp_solution[(edge1+1)%N]] +\n                            distance_matrix_1[temp_solution[edge2], temp_solution[(edge2+1)%N]] +\n                            distance_matrix_2[temp_solution[edge1], temp_solution[(edge1+1)%N]] +\n                            distance_matrix_2[temp_solution[edge2], temp_solution[(edge2+1)%N]])\n\n            swapped_cost = (distance_matrix_1[temp_solution[edge1], temp_solution[edge2]] +\n                            distance_matrix_1[temp_solution[(edge1+1)%N], temp_solution[(edge2+1)%N]] +\n                            distance_matrix_2[temp_solution[edge1], temp_solution[edge2]] +\n                            distance_matrix_2[temp_solution[(edge1+1)%N], temp_solution[(edge2+1)%N]])\n\n            if swapped_cost < original_cost:\n                # Perform the swap\n                temp_solution[edge1], temp_solution[edge2] = temp_solution[edge2], temp_solution[edge1]\n\n        new_solution = temp_solution\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if np.random.random() < 0.5:\n            a, b, c = np.random.choice(N, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:c],\n                new_solution[a:b],\n                new_solution[c:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.296195850110871,
            6.011674755891352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_scores = objectives / np.max(objectives, axis=0)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if np.random.random() < 0.5:\n            a, b, c = np.random.choice(N, 3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:c],\n                new_solution[a:b],\n                new_solution[c:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a 3-opt move with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    # Calculate crowding distance for each objective\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding_dist[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (np.max(sorted_obj) - np.min(sorted_obj) + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt move with probabilistic edge insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.271000259545566,
            6.240488326836717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    # Calculate crowding distance for each objective\n    crowding_dist = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        sorted_obj = objectives[sorted_idx, i]\n        crowding_dist[sorted_idx[1:-1]] += (sorted_obj[2:] - sorted_obj[:-2]) / (np.max(sorted_obj) - np.min(sorted_obj) + 1e-10)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt move with probabilistic edge insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to prioritize under-explored regions, then applies a hybrid local search combining a novel 'k-segment inversion' with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    if len(archive) > 1:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(1, len(archive)-1):\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: k-segment inversion with probabilistic edge insertion\n        k = np.random.randint(2, min(4, N//2))\n        segments = np.random.choice(N, k+1, replace=False)\n        segments.sort()\n        segments[-1] = N\n\n        # k-segment inversion\n        for i in range(len(segments)-1):\n            start, end = segments[i], segments[i+1]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.962816314460023,
            7.511284347131312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    if len(archive) > 1:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(1, len(archive)-1):\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: k-segment inversion with probabilistic edge insertion\n        k = np.random.randint(2, min(4, N//2))\n        segments = np.random.choice(N, k+1, replace=False)\n        segments.sort()\n        segments[-1] = N\n\n        # k-segment inversion\n        for i in range(len(segments)-1):\n            start, end = segments[i], segments[i+1]\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge swapping with a segment relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with segment relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment relocation\n        if np.random.random() < 0.5:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.8982887301216405,
            6.522155560040984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with segment relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment relocation\n        if np.random.random() < 0.5:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive based on crowding distance in objective space, then applies a hybrid local search combining node swapping with a probabilistic segment inversion to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 0], objectives[:, 1]))\n    crowding = np.zeros(len(archive))\n\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding[i] = float('inf')\n        else:\n            crowding[i] = abs(objectives[sorted_indices[i-1], 0] - objectives[sorted_indices[i+1], 0]) + \\\n                          abs(objectives[sorted_indices[i-1], 1] - objectives[sorted_indices[i+1], 1])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: node swapping with probabilistic segment inversion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.335206634994929,
            9.902161373269223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 0], objectives[:, 1]))\n    crowding = np.zeros(len(archive))\n\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding[i] = float('inf')\n        else:\n            crowding[i] = abs(objectives[sorted_indices[i-1], 0] - objectives[sorted_indices[i+1], 0]) + \\\n                          abs(objectives[sorted_indices[i-1], 1] - objectives[sorted_indices[i+1], 1])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: node swapping with probabilistic segment inversion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines objective performance with solution structure, then applies a hybrid local search combining segment rotation with a probabilistic node permutation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware metric\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=1, keepdims=True)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate diversity metric (combining objective performance and solution structure)\n    diversity_metrics = []\n    for i, (sol, _) in enumerate(archive):\n        # Solution structure: count of consecutive nodes with increasing IDs\n        structure_score = sum(1 for j in range(len(sol)-1) if sol[j+1] == sol[j] + 1)\n        diversity_metrics.append(np.sum(normalized_obj[i]) + 0.3 * structure_score)\n\n    selected_idx = np.argmin(diversity_metrics)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment rotation with probabilistic node permutation\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        segment_length = b - a + 1\n\n        # Segment rotation (shift elements in segment)\n        rotation = np.random.randint(1, segment_length)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n        # Probabilistic node permutation\n        if np.random.random() < 0.6:\n            c, d = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.726208264110004,
            6.422229405565055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware metric\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=1, keepdims=True)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate diversity metric (combining objective performance and solution structure)\n    diversity_metrics = []\n    for i, (sol, _) in enumerate(archive):\n        # Solution structure: count of consecutive nodes with increasing IDs\n        structure_score = sum(1 for j in range(len(sol)-1) if sol[j+1] == sol[j] + 1)\n        diversity_metrics.append(np.sum(normalized_obj[i]) + 0.3 * structure_score)\n\n    selected_idx = np.argmin(diversity_metrics)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment rotation with probabilistic node permutation\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        segment_length = b - a + 1\n\n        # Segment rotation (shift elements in segment)\n        rotation = np.random.randint(1, segment_length)\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n        # Probabilistic node permutation\n        if np.random.random() < 0.6:\n            c, d = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-based selection, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion and swap operations to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            distances[sorted_indices[i]] = float('inf')\n        else:\n            left = sorted_objectives[i-1]\n            right = sorted_objectives[i+1]\n            distances[sorted_indices[i]] = np.sum(np.abs(right - left))\n\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion and swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Probabilistic swap\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.851996663662492,
            7.61971071920429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            distances[sorted_indices[i]] = float('inf')\n        else:\n            left = sorted_objectives[i-1]\n            right = sorted_objectives[i+1]\n            distances[sorted_indices[i]] = np.sum(np.abs(right - left))\n\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion and swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Probabilistic swap\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.842318304956346,
            7.953715747109067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.842318304956346,
            7.953715747109067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement and diversity, then applies a novel hybrid local search that combines a probabilistic path inversion with a guided edge exchange to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better objective and diverse solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.array([np.sum(np.abs(sol - archive[0][0])) for (sol, _) in archive])\n    combined_scores = 0.6 * np.sum(objectives, axis=1) + 0.4 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Probabilistic path inversion\n        if np.random.random() < 0.6:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge exchange\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate cost difference in both objectives\n                def cost_diff(sol):\n                    total_cost = 0\n                    for k in range(N):\n                        u = sol[k]\n                        v = sol[(k+1)%N]\n                        total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n                    return total_cost\n\n                original_cost = cost_diff(new_solution)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                new_cost = cost_diff(temp_sol)\n\n                if new_cost < original_cost:\n                    new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.501790032403196,
            9.638869543835117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better objective and diverse solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.array([np.sum(np.abs(sol - archive[0][0])) for (sol, _) in archive])\n    combined_scores = 0.6 * np.sum(objectives, axis=1) + 0.4 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Probabilistic path inversion\n        if np.random.random() < 0.6:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge exchange\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate cost difference in both objectives\n                def cost_diff(sol):\n                    total_cost = 0\n                    for k in range(N):\n                        u = sol[k]\n                        v = sol[(k+1)%N]\n                        total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n                    return total_cost\n\n                original_cost = cost_diff(new_solution)\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n                new_cost = cost_diff(temp_sol)\n\n                if new_cost < original_cost:\n                    new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.564681530529454,
            5.655044504385038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.564681530529454,
            5.655044504385038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a novel local search combining segment inversion with probabilistic k-opt moves (k=3 or 4) to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion with probabilistic k-opt moves\n        k = np.random.choice([3, 4])\n        if k == 3:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        else:\n            # 4-opt move\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.6:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.93089765274522,
            7.290157655289774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion with probabilistic k-opt moves\n        k = np.random.choice([3, 4])\n        if k == 3:\n            # 3-opt move\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        else:\n            # 4-opt move\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.6:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining a novel segment inversion with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Segment inversion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.969073986049082,
            5.840084583980954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Segment inversion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining a probabilistic node swap with a segment inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: probabilistic node swap with segment inversion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Probabilistic node swap\n        if np.random.random() < 0.7:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment inversion\n        if np.random.random() < 0.5:\n            c, d = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.67558258937675,
            8.022042178652812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: probabilistic node swap with segment inversion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Probabilistic node swap\n        if np.random.random() < 0.7:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Segment inversion\n        if np.random.random() < 0.5:\n            c, d = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel local search combining segment inversion with a probabilistic edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: combine objective scores with diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    diversity_scores = np.array([np.sum(np.abs(sol - archive[0][0])) for (sol, _) in archive])\n    combined_scores = weighted_scores + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion with probabilistic edge insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Segment inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.555833645183246,
            8.162983103350197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: combine objective scores with diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    diversity_scores = np.array([np.sum(np.abs(sol - archive[0][0])) for (sol, _) in archive])\n    combined_scores = weighted_scores + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: segment inversion with probabilistic edge insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Segment inversion\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel segment-based perturbation that combines partial reversal with probabilistic segment insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    diversity_scores = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(diversity_scores) if diversity_scores else 0\n    combined_scores = weighted_scores + 0.2 * diversity_score\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Segment-based perturbation\n        segment_length = max(2, min(5, np.random.randint(2, N//2)))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Partial reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.5:\n            insert_pos = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.s_[start:end])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.526401963476373,
            6.643883488438379
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    diversity_scores = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(diversity_scores) if diversity_scores else 0\n    combined_scores = weighted_scores + 0.2 * diversity_score\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Segment-based perturbation\n        segment_length = max(2, min(5, np.random.randint(2, N//2)))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Partial reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.5:\n            insert_pos = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.s_[start:end])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining 3-opt with a probabilistic node swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.7, 0.3])  # Weighted sum with more emphasis on first objective\n    weighted_scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node swap\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt operation\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n        # Probabilistic node swap\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.054382658208032,
            8.060979428223886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.array([0.7, 0.3])  # Weighted sum with more emphasis on first objective\n    weighted_scores = np.dot(normalized_scores, weights)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node swap\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt operation\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n        # Probabilistic node swap\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining a novel segment rotation with a probabilistic node swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum((objectives - mean_obj) ** 2, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment rotation with probabilistic node swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, k)\n\n        # Probabilistic node swap\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.136951532933924,
            8.165803516431009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity in objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    mean_obj = np.mean(objectives, axis=0)\n    diversity_scores = np.sum((objectives - mean_obj) ** 2, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment rotation with probabilistic node swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, k)\n\n        # Probabilistic node swap\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel local search operator that combines a probabilistic segment reversal with a guided edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and dominance\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    dominance_scores = np.sum(normalized_scores < 0.5, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.5 * dominance_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment reversal with guided edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    # Insert node j after node i\n                    node = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                    insert_pos = (i + 1) % N\n                    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.564869760458189,
            5.712848303297716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and dominance\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    dominance_scores = np.sum(normalized_scores < 0.5, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.5 * dominance_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment reversal with guided edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided edge insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    # Insert node j after node i\n                    node = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n                    insert_pos = (i + 1) % N\n                    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution structure diversity, then applies a novel local search operator that combines a probabilistic segment inversion with a guided node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate structural diversity using Hamming distance\n    diversity_scores = []\n    for sol, _ in archive:\n        hamming_dist = sum(1 for i in range(len(sol)) if sol[i] != archive[0][0][i])\n        diversity_scores.append(hamming_dist)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.5 * (diversity_scores / len(sol))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Try inserting node i after node j\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, i)\n                temp_sol = np.insert(temp_sol, j, new_solution[i])\n\n                new_cost1 = distance_matrix_1[temp_sol[j-1], temp_sol[j]] + distance_matrix_1[temp_sol[(j+1)%N], temp_sol[j]]\n                new_cost2 = distance_matrix_2[temp_sol[j-1], temp_sol[j]] + distance_matrix_2[temp_sol[(j+1)%N], temp_sol[j]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.758819988397105,
            6.041005971354555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate structural diversity using Hamming distance\n    diversity_scores = []\n    for sol, _ in archive:\n        hamming_dist = sum(1 for i in range(len(sol)) if sol[i] != archive[0][0][i])\n        diversity_scores.append(hamming_dist)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.5 * (diversity_scores / len(sol))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Try inserting node i after node j\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, i)\n                temp_sol = np.insert(temp_sol, j, new_solution[i])\n\n                new_cost1 = distance_matrix_1[temp_sol[j-1], temp_sol[j]] + distance_matrix_1[temp_sol[(j+1)%N], temp_sol[j]]\n                new_cost2 = distance_matrix_2[temp_sol[j-1], temp_sol[j]] + distance_matrix_2[temp_sol[(j+1)%N], temp_sol[j]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel local search operator that combines a guided segment insertion with a probabilistic edge reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and dominance\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    dominance_scores = np.sum(normalized_scores < 0.5, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.4 * dominance_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: guided segment insertion with probabilistic edge reversal\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Find optimal insertion point based on both objectives\n        best_pos = a\n        min_cost = float('inf')\n        for i in range(N - len(segment)):\n            if i >= a and i < b:  # Skip current position\n                continue\n            # Calculate potential cost for both objectives\n            if i == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Insert segment at best position\n        if best_pos != a:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n            # Remove old segment\n            if best_pos < a:\n                new_solution = np.concatenate([\n                    new_solution[:a + len(segment)],\n                    new_solution[a + 2*len(segment):]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:a],\n                    new_solution[a + len(segment):]\n                ])\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n                # Accept reversal if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.028833405329298,
            6.4478799792643855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and dominance\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    dominance_scores = np.sum(normalized_scores < 0.5, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.4 * dominance_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: guided segment insertion with probabilistic edge reversal\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        segment = new_solution[a:b+1]\n\n        # Find optimal insertion point based on both objectives\n        best_pos = a\n        min_cost = float('inf')\n        for i in range(N - len(segment)):\n            if i >= a and i < b:  # Skip current position\n                continue\n            # Calculate potential cost for both objectives\n            if i == 0:\n                prev_node = new_solution[-1]\n            else:\n                prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n            cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        # Insert segment at best position\n        if best_pos != a:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n            # Remove old segment\n            if best_pos < a:\n                new_solution = np.concatenate([\n                    new_solution[:a + len(segment)],\n                    new_solution[a + 2*len(segment):]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:a],\n                    new_solution[a + len(segment):]\n                ])\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n                # Accept reversal if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution structure, then applies a novel local search operator that combines a probabilistic segment inversion with a guided node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions that are non-dominated in at least one objective\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[(i-1)%N], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]\n                old_cost2 = distance_matrix_2[new_solution[(i-1)%N], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n                new_cost1 = distance_matrix_1[new_solution[(i-1)%N], new_solution[(i+1)%N]]\n                new_cost2 = distance_matrix_2[new_solution[(i-1)%N], new_solution[(i+1)%N]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                    insert_pos = np.random.randint(0, len(new_solution))\n                    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.1816989282970685,
            7.081589603032688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions that are non-dominated in at least one objective\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[(i-1)%N], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]\n                old_cost2 = distance_matrix_2[new_solution[(i-1)%N], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n                new_cost1 = distance_matrix_1[new_solution[(i-1)%N], new_solution[(i+1)%N]]\n                new_cost2 = distance_matrix_2[new_solution[(i-1)%N], new_solution[(i+1)%N]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                    insert_pos = np.random.randint(0, len(new_solution))\n                    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search combining a probabilistic 4-opt move with a segment insertion to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        # Hybrid local search: probabilistic 4-opt move\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        if np.random.random() < 0.7:\n            # 4-opt move (two 2-opt exchanges)\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Segment insertion\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            k = np.random.randint(0, N)\n            if i < j and j < k:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate((new_solution[:i], new_solution[j:k], segment, new_solution[k:]))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.408215704718392,
            7.186925249834212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        # Hybrid local search: probabilistic 4-opt move\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        if np.random.random() < 0.7:\n            # 4-opt move (two 2-opt exchanges)\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Segment insertion\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            k = np.random.randint(0, N)\n            if i < j and j < k:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate((new_solution[:i], new_solution[j:k], segment, new_solution[k:]))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a novel local search operator that combines a probabilistic segment inversion with a guided node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    structural_diversity = np.array([np.sum(np.diff(sol) != np.diff(archive[0][0])) for (sol, _) in archive])\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.4 * structural_diversity\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.432533689635125,
            6.132622861777793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    structural_diversity = np.array([np.sum(np.diff(sol) != np.diff(archive[0][0])) for (sol, _) in archive])\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.4 * structural_diversity\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    node = new_solution[i]\n                    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to promote diversity, then applies a hybrid local search combining edge exchange with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        left = sorted_objectives[i-1]\n        right = sorted_objectives[i+1]\n        crowding_distances[i] = np.sum(np.abs(sorted_objectives[i] - left) + np.abs(sorted_objectives[i] - right))\n\n    crowding_distances[0] = crowding_distances[-1] = np.inf\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge exchange with probabilistic segment insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge exchange\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.3:\n            i, j, k = np.random.choice(N, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.623978733030533,
            8.494437371841483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        left = sorted_objectives[i-1]\n        right = sorted_objectives[i+1]\n        crowding_distances[i] = np.sum(np.abs(sorted_objectives[i] - left) + np.abs(sorted_objectives[i] - right))\n\n    crowding_distances[0] = crowding_distances[-1] = np.inf\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge exchange with probabilistic segment insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge exchange\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.3:\n            i, j, k = np.random.choice(N, 3, replace=False)\n            i, j, k = sorted([i, j, k])\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.59490930398189,
            6.563195839602217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.033601872808748,
            5.421414242948537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.033601872808748,
            5.421414242948537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel local search that combines segment insertion with probabilistic edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n\n    # Add diversity factor\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)-1):\n            diversity += np.abs(sol[i] - sol[i+1])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    combined_scores = weighted_scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel local search: segment insertion with probabilistic edge swaps\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Segment insertion\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        # Probabilistic edge swaps\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.927690588706841,
            6.740442714524932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n\n    # Add diversity factor\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)-1):\n            diversity += np.abs(sol[i] - sol[i+1])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    combined_scores = weighted_scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel local search: segment insertion with probabilistic edge swaps\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Segment insertion\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n        # Probabilistic edge swaps\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto dominance-aware selection, then applies a hybrid local search combining a novel node swap with a probabilistic edge crossover to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions with better combined objective\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: novel node swap with probabilistic edge crossover\n        a, b = np.random.choice(N, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Novel node swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic edge crossover\n        if np.random.random() < 0.5:\n            c, d = np.random.choice(N, 2, replace=False)\n            if c > d:\n                c, d = d, c\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.171190641768389,
            7.130280296616104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions with better combined objective\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        is_dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: novel node swap with probabilistic edge crossover\n        a, b = np.random.choice(N, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Novel node swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic edge crossover\n        if np.random.random() < 0.5:\n            c, d = np.random.choice(N, 2, replace=False)\n            if c > d:\n                c, d = d, c\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining a randomized 2.5-opt move with a segment inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1,0] - sorted_objectives[i-1,0]) / (objectives[:,0].max() - objectives[:,0].min() + 1e-8) + \\\n                                   (sorted_objectives[i+1,1] - sorted_objectives[i-1,1]) / (objectives[:,1].max() - objectives[:,1].min() + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: randomized 2.5-opt with segment inversion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 2.5-opt move (partial rearrangement)\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n\n        new_order = np.concatenate([segment1, segment3, segment2])\n        new_solution[a:d] = new_order\n\n        # Segment inversion\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.777650509472466,
            8.887677516312257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with high crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:,1], objectives[:,0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1,0] - sorted_objectives[i-1,0]) / (objectives[:,0].max() - objectives[:,0].min() + 1e-8) + \\\n                                   (sorted_objectives[i+1,1] - sorted_objectives[i-1,1]) / (objectives[:,1].max() - objectives[:,1].min() + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: randomized 2.5-opt with segment inversion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 2.5-opt move (partial rearrangement)\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n\n        new_order = np.concatenate([segment1, segment3, segment2])\n        new_solution[a:d] = new_order\n\n        # Segment inversion\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining 3-opt with a probabilistic node swap to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic node swap\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node swap\n        if np.random.random() < 0.6:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.3743954429212994,
            6.711381431085356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic node swap\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node swap\n        if np.random.random() < 0.6:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware objective score, then applies a hybrid local search combining 3-opt with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = sorted_indices[i-1] if i > 0 else sorted_indices[i]\n        right = sorted_indices[i+1] if i < len(archive)-1 else sorted_indices[i]\n        crowding_distances[i] = np.abs(objectives[right, 0] - objectives[left, 0]) + np.abs(objectives[right, 1] - objectives[left, 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic segment reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.368644996405486,
            7.380175479521265
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = sorted_indices[i-1] if i > 0 else sorted_indices[i]\n        right = sorted_indices[i+1] if i < len(archive)-1 else sorted_indices[i]\n        crowding_distances[i] = np.abs(objectives[right, 0] - objectives[left, 0]) + np.abs(objectives[right, 1] - objectives[left, 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic segment reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and structural diversity, then applies a novel local search operator that combines a probabilistic node insertion with a guided segment reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with balanced objectives and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    balance_scores = 1 - np.abs(normalized_scores[:, 0] - normalized_scores[:, 1])\n    diversity_scores = np.std([np.unique(sol[0]) for sol, _ in archive], axis=0)\n    combined_scores = 0.6 * balance_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic node insertion with guided segment reversal\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        k = np.random.randint(0, N)\n\n        # Node insertion\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Guided segment reversal based on objective improvement\n        if np.random.random() < 0.8:\n            a, b = sorted(np.random.choice(N-1, 2, replace=False))\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate potential improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, N)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, N)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n            new_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) + sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n            # Accept reversal if it improves at least one objective\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.488509641675321,
            8.638684429865744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with balanced objectives and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    balance_scores = 1 - np.abs(normalized_scores[:, 0] - normalized_scores[:, 1])\n    diversity_scores = np.std([np.unique(sol[0]) for sol, _ in archive], axis=0)\n    combined_scores = 0.6 * balance_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic node insertion with guided segment reversal\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        k = np.random.randint(0, N)\n\n        # Node insertion\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Guided segment reversal based on objective improvement\n        if np.random.random() < 0.8:\n            a, b = sorted(np.random.choice(N-1, 2, replace=False))\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate potential improvement\n            old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, N)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, N)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))) + sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n            new_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))) + sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n            # Accept reversal if it improves at least one objective\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[a:b+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective crowding distance metric, then applies a novel local search combining a probabilistic node swap with a segment reversal that adapts its intensity based on the solution's current quality, ensuring high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1][0] - sorted_objectives[i-1][0]) / (sorted_objectives[-1][0] - sorted_objectives[0][0] + 1e-8) + \\\n                                   (sorted_objectives[i+1][1] - sorted_objectives[i-1][1]) / (sorted_objectives[-1][1] - sorted_objectives[0][1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Adaptive local search: probabilistic node swap with segment reversal\n        quality_score = crowding_distances[selected_idx] / (np.max(crowding_distances) + 1e-8)\n        swap_prob = 0.5 + 0.5 * quality_score  # Higher quality solutions get more aggressive swaps\n\n        for i in range(N):\n            if np.random.random() < swap_prob:\n                j = np.random.randint(0, N)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal with quality-based intensity\n        reversal_intensity = 0.2 + 0.8 * quality_score\n        if np.random.random() < reversal_intensity:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.50541502091994,
            10.649916078604127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1][0] - sorted_objectives[i-1][0]) / (sorted_objectives[-1][0] - sorted_objectives[0][0] + 1e-8) + \\\n                                   (sorted_objectives[i+1][1] - sorted_objectives[i-1][1]) / (sorted_objectives[-1][1] - sorted_objectives[0][1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Adaptive local search: probabilistic node swap with segment reversal\n        quality_score = crowding_distances[selected_idx] / (np.max(crowding_distances) + 1e-8)\n        swap_prob = 0.5 + 0.5 * quality_score  # Higher quality solutions get more aggressive swaps\n\n        for i in range(N):\n            if np.random.random() < swap_prob:\n                j = np.random.randint(0, N)\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment reversal with quality-based intensity\n        reversal_intensity = 0.2 + 0.8 * quality_score\n        if np.random.random() < reversal_intensity:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel multi-segment relocation strategy with adaptive segment length to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Adaptive multi-segment relocation\n        num_segments = np.random.randint(2, min(5, N//2))\n        segment_lengths = np.random.randint(2, min(5, N//num_segments), size=num_segments)\n        segment_indices = np.random.choice(N, size=num_segments, replace=False)\n        segment_indices.sort()\n\n        # Extract and relocate segments\n        segments = []\n        current_pos = 0\n        for i, idx in enumerate(segment_indices):\n            seg_len = segment_lengths[i]\n            if current_pos >= N:\n                break\n            seg_start = min(idx, N - seg_len)\n            seg_end = seg_start + seg_len\n            segments.append(new_solution[seg_start:seg_end])\n            new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert segments at new positions\n        insert_positions = np.random.choice(len(new_solution) + 1, size=len(segments), replace=False)\n        insert_positions.sort()\n        for i, pos in enumerate(insert_positions):\n            if i < len(segments):\n                new_solution = np.concatenate([new_solution[:pos], segments[i], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.629521669346724,
            6.702050457367366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Adaptive multi-segment relocation\n        num_segments = np.random.randint(2, min(5, N//2))\n        segment_lengths = np.random.randint(2, min(5, N//num_segments), size=num_segments)\n        segment_indices = np.random.choice(N, size=num_segments, replace=False)\n        segment_indices.sort()\n\n        # Extract and relocate segments\n        segments = []\n        current_pos = 0\n        for i, idx in enumerate(segment_indices):\n            seg_len = segment_lengths[i]\n            if current_pos >= N:\n                break\n            seg_start = min(idx, N - seg_len)\n            seg_end = seg_start + seg_len\n            segments.append(new_solution[seg_start:seg_end])\n            new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert segments at new positions\n        insert_positions = np.random.choice(len(new_solution) + 1, size=len(segments), replace=False)\n        insert_positions.sort()\n        for i, pos in enumerate(insert_positions):\n            if i < len(segments):\n                new_solution = np.concatenate([new_solution[:pos], segments[i], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.107927898422226,
            5.4204044935054885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.107927898422226,
            5.4204044935054885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel segment-based local search that combines adaptive segment reversal with probabilistic segment shifting to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    weighted_scores = 0.7 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Adaptive segment-based local search\n        segment_size = max(2, min(5, N // 4))\n        k = np.random.randint(segment_size, N - segment_size)\n        segment = new_solution[k:k+segment_size]\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.6:\n            segment = segment[::-1]\n\n        # Probabilistic segment shifting\n        if np.random.random() < 0.4:\n            shift = np.random.randint(1, segment_size)\n            segment = np.roll(segment, shift)\n\n        new_solution[k:k+segment_size] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.988169608563679,
            8.808072499571663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    weighted_scores = 0.7 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Adaptive segment-based local search\n        segment_size = max(2, min(5, N // 4))\n        k = np.random.randint(segment_size, N - segment_size)\n        segment = new_solution[k:k+segment_size]\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.6:\n            segment = segment[::-1]\n\n        # Probabilistic segment shifting\n        if np.random.random() < 0.4:\n            shift = np.random.randint(1, segment_size)\n            segment = np.roll(segment, shift)\n\n        new_solution[k:k+segment_size] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based selection criterion, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated[i] = True\n                break\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        a, b = np.random.choice(N, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge insertion\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.576612398920016,
            7.1367238924087975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    is_dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                is_dominated[i] = True\n                break\n    non_dominated_indices = np.where(~is_dominated)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        a, b = np.random.choice(N, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge insertion\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware ranking that prioritizes Pareto-frontier solutions, then applies a hybrid local search combining node swap with a probabilistic path inversion to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize Pareto-frontier solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: node swap with probabilistic path inversion\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.058117570334167,
            6.618714774362781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize Pareto-frontier solutions\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and np.all(objectives[j] <= objectives[i]) and np.any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: node swap with probabilistic path inversion\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.033067661776936,
            4.531907756863027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.033067661776936,
            4.531907756863027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to promote diversity, then applies a hybrid local search combining edge insertion with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (sorted_objectives[sorted_indices[j+1], i] - sorted_objectives[sorted_indices[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: Edge insertion with probabilistic segment reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge insertion\n        inserted_node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [inserted_node], new_solution[a:b], new_solution[b+1:]])\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.348829851360264,
            8.57824964088668
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (sorted_objectives[sorted_indices[j+1], i] - sorted_objectives[sorted_indices[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: Edge insertion with probabilistic segment reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Edge insertion\n        inserted_node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:a], [inserted_node], new_solution[a:b], new_solution[b+1:]])\n\n        # Probabilistic segment reversal\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of dominance and crowding distance metrics, then applies a novel hybrid local search combining a probabilistic segment shuffle with a guided edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better dominance and crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate dominance scores\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominates = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and \\\n                   (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominates += 1\n        dominance_scores[i] = dominates\n\n    # Calculate crowding distance\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distance = np.zeros(len(archive))\n    crowding_distance[sorted_indices[0]] = np.inf\n    crowding_distance[sorted_indices[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_distance[i] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    for i in range(1, len(archive)-1):\n        crowding_distance[i] += objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]\n\n    # Combine scores\n    combined_scores = (0.7 * dominance_scores + 0.3 * crowding_distance) / (dominance_scores.max() + crowding_distance.max() + 1e-8)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel hybrid local search: probabilistic segment shuffle with guided edge insertion\n        # Probabilistic segment shuffle\n        if np.random.random() < 0.6:\n            k = np.random.randint(2, min(5, N//2))\n            segments = np.array_split(new_solution, k)\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        if np.random.random() < 0.8:\n            # Find the worst edge in both objectives\n            total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n            total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n            worst_edge = -1\n            worst_cost = -1\n            for i in range(N):\n                cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]\n                cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n                combined_cost = 0.5 * cost1/total_cost1 + 0.5 * cost2/total_cost2\n                if combined_cost > worst_cost:\n                    worst_cost = combined_cost\n                    worst_edge = i\n\n            if worst_edge != -1:\n                # Remove the worst edge\n                i = worst_edge\n                j = (i + 1) % N\n                node_i = new_solution[i]\n                node_j = new_solution[j]\n\n                # Find the best insertion point for node_j\n                best_pos = -1\n                best_cost = np.inf\n                for pos in range(N-1):\n                    if pos != i and pos != j:\n                        cost1 = distance_matrix_1[new_solution[pos], node_j] + distance_matrix_1[node_j, new_solution[(pos+1)%N]]\n                        cost2 = distance_matrix_2[new_solution[pos], node_j] + distance_matrix_2[node_j, new_solution[(pos+1)%N]]\n                        combined_cost = 0.5 * cost1/total_cost1 + 0.5 * cost2/total_cost2\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_pos = pos\n\n                if best_pos != -1:\n                    # Insert node_j at best_pos\n                    if best_pos > i:\n                        new_solution = np.concatenate([\n                            new_solution[:i+1],\n                            new_solution[j:best_pos+1],\n                            [node_j],\n                            new_solution[best_pos+1:]\n                        ])\n                    else:\n                        new_solution = np.concatenate([\n                            new_solution[:best_pos+1],\n                            [node_j],\n                            new_solution[best_pos+1:i+1],\n                            new_solution[j:]\n                        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.458432605340455,
            10.547117994487134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better dominance and crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate dominance scores\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominates = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and \\\n                   (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominates += 1\n        dominance_scores[i] = dominates\n\n    # Calculate crowding distance\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distance = np.zeros(len(archive))\n    crowding_distance[sorted_indices[0]] = np.inf\n    crowding_distance[sorted_indices[-1]] = np.inf\n    for i in range(1, len(archive)-1):\n        crowding_distance[i] = objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]\n\n    sorted_indices = np.argsort(objectives[:, 1])\n    for i in range(1, len(archive)-1):\n        crowding_distance[i] += objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]\n\n    # Combine scores\n    combined_scores = (0.7 * dominance_scores + 0.3 * crowding_distance) / (dominance_scores.max() + crowding_distance.max() + 1e-8)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel hybrid local search: probabilistic segment shuffle with guided edge insertion\n        # Probabilistic segment shuffle\n        if np.random.random() < 0.6:\n            k = np.random.randint(2, min(5, N//2))\n            segments = np.array_split(new_solution, k)\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        if np.random.random() < 0.8:\n            # Find the worst edge in both objectives\n            total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n            total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%N]] for i in range(N))\n\n            worst_edge = -1\n            worst_cost = -1\n            for i in range(N):\n                cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]\n                cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n                combined_cost = 0.5 * cost1/total_cost1 + 0.5 * cost2/total_cost2\n                if combined_cost > worst_cost:\n                    worst_cost = combined_cost\n                    worst_edge = i\n\n            if worst_edge != -1:\n                # Remove the worst edge\n                i = worst_edge\n                j = (i + 1) % N\n                node_i = new_solution[i]\n                node_j = new_solution[j]\n\n                # Find the best insertion point for node_j\n                best_pos = -1\n                best_cost = np.inf\n                for pos in range(N-1):\n                    if pos != i and pos != j:\n                        cost1 = distance_matrix_1[new_solution[pos], node_j] + distance_matrix_1[node_j, new_solution[(pos+1)%N]]\n                        cost2 = distance_matrix_2[new_solution[pos], node_j] + distance_matrix_2[node_j, new_solution[(pos+1)%N]]\n                        combined_cost = 0.5 * cost1/total_cost1 + 0.5 * cost2/total_cost2\n                        if combined_cost < best_cost:\n                            best_cost = combined_cost\n                            best_pos = pos\n\n                if best_pos != -1:\n                    # Insert node_j at best_pos\n                    if best_pos > i:\n                        new_solution = np.concatenate([\n                            new_solution[:i+1],\n                            new_solution[j:best_pos+1],\n                            [node_j],\n                            new_solution[best_pos+1:]\n                        ])\n                    else:\n                        new_solution = np.concatenate([\n                            new_solution[:best_pos+1],\n                            [node_j],\n                            new_solution[best_pos+1:i+1],\n                            new_solution[j:]\n                        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and solution structure diversity, then applies a hybrid local search combining node swapping with a probabilistic segment inversion, which explores the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate solution diversity based on node order differences\n    diversity_scores = np.zeros(len(archive))\n    base_order = np.argsort(archive[0][0])\n    for i, (sol, _) in enumerate(archive):\n        order_diff = np.sum(np.argsort(sol) != base_order)\n        diversity_scores[i] = order_diff\n\n    # Combine scores with diversity\n    weights = np.array([0.5, 0.5])\n    combined_scores = np.sum(normalized_scores * weights, axis=1) + 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: node swapping with probabilistic segment inversion\n        a, b = np.random.choice(N, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.4:\n            seg_length = np.random.randint(2, min(4, N//2))\n            start = np.random.randint(0, N - seg_length)\n            new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.034102487076616,
            8.136637570468395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate solution diversity based on node order differences\n    diversity_scores = np.zeros(len(archive))\n    base_order = np.argsort(archive[0][0])\n    for i, (sol, _) in enumerate(archive):\n        order_diff = np.sum(np.argsort(sol) != base_order)\n        diversity_scores[i] = order_diff\n\n    # Combine scores with diversity\n    weights = np.array([0.5, 0.5])\n    combined_scores = np.sum(normalized_scores * weights, axis=1) + 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: node swapping with probabilistic segment inversion\n        a, b = np.random.choice(N, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic segment inversion\n        if np.random.random() < 0.4:\n            seg_length = np.random.randint(2, min(4, N//2))\n            start = np.random.randint(0, N - seg_length)\n            new_solution[start:start+seg_length] = new_solution[start:start+seg_length][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective performance and solution structure, then applies a novel \"cross-swap\" local search operator that exchanges segments between nodes in different objective spaces to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective performance\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_scores = objectives / (np.sum(objectives, axis=0) + 1e-8)\n    weighted_scores = np.sum(normalized_scores * np.array([0.5, 0.5]), axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Cross-swap local search: exchange segments between nodes in different objective spaces\n        split_point = np.random.randint(1, N-1)\n        segment1 = new_solution[:split_point]\n        segment2 = new_solution[split_point:]\n\n        # Evaluate segments in both objective spaces\n        cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1)) + distance_matrix_1[segment1[-1], segment1[0]]\n        cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1)) + distance_matrix_2[segment1[-1], segment1[0]]\n        cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1)) + distance_matrix_1[segment2[-1], segment2[0]]\n        cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1)) + distance_matrix_2[segment2[-1], segment2[0]]\n\n        # Determine which segment has better balance between objectives\n        if (cost1_seg1 + cost2_seg1) < (cost1_seg2 + cost2_seg2):\n            # Reverse the better segment to potentially improve both objectives\n            segment1 = segment1[::-1]\n        else:\n            segment2 = segment2[::-1]\n\n        # Reconstruct the solution\n        new_solution = np.concatenate([segment1, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.225742056167569,
            8.66014368995113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective performance\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_scores = objectives / (np.sum(objectives, axis=0) + 1e-8)\n    weighted_scores = np.sum(normalized_scores * np.array([0.5, 0.5]), axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Cross-swap local search: exchange segments between nodes in different objective spaces\n        split_point = np.random.randint(1, N-1)\n        segment1 = new_solution[:split_point]\n        segment2 = new_solution[split_point:]\n\n        # Evaluate segments in both objective spaces\n        cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1)) + distance_matrix_1[segment1[-1], segment1[0]]\n        cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1)) + distance_matrix_2[segment1[-1], segment1[0]]\n        cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1)) + distance_matrix_1[segment2[-1], segment2[0]]\n        cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1)) + distance_matrix_2[segment2[-1], segment2[0]]\n\n        # Determine which segment has better balance between objectives\n        if (cost1_seg1 + cost2_seg1) < (cost1_seg2 + cost2_seg2):\n            # Reverse the better segment to potentially improve both objectives\n            segment1 = segment1[::-1]\n        else:\n            segment2 = segment2[::-1]\n\n        # Reconstruct the solution\n        new_solution = np.concatenate([segment1, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective and diversity score, then applies a hybrid local search combining a novel \"objective-aware segment swap\" with probabilistic edge flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate diversity score\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity_scores[i] = np.sum(np.linalg.norm(normalized_scores - normalized_scores[i], axis=1))\n\n    # Combine objective and diversity scores\n    weights = np.array([0.5, 0.5])\n    combined_scores = np.sum(normalized_scores * weights, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: objective-aware segment swap with probabilistic edge flipping\n        # Select segments based on objective improvement potential\n        obj1 = objectives[selected_idx][0]\n        obj2 = objectives[selected_idx][1]\n\n        # Calculate segment costs\n        segment_length = max(2, N // 5)\n        segment_costs = np.zeros(N - segment_length + 1)\n\n        for i in range(N - segment_length + 1):\n            segment = new_solution[i:i+segment_length]\n            cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n            cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n            segment_costs[i] = (cost1 - obj1) + (cost2 - obj2)\n\n        # Select segments with high potential for improvement\n        best_segments = np.argsort(segment_costs)[:2]\n        if len(best_segments) > 1:\n            # Swap the best segments\n            seg1 = new_solution[best_segments[0]:best_segments[0]+segment_length]\n            seg2 = new_solution[best_segments[1]:best_segments[1]+segment_length]\n            new_solution[best_segments[0]:best_segments[0]+segment_length] = seg2\n            new_solution[best_segments[1]:best_segments[1]+segment_length] = seg1\n\n        # Probabilistic edge flipping\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j and abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.812500900047187,
            10.27697821850872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate diversity score\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity_scores[i] = np.sum(np.linalg.norm(normalized_scores - normalized_scores[i], axis=1))\n\n    # Combine objective and diversity scores\n    weights = np.array([0.5, 0.5])\n    combined_scores = np.sum(normalized_scores * weights, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: objective-aware segment swap with probabilistic edge flipping\n        # Select segments based on objective improvement potential\n        obj1 = objectives[selected_idx][0]\n        obj2 = objectives[selected_idx][1]\n\n        # Calculate segment costs\n        segment_length = max(2, N // 5)\n        segment_costs = np.zeros(N - segment_length + 1)\n\n        for i in range(N - segment_length + 1):\n            segment = new_solution[i:i+segment_length]\n            cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n            cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n            segment_costs[i] = (cost1 - obj1) + (cost2 - obj2)\n\n        # Select segments with high potential for improvement\n        best_segments = np.argsort(segment_costs)[:2]\n        if len(best_segments) > 1:\n            # Swap the best segments\n            seg1 = new_solution[best_segments[0]:best_segments[0]+segment_length]\n            seg2 = new_solution[best_segments[1]:best_segments[1]+segment_length]\n            new_solution[best_segments[0]:best_segments[0]+segment_length] = seg2\n            new_solution[best_segments[1]:best_segments[1]+segment_length] = seg1\n\n        # Probabilistic edge flipping\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j and abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score that combines both objectives and their improvement potential, then applies a novel local search combining segment swapping with probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better hybrid objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment swapping with probabilistic node insertion\n        seg_length = np.random.randint(2, min(5, N//2))\n        start1 = np.random.randint(0, N - seg_length)\n        start2 = np.random.randint(0, N - seg_length)\n        segment1 = new_solution[start1:start1+seg_length]\n        segment2 = new_solution[start2:start2+seg_length]\n\n        if start1 != start2:\n            new_solution[start1:start1+seg_length] = segment2\n            new_solution[start2:start2+seg_length] = segment1\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.4:\n            node = np.random.choice(new_solution)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            insert_pos = np.random.randint(0, N - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.095738493309005,
            8.066075754637975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better hybrid objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment swapping with probabilistic node insertion\n        seg_length = np.random.randint(2, min(5, N//2))\n        start1 = np.random.randint(0, N - seg_length)\n        start2 = np.random.randint(0, N - seg_length)\n        segment1 = new_solution[start1:start1+seg_length]\n        segment2 = new_solution[start2:start2+seg_length]\n\n        if start1 != start2:\n            new_solution[start1:start1+seg_length] = segment2\n            new_solution[start2:start2+seg_length] = segment1\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.4:\n            node = np.random.choice(new_solution)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            insert_pos = np.random.randint(0, N - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This algorithm selects a solution from the archive based on a distance-aware objective score that prioritizes solutions with better overall distance reduction potential, then applies a hybrid local search combining node swapping with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better distance reduction potential\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Distance-aware weighting: emphasize solutions with better overall distance reduction\n    distance_weights = 1 / (normalized_scores[:, 0] + normalized_scores[:, 1] + 1e-8)\n    distance_weights = distance_weights / np.sum(distance_weights)\n\n    weighted_scores = np.sum(normalized_scores * distance_weights.reshape(-1, 1), axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: node swapping with probabilistic path inversion\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.3:\n            start = np.random.randint(0, N - 1)\n            end = np.random.randint(start + 1, N)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.362622962821945,
            6.2255201212854585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better distance reduction potential\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Distance-aware weighting: emphasize solutions with better overall distance reduction\n    distance_weights = 1 / (normalized_scores[:, 0] + normalized_scores[:, 1] + 1e-8)\n    distance_weights = distance_weights / np.sum(distance_weights)\n\n    weighted_scores = np.sum(normalized_scores * distance_weights.reshape(-1, 1), axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: node swapping with probabilistic path inversion\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.3:\n            start = np.random.randint(0, N - 1)\n            end = np.random.randint(start + 1, N)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This algorithm selects a solution from the archive based on a quality-diversity tradeoff metric, then applies a novel hybrid local search combining edge swap with a probabilistic path inversion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better quality-diversity tradeoff\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Quality-diversity metric: balance objective values and diversity\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity_scores[i] = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n    tradeoff_metric = np.sum(normalized_scores * [0.5, 0.5], axis=1) + 0.3 * diversity_scores\n    selected_idx = np.argmin(tradeoff_metric)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N - 2)\n            end = np.random.randint(start + 2, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.733955267476318,
            7.814989202053488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better quality-diversity tradeoff\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Quality-diversity metric: balance objective values and diversity\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity_scores[i] = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n    tradeoff_metric = np.sum(normalized_scores * [0.5, 0.5], axis=1) + 0.3 * diversity_scores\n    selected_idx = np.argmin(tradeoff_metric)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N - 2)\n            end = np.random.randint(start + 2, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-based selection criterion, then applies a hybrid local search combining 4-opt with a biased edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = sorted_indices[i-1] if i > 0 else sorted_indices[i]\n        right = sorted_indices[i+1] if i < len(archive)-1 else sorted_indices[i]\n        crowding_distances[i] = objectives[right, 0] - objectives[left, 0]\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with biased edge insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Biased edge insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.449929842041023,
            7.922029079799981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = sorted_indices[i-1] if i > 0 else sorted_indices[i]\n        right = sorted_indices[i+1] if i < len(archive)-1 else sorted_indices[i]\n        crowding_distances[i] = objectives[right, 0] - objectives[left, 0]\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with biased edge insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Biased edge insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.7339966968769716,
            8.558740670390453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.7339966968769716,
            8.558740670390453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a novel local search operator that combines edge insertion with a probabilistic segment rotation to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[-1, 0] - objectives[0, 0] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel local search: Edge insertion with probabilistic segment rotation\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge insertion\n        removed_edges = [new_solution[a-1], new_solution[a], new_solution[b-1], new_solution[b]]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n        # Probabilistic segment rotation\n        if np.random.random() < 0.7:\n            k = np.random.randint(2, N//2)\n            new_solution = np.roll(new_solution, k)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.673377530974083,
            8.879546103273157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[-1, 0] - objectives[0, 0] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel local search: Edge insertion with probabilistic segment rotation\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge insertion\n        removed_edges = [new_solution[a-1], new_solution[a], new_solution[b-1], new_solution[b]]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n        # Probabilistic segment rotation\n        if np.random.random() < 0.7:\n            k = np.random.randint(2, N//2)\n            new_solution = np.roll(new_solution, k)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a segment-based swap with a probabilistic edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Combine objective score and diversity measure\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(sol != other_sol) / len(sol)\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = 0.7 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] - 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: segment-based swap with probabilistic edge insertion\n        k = np.random.randint(2, min(5, N//2))\n        segments = np.random.choice(N, size=k, replace=False)\n        segments = np.sort(segments)\n\n        # Segment-based swap\n        for i in range(len(segments)-1):\n            a, b = segments[i], segments[i+1]\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.224588883115435,
            6.965308816045784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Combine objective score and diversity measure\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        diversity = 0\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(sol != other_sol) / len(sol)\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = 0.7 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] - 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: segment-based swap with probabilistic edge insertion\n        k = np.random.randint(2, min(5, N//2))\n        segments = np.random.choice(N, size=k, replace=False)\n        segments = np.sort(segments)\n\n        # Segment-based swap\n        for i in range(len(segments)-1):\n            a, b = segments[i], segments[i+1]\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel segment-based local search that combines partial path reversal with probabilistic edge swaps to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.7, 0.3])  # Balance between objectives and diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n\n    # Add diversity consideration by including crowding distance\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (max_vals[i] - min_vals[i] + 1e-8)\n\n    combined_scores = weighted_scores - 0.3 * crowding_distances  # Penalize crowded solutions\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel segment-based local search\n        segment_size = max(2, int(0.2 * N))\n        start = np.random.randint(0, N - segment_size)\n        end = start + segment_size\n\n        # Partial path reversal with probability\n        if np.random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge swaps\n        if np.random.random() < 0.4:\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            if b - a > 1:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.394783200839466,
            10.577219523384478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.7, 0.3])  # Balance between objectives and diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n\n    # Add diversity consideration by including crowding distance\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (max_vals[i] - min_vals[i] + 1e-8)\n\n    combined_scores = weighted_scores - 0.3 * crowding_distances  # Penalize crowded solutions\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel segment-based local search\n        segment_size = max(2, int(0.2 * N))\n        start = np.random.randint(0, N - segment_size)\n        end = start + segment_size\n\n        # Partial path reversal with probability\n        if np.random.random() < 0.6:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge swaps\n        if np.random.random() < 0.4:\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            if b - a > 1:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances both objectives, then applies a hybrid local search combining segment shuffling with probabilistic edge insertion to generate diverse and high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with balanced normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment shuffling with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        segment = new_solution[a:b]\n\n        # Shuffle the segment\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.251362806128759,
            6.80185383701849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with balanced normalized objectives\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment shuffling with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n        segment = new_solution[a:b]\n\n        # Shuffle the segment\n        np.random.shuffle(segment)\n        new_solution[a:b] = segment\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = np.random.randint(0, N-1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to promote diversity, then applies a hybrid local search combining a novel segment rotation with a probabilistic node swap to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + \\\n                                   (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment rotation with probabilistic node swap\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Probabilistic node swap\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.300515702427663,
            8.841514155912789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with higher crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + \\\n                                   (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment rotation with probabilistic node swap\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Probabilistic node swap\n        if np.random.random() < 0.3:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining a modified 4-opt move with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores * [0.5, 0.5], axis=1) + 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        # Hybrid local search: modified 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move with segment rotation\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n        new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.561904228728415,
            6.304103864425845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores * [0.5, 0.5], axis=1) + 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        # Hybrid local search: modified 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move with segment rotation\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:d]\n        new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized first objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on first objective\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path reversal\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[end:start:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.23541669426597,
            8.84374755206405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized first objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on first objective\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path reversal\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[end:start:-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance-aware selection, then applies a hybrid local search combining a novel \"segment rotation\" operator with a probabilistic \"node swap with nearest neighbor\" to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1, m] - sorted_objectives[i-1, m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment rotation with probabilistic node swap\n        i = np.random.randint(0, N-4)\n        k = np.random.randint(3, min(6, N-i))\n\n        # Segment rotation\n        segment = new_solution[i:i+k]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[i:i+k] = rotated_segment\n\n        # Probabilistic node swap with nearest neighbor\n        if np.random.random() < 0.6:\n            j = np.random.randint(0, N)\n            node = new_solution[j]\n\n            # Find nearest neighbor in both distance matrices\n            dist1 = distance_matrix_1[node]\n            dist2 = distance_matrix_2[node]\n            combined_dist = dist1 + dist2\n\n            # Exclude current position and itself\n            mask = np.ones(N, dtype=bool)\n            mask[j] = False\n            mask[node] = False\n\n            if np.any(mask):\n                candidates = np.where(mask)[0]\n                nearest = candidates[np.argmin(combined_dist[candidates])]\n                new_solution[j], new_solution[np.where(new_solution == nearest)[0][0]] = new_solution[np.where(new_solution == nearest)[0][0]], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.10416190922881,
            8.989910788914461
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better crowding distance\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i+1, m] - sorted_objectives[i-1, m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: segment rotation with probabilistic node swap\n        i = np.random.randint(0, N-4)\n        k = np.random.randint(3, min(6, N-i))\n\n        # Segment rotation\n        segment = new_solution[i:i+k]\n        rotated_segment = np.roll(segment, np.random.randint(1, len(segment)))\n        new_solution[i:i+k] = rotated_segment\n\n        # Probabilistic node swap with nearest neighbor\n        if np.random.random() < 0.6:\n            j = np.random.randint(0, N)\n            node = new_solution[j]\n\n            # Find nearest neighbor in both distance matrices\n            dist1 = distance_matrix_1[node]\n            dist2 = distance_matrix_2[node]\n            combined_dist = dist1 + dist2\n\n            # Exclude current position and itself\n            mask = np.ones(N, dtype=bool)\n            mask[j] = False\n            mask[node] = False\n\n            if np.any(mask):\n                candidates = np.where(mask)[0]\n                nearest = candidates[np.argmin(combined_dist[candidates])]\n                new_solution[j], new_solution[np.where(new_solution == nearest)[0][0]] = new_solution[np.where(new_solution == nearest)[0][0]], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a novel segment rotation and inversion operator to generate neighbors that balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        crowding_distances = np.zeros(len(archive))\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_indices_2 = np.argsort(objectives[:, 1])\n\n        for i in range(len(archive)):\n            if i == 0 or i == len(archive)-1:\n                crowding_distances[i] = float('inf')\n            else:\n                crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n                crowding_distances[i] += (objectives[sorted_indices_2[i+1], 1] - objectives[sorted_indices_2[i-1], 1]) / (objectives[sorted_indices_2[-1], 1] - objectives[sorted_indices_2[0], 1] + 1e-8)\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N-segment_length)\n        end = start + segment_length\n\n        if np.random.random() < 0.7:\n            rotation = np.random.randint(1, segment_length)\n            new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n        else:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.640399200741387,
            10.134111615327608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        crowding_distances = np.zeros(len(archive))\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_indices_2 = np.argsort(objectives[:, 1])\n\n        for i in range(len(archive)):\n            if i == 0 or i == len(archive)-1:\n                crowding_distances[i] = float('inf')\n            else:\n                crowding_distances[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0] + 1e-8)\n                crowding_distances[i] += (objectives[sorted_indices_2[i+1], 1] - objectives[sorted_indices_2[i-1], 1]) / (objectives[sorted_indices_2[-1], 1] - objectives[sorted_indices_2[0], 1] + 1e-8)\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N-segment_length)\n        end = start + segment_length\n\n        if np.random.random() < 0.7:\n            rotation = np.random.randint(1, segment_length)\n            new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n        else:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score that emphasizes both improvement potential and solution uniqueness, then applies a hybrid local search combining segment relocations with a probabilistic node reinsertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.std(normalized_scores, axis=0)\n    weights = 0.6 * diversity_scores + 0.4 * np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N // 2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:],\n            segment\n        ])\n\n        if np.random.random() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.where(new_solution == node)[0][0]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.446427980066814,
            8.319002408176013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.std(normalized_scores, axis=0)\n    weights = 0.6 * diversity_scores + 0.4 * np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N // 2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:],\n            segment\n        ])\n\n        if np.random.random() < 0.5:\n            node = np.random.choice(new_solution)\n            pos = np.where(new_solution == node)[0][0]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric that balances both objectives, then applies a novel segment-based local search that combines probabilistic segment rotation with edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using crowding distance metric\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[i] = abs(objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + \\\n                               abs(objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Segment-based local search\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Probabilistic segment rotation\n        if np.random.random() < 0.5:\n            rotation = np.random.randint(1, segment_length)\n            segment = new_solution[start:end]\n            new_solution[start:end] = np.concatenate([segment[rotation:], segment[:rotation]])\n        else:\n            # Edge swap within segment\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.522322083673554,
            9.593603141607352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution using crowding distance metric\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding_distances[i] = abs(objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + \\\n                               abs(objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Segment-based local search\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Probabilistic segment rotation\n        if np.random.random() < 0.5:\n            rotation = np.random.randint(1, segment_length)\n            segment = new_solution[start:end]\n            new_solution[start:end] = np.concatenate([segment[rotation:], segment[:rotation]])\n        else:\n            # Edge swap within segment\n            i = np.random.randint(start, end)\n            j = np.random.randint(start, end)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto-dominance-aware selection criterion, then applies a hybrid local search combining 4-opt with a distance-based edge exchange to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions with better diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        # Hybrid local search: 4-opt with distance-based edge exchange\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Distance-based edge exchange\n        for _ in range(2):\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (dist1_after + dist2_after) < (dist1_before + dist2_before):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.531999958308326,
            7.264932073491142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize non-dominated solutions with better diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        # Hybrid local search: 4-opt with distance-based edge exchange\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Distance-based edge exchange\n        for _ in range(2):\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                dist1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                dist1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                dist2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                dist2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (dist1_after + dist2_after) < (dist1_before + dist2_before):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions of the Pareto front, then applies a hybrid local search combining 3-opt with a probabilistic edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_solutions = [archive[i][0] for i in sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = abs(objectives[i-1][0] - objectives[i+1][0]) + abs(objectives[i-1][1] - objectives[i+1][1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = sorted_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        a, b, c = sorted(np.random.choice(N, 3, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.934093018499298,
            9.81261518960686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_solutions = [archive[i][0] for i in sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = abs(objectives[i-1][0] - objectives[i+1][0]) + abs(objectives[i-1][1] - objectives[i+1][1])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = sorted_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        a, b, c = sorted(np.random.choice(N, 3, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining segment reversal and probabilistic edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    N = len(solutions[0])\n\n    if len(archive) == 1:\n        base_solution = solutions[0].copy()\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_distances = np.zeros(len(sorted_objectives))\n        crowding_distances[1:-1] = (sorted_objectives[2:, 1] - sorted_objectives[:-2, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = solutions[sorted_indices[selected_idx]].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.0034753522028,
            7.636500866217169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    N = len(solutions[0])\n\n    if len(archive) == 1:\n        base_solution = solutions[0].copy()\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_distances = np.zeros(len(sorted_objectives))\n        crowding_distances[1:-1] = (sorted_objectives[2:, 1] - sorted_objectives[:-2, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = solutions[sorted_indices[selected_idx]].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that emphasizes both objectives equally, then applies a novel local search operator that combines segment reversal with probabilistic edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Segment reversal\n        start = np.random.randint(0, N)\n        end = np.random.randint(start, N)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.048099039779763,
            5.91176485321344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Segment reversal\n        start = np.random.randint(0, N)\n        end = np.random.randint(start, N)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insert_pos = np.random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.693109339446275,
            4.482075269241729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.693109339446275,
            4.482075269241729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in both objectives while applying a hybrid local search combining edge swaps with a probabilistic path inversion and a novel segment rotation operation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N)\n            segment_length = np.random.randint(1, N // 2)\n            new_solution[k:] = np.roll(new_solution[k:], segment_length)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.53682070402421,
            6.32005900020254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N)\n            segment_length = np.random.randint(1, N // 2)\n            new_solution[k:] = np.roll(new_solution[k:], segment_length)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal and segment rotation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            length = np.random.randint(2, min(5, N))\n            segment = new_solution[start:start+length]\n            new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[start+length:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.723621005938316,
            4.9677753075892594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            length = np.random.randint(2, min(5, N))\n            segment = new_solution[start:start+length]\n            new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[start+length:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances improvement potential in both objectives while applying a hybrid local search combining segment relocations with a probabilistic path rotation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        if np.random.random() < 0.7:\n            segment = new_solution[start:end]\n            rotation = np.random.randint(1, segment_length)\n            rotated_segment = np.roll(segment, rotation)\n            new_solution[start:end] = rotated_segment\n        else:\n            insert_pos = np.random.randint(0, N)\n            if insert_pos > start:\n                segment = new_solution[start:end]\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:insert_pos], segment, new_solution[insert_pos:]])\n            else:\n                segment = new_solution[start:end]\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.46186894098203,
            6.288546950677598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        if np.random.random() < 0.7:\n            segment = new_solution[start:end]\n            rotation = np.random.randint(1, segment_length)\n            rotated_segment = np.roll(segment, rotation)\n            new_solution[start:end] = rotated_segment\n        else:\n            insert_pos = np.random.randint(0, N)\n            if insert_pos > start:\n                segment = new_solution[start:end]\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:insert_pos], segment, new_solution[insert_pos:]])\n            else:\n                segment = new_solution[start:end]\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance score that prioritizes non-dominated solutions, then applies a hybrid local search combining edge insertions with a probabilistic 3-opt move to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        if np.random.random() < 0.5:\n            a = np.random.randint(0, N)\n            b = np.random.randint(a, N)\n            c = np.random.randint(b, N)\n            segment = new_solution[b:c]\n            new_solution = np.concatenate([new_solution[:b], segment[::-1], new_solution[c:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.669137778057362,
            6.697733953835435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if np.all(other_obj <= obj) and np.any(other_obj < obj):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        if np.random.random() < 0.5:\n            a = np.random.randint(0, N)\n            b = np.random.randint(a, N)\n            c = np.random.randint(b, N)\n            segment = new_solution[b:c]\n            new_solution = np.concatenate([new_solution[:b], segment[::-1], new_solution[c:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion and a novel edge insertion strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            if k != l:\n                new_solution = np.insert(new_solution, k, new_solution[l])\n                new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.045807471803784,
            5.053920813144145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            if k != l:\n                new_solution = np.insert(new_solution, k, new_solution[l])\n                new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This algorithm first selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining a probabilistic segment reversal with a greedy edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.094287994922029,
            9.574814235218689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j+1 if j > i else j)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized second objective score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Weight more on second objective\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge swap with probabilistic path inversion\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Probabilistic path inversion\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines objective improvement potential with solution diversity, then applies a novel local search operator that combines segment relocations with probabilistic edge insertions to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: combine objective improvement with diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for (sol, _) in archive:\n        diversity = 0\n        for i in range(len(sol)-1):\n            diversity += np.abs(sol[i] - sol[i+1])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    # Combine objective and diversity scores\n    weights = np.array([0.5, 0.3, 0.2])  # objective1, objective2, diversity\n    combined_scores = np.column_stack((normalized_scores, diversity_scores))\n    weighted_scores = np.sum(combined_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel local search: segment relocation with probabilistic edge insertion\n        if np.random.random() < 0.7:\n            # Segment relocation\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n                if len(new_solution) > N:\n                    new_solution = new_solution[:N]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.371006412645197,
            8.384584888287577
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: combine objective improvement with diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for (sol, _) in archive:\n        diversity = 0\n        for i in range(len(sol)-1):\n            diversity += np.abs(sol[i] - sol[i+1])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    # Combine objective and diversity scores\n    weights = np.array([0.5, 0.3, 0.2])  # objective1, objective2, diversity\n    combined_scores = np.column_stack((normalized_scores, diversity_scores))\n    weighted_scores = np.sum(combined_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Novel local search: segment relocation with probabilistic edge insertion\n        if np.random.random() < 0.7:\n            # Segment relocation\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n                if len(new_solution) > N:\n                    new_solution = new_solution[:N]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal and node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            pos = np.random.randint(0, N)\n            node = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.299502314496863,
            5.172410417497498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            pos = np.random.randint(0, N)\n            node = new_solution[pos]\n            new_solution = np.delete(new_solution, pos)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that emphasizes balanced improvement across both objectives while applying a novel local search operator that combines probabilistic segment shifts with a multi-objective-aware edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        if np.random.random() < 0.7:\n            new_pos = np.random.randint(0, N - segment_length)\n            if new_pos != start:\n                new_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+segment_length:new_pos],\n                    segment,\n                    new_solution[new_pos:]\n                ])\n        else:\n            for i in range(len(segment)):\n                if np.random.random() < 0.3:\n                    insert_pos = np.random.randint(0, N)\n                    if insert_pos != start + i:\n                        node = segment[i]\n                        new_solution = np.concatenate([\n                            new_solution[:start+i],\n                            new_solution[start+i+1:insert_pos],\n                            [node],\n                            new_solution[insert_pos:]\n                        ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.351816943654633,
            6.764334803227442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        if np.random.random() < 0.7:\n            new_pos = np.random.randint(0, N - segment_length)\n            if new_pos != start:\n                new_solution = np.concatenate([\n                    new_solution[:start],\n                    new_solution[start+segment_length:new_pos],\n                    segment,\n                    new_solution[new_pos:]\n                ])\n        else:\n            for i in range(len(segment)):\n                if np.random.random() < 0.3:\n                    insert_pos = np.random.randint(0, N)\n                    if insert_pos != start + i:\n                        node = segment[i]\n                        new_solution = np.concatenate([\n                            new_solution[:start+i],\n                            new_solution[start+i+1:insert_pos],\n                            [node],\n                            new_solution[insert_pos:]\n                        ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes balanced improvement in both objectives while applying a hybrid local search combining probabilistic edge swaps with a dynamic segment reversal based on local cost differences to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        for _ in range(2):\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        for _ in range(2):\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            if len(segment) > 1:\n                if np.random.random() < 0.7:\n                    new_solution[start:end] = segment[::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.651480907778546,
            7.503931399521322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        for _ in range(2):\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        for _ in range(2):\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            if len(segment) > 1:\n                if np.random.random() < 0.7:\n                    new_solution[start:end] = segment[::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions of the Pareto front, then applies a novel hybrid local search combining a probabilistic 3-opt move with a segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(len(sorted_objectives)):\n        if i == 0 or i == len(sorted_objectives) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                   (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            k = np.random.randint(0, N)\n            if i != j and i != k and j != k:\n                segment = new_solution[[i, j, k]]\n                new_solution = np.delete(new_solution, [i, j, k])\n                for _ in range(3):\n                    pos = np.random.randint(0, len(new_solution))\n                    new_solution = np.insert(new_solution, pos, segment[_])\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, slice(start, end))\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.8209334329550195,
            10.768932116604645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(len(sorted_objectives)):\n        if i == 0 or i == len(sorted_objectives) - 1:\n            crowding_distances[i] = np.inf\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                   (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            k = np.random.randint(0, N)\n            if i != j and i != k and j != k:\n                segment = new_solution[[i, j, k]]\n                new_solution = np.delete(new_solution, [i, j, k])\n                for _ in range(3):\n                    pos = np.random.randint(0, len(new_solution))\n                    new_solution = np.insert(new_solution, pos, segment[_])\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, slice(start, end))\n            pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objectives and diversity metrics, then applies a novel local search combining adaptive segment swapping with probabilistic edge flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = min(3, N // 2)\n        seg1_start = np.random.randint(0, N - k)\n        seg1_end = seg1_start + k\n        seg2_start = np.random.randint(0, N - k)\n        seg2_end = seg2_start + k\n\n        if seg1_start != seg2_start:\n            seg1 = new_solution[seg1_start:seg1_end]\n            seg2 = new_solution[seg2_start:seg2_end]\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n\n        if np.random.random() < 0.4:\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.290689604960116,
            8.219242158130445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = min(3, N // 2)\n        seg1_start = np.random.randint(0, N - k)\n        seg1_end = seg1_start + k\n        seg2_start = np.random.randint(0, N - k)\n        seg2_end = seg2_start + k\n\n        if seg1_start != seg2_start:\n            seg1 = new_solution[seg1_start:seg1_end]\n            seg2 = new_solution[seg2_start:seg2_end]\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n\n        if np.random.random() < 0.4:\n            a, b = np.random.choice(N, 2, replace=False)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric in the objective space, then applies a hybrid local search combining a segment relocation with a probabilistic edge insertion to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_start = np.random.randint(0, N)\n        segment_end = np.random.randint(segment_start, N)\n        segment = new_solution[segment_start:segment_end]\n\n        insertion_point = np.random.randint(0, N)\n        new_solution = np.concatenate([\n            new_solution[:insertion_point],\n            segment,\n            new_solution[insertion_point:segment_start],\n            new_solution[segment_end:]\n        ])\n\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.713778068139832,
            7.8658684671687205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_start = np.random.randint(0, N)\n        segment_end = np.random.randint(segment_start, N)\n        segment = new_solution[segment_start:segment_end]\n\n        insertion_point = np.random.randint(0, N)\n        new_solution = np.concatenate([\n            new_solution[:insertion_point],\n            segment,\n            new_solution[insertion_point:segment_start],\n            new_solution[segment_end:]\n        ])\n\n        if np.random.random() < 0.5:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal and segment rotation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(1, N//2)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.766435707509103,
            4.779827369976217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(1, N//2)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a probabilistic 3-opt local search with adaptive segment lengths to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive)\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(N)\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, N-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    # Select solution with lowest crowding distance (most isolated)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Probabilistic 3-opt with adaptive segment lengths\n        if np.random.random() < 0.7:\n            # Select three distinct random points\n            i, j, k = np.random.choice(N, size=3, replace=False)\n            i, j, k = sorted([i, j, k])\n\n            # Apply 3-opt move\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            segment3 = new_solution[k:] if k < N else new_solution[:k]\n\n            # Try all possible combinations\n            options = [\n                np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n                np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n                np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n                np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3]),\n                np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n                np.concatenate([new_solution[:i], segment2, segment1[::-1], segment3]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], segment3])\n            ]\n\n            # Select the best option based on both objectives\n            best_option = new_solution\n            best_score = np.inf\n            for option in options:\n                if len(np.unique(option)) != N:\n                    continue\n                cost1 = sum(distance_matrix_1[option[i], option[(i+1)%N]] for i in range(N))\n                cost2 = sum(distance_matrix_2[option[i], option[(i+1)%N]] for i in range(N))\n                score = cost1 + cost2\n                if score < best_score:\n                    best_score = score\n                    best_option = option.copy()\n\n            new_solution = best_option\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.298161312304946,
            7.103057601407283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive)\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(N)\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, N-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n\n    # Select solution with lowest crowding distance (most isolated)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Probabilistic 3-opt with adaptive segment lengths\n        if np.random.random() < 0.7:\n            # Select three distinct random points\n            i, j, k = np.random.choice(N, size=3, replace=False)\n            i, j, k = sorted([i, j, k])\n\n            # Apply 3-opt move\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            segment3 = new_solution[k:] if k < N else new_solution[:k]\n\n            # Try all possible combinations\n            options = [\n                np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n                np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n                np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n                np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3]),\n                np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n                np.concatenate([new_solution[:i], segment2, segment1[::-1], segment3]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n                np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], segment3])\n            ]\n\n            # Select the best option based on both objectives\n            best_option = new_solution\n            best_score = np.inf\n            for option in options:\n                if len(np.unique(option)) != N:\n                    continue\n                cost1 = sum(distance_matrix_1[option[i], option[(i+1)%N]] for i in range(N))\n                cost2 = sum(distance_matrix_2[option[i], option[(i+1)%N]] for i in range(N))\n                score = cost1 + cost2\n                if score < best_score:\n                    best_score = score\n                    best_option = option.copy()\n\n            new_solution = best_option\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances both objectives equally, then applies a novel local search strategy that combines probabilistic segment relocations with a distance-based edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while i == j:\n                j = np.random.randint(0, N)\n            dist1_i = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]\n            dist1_j = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            dist2_i = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n            dist2_j = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            if (dist1_i + dist1_j) > (dist2_i + dist2_j):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.076302179376208,
            6.3615316050650295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while i == j:\n                j = np.random.randint(0, N)\n            dist1_i = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%N]]\n            dist1_j = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n            dist2_i = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%N]]\n            dist2_j = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n            if (dist1_i + dist1_j) > (dist2_i + dist2_j):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining random node insertions with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            temp = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.886893393088873,
            8.309355968667848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            temp = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining random node insertions with a probabilistic 3-opt move to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n        if np.random.random() < 0.7:\n            a, b, c = np.random.choice(N, size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.187469773789543,
            8.975908977500282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i]) / (sorted_objectives[-1, i] - sorted_objectives[0, i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n        if np.random.random() < 0.7:\n            a, b, c = np.random.choice(N, size=3, replace=False)\n            a, b, c = sorted([a, b, c])\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[b:c] = new_solution[b:c][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that prioritizes solutions with high potential for improvement in both objectives while applying a novel local search operator that combines segment relocations with probabilistic edge insertions to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.48668394334436,
            10.670971767068158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        insert_pos = np.random.randint(0, len(new_solution) + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This algorithm selects a solution from the archive using a dynamic weighted score that prioritizes solutions with better performance in the second objective while applying a hybrid local search combining edge swaps with a probabilistic segment reversal and insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.284334080812684,
            4.698817888975156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and objective improvement potential, then applies a novel hybrid local search combining edge swaps with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (max_vals[i] - min_vals[i] + 1e-8)\n\n    # Combine normalized scores and crowding distance\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.4 * normalized_scores[:, 1] - 0.2 * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Apply edge swap\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply probabilistic segment insertion\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.429814881915274,
            8.562827578322128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (max_vals[i] - min_vals[i] + 1e-8)\n\n    # Combine normalized scores and crowding distance\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.4 * normalized_scores[:, 1] - 0.2 * crowding_distances\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Apply edge swap\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply probabilistic segment insertion\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining edge swaps with a probabilistic segment reversal and a novel node insertion heuristic to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.3:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            pos = np.random.randint(1, N-1)\n            node = new_solution[pos]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:], [node]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.402120004012078,
            9.825971096179092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.3:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            pos = np.random.randint(1, N-1)\n            node = new_solution[pos]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:], [node]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This algorithm selects the best solution from the archive based on a combined objective score, then applies a novel \"segmented crossover and inversion\" local search that recombines random segments of the tour with inverted segments to create diverse, high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    combined_scores = objectives[:, 0] + 0.5 * objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segments = []\n        num_segments = np.random.randint(2, 5)\n        segment_indices = np.sort(np.random.choice(np.arange(1, N), num_segments, replace=False))\n\n        prev_idx = 0\n        for idx in segment_indices:\n            segments.append(new_solution[prev_idx:idx])\n            prev_idx = idx\n        segments.append(new_solution[prev_idx:])\n\n        np.random.shuffle(segments)\n\n        if np.random.random() < 0.7:\n            for i in range(len(segments)):\n                if np.random.random() < 0.5:\n                    segments[i] = segments[i][::-1]\n\n        new_solution = np.concatenate(segments)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.884631488324362,
            7.992982753614399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    combined_scores = objectives[:, 0] + 0.5 * objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segments = []\n        num_segments = np.random.randint(2, 5)\n        segment_indices = np.sort(np.random.choice(np.arange(1, N), num_segments, replace=False))\n\n        prev_idx = 0\n        for idx in segment_indices:\n            segments.append(new_solution[prev_idx:idx])\n            prev_idx = idx\n        segments.append(new_solution[prev_idx:])\n\n        np.random.shuffle(segments)\n\n        if np.random.random() < 0.7:\n            for i in range(len(segments)):\n                if np.random.random() < 0.5:\n                    segments[i] = segments[i][::-1]\n\n        new_solution = np.concatenate(segments)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining segment relocations with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            segment_length = np.random.randint(1, min(4, N//2))\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.075256403776407,
            4.76939580630725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            segment_length = np.random.randint(1, min(4, N//2))\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a solution from the archive using a dynamic weighted score that prioritizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal and segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            segment_length = np.random.randint(2, min(5, N))\n            pos = np.random.randint(0, N - segment_length)\n            segment = new_solution[pos:pos+segment_length]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+segment_length:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.92757235335476,
            4.8992297570346635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            segment_length = np.random.randint(2, min(5, N))\n            pos = np.random.randint(0, N - segment_length)\n            segment = new_solution[pos:pos+segment_length]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+segment_length:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined normalized objective score that balances both objectives, then applies a novel local search operator that combines probabilistic segment rotation with adaptive edge swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.5332986056852995,
            7.080573662178226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel hybrid local search combining edge reinsertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        objectives_sorted = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            if objectives_sorted[-1] != objectives_sorted[0]:\n                crowding_distances[sorted_idx[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if np.random.random() < 0.4:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.598955554404224,
            9.801261053882683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.zeros(len(objectives))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        objectives_sorted = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(objectives)-1):\n            if objectives_sorted[-1] != objectives_sorted[0]:\n                crowding_distances[sorted_idx[i]] += (objectives_sorted[i+1] - objectives_sorted[i-1]) / (objectives_sorted[-1] - objectives_sorted[0])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if np.random.random() < 0.4:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that emphasizes solutions with balanced improvements in both objectives, then applies a novel local search strategy that combines a probabilistic segment rotation with a distance-aware edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    balanced_scores = np.prod(normalized_scores, axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            length = np.random.randint(2, min(5, N))\n            end = min(start + length, N)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                if distance_matrix_1[new_solution[(i-1)%N], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] < \\\n                   distance_matrix_1[new_solution[(i-1)%N], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.154072657312362,
            7.2166939866040165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    balanced_scores = np.prod(normalized_scores, axis=1)\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            length = np.random.randint(2, min(5, N))\n            end = min(start + length, N)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                if distance_matrix_1[new_solution[(i-1)%N], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]] < \\\n                   distance_matrix_1[new_solution[(i-1)%N], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution from the archive based on a fitness score derived from the Pareto dominance relationship and applies a novel local search operator that combines edge insertion with a probabilistic double-bridge move to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    dominated_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n\n    non_dominated_indices = np.where(dominated_count == 0)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if np.random.random() < 0.3:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            c, d = sorted(np.random.choice(N, 2, replace=False))\n            if a < c < b < d:\n                segment1 = new_solution[a:b]\n                segment2 = new_solution[c:d]\n                new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.428595998577494,
            6.619698427963452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    dominated_count = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n\n    non_dominated_indices = np.where(dominated_count == 0)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        if np.random.random() < 0.3:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            c, d = sorted(np.random.choice(N, 2, replace=False))\n            if a < c < b < d:\n                segment1 = new_solution[a:b]\n                segment2 = new_solution[c:d]\n                new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that emphasizes both objectives equally, then applies a novel local search that combines segment rotation with probabilistic edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_size = np.random.randint(2, min(5, N // 2))\n        start = np.random.randint(0, N - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.011594101538836,
            6.173609658968008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_size = np.random.randint(2, min(5, N // 2))\n        start = np.random.randint(0, N - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized improvements in both objectives while applying a novel local search strategy that combines probabilistic partial path rotation with adaptive edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = np.random.randint(1, min(5, N//2))\n        start = np.random.randint(0, N - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.4542897640545505,
            6.646854299786858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = np.random.randint(1, min(5, N//2))\n        start = np.random.randint(0, N - k)\n        segment = new_solution[start:start+k]\n        np.random.shuffle(segment)\n        new_solution[start:start+k] = segment\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a hybrid local search combining random node insertions with a probabilistic edge reversal to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8)\n\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.roll(new_solution, (j-i) % N)\n\n        if np.random.random() < 0.7:\n            a = np.random.randint(0, N)\n            b = np.random.randint(0, N)\n            if a != b:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.324499254977018,
            7.9780560417727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding_distances[sorted_indices[i]] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8)\n\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.roll(new_solution, (j-i) % N)\n\n        if np.random.random() < 0.7:\n            a = np.random.randint(0, N)\n            b = np.random.randint(0, N)\n            if a != b:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize diverse solutions, then applies a hybrid local search combining random node insertion with a probabilistic 3-opt move to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        if np.random.random() < 0.3:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.636478448126331,
            7.802590027740278
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n        if np.random.random() < 0.3:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.180321466936787,
            4.390328299385654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.180321466936787,
            4.390328299385654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal and segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            if k < l:\n                segment = new_solution[k:l]\n                new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.181127903687418,
            4.630929909155469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            if k < l:\n                segment = new_solution[k:l]\n                new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining segment relocation with a probabilistic path reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                               (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        if np.random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:start:-1], new_solution[end:]])\n        else:\n            insert_pos = np.random.randint(0, N - segment_length)\n            if insert_pos != start:\n                segment = new_solution[start:end]\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.4:\n            flip_start = np.random.randint(0, N)\n            flip_end = np.random.randint(flip_start, N)\n            new_solution[flip_start:flip_end] = new_solution[flip_start:flip_end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.429666256971807,
            10.636659474498781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                               (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        if np.random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:start:-1], new_solution[end:]])\n        else:\n            insert_pos = np.random.randint(0, N - segment_length)\n            if insert_pos != start:\n                segment = new_solution[start:end]\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.4:\n            flip_start = np.random.randint(0, N)\n            flip_end = np.random.randint(flip_start, N)\n            new_solution[flip_start:flip_end] = new_solution[flip_start:flip_end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel local search operator that combines a probabilistic segment rotation with a biased edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive)\n\n    if N == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_distances = np.zeros(N)\n        for i in range(2):\n            sorted_order = np.argsort(sorted_objectives[:, i])\n            sorted_objectives_sorted = sorted_objectives[sorted_order]\n            crowding_distances[sorted_order[1:-1]] += (\n                sorted_objectives_sorted[2:, i] - sorted_objectives_sorted[:-2, i]\n            )\n            crowding_distances[sorted_order[0]] = np.inf\n            crowding_distances[sorted_order[-1]] = np.inf\n\n        selected_idx = np.argmin(crowding_distances)\n        base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution[start:start+segment_length] = rotated_segment\n\n        if np.random.random() < 0.4:\n            insert_pos = np.random.randint(0, N)\n            if insert_pos >= start and insert_pos < start + segment_length:\n                pass\n            else:\n                node = new_solution[insert_pos]\n                new_solution = np.delete(new_solution, insert_pos)\n                insert_pos = np.random.randint(0, N - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.91963492882157,
            7.846981210942456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive)\n\n    if N == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_distances = np.zeros(N)\n        for i in range(2):\n            sorted_order = np.argsort(sorted_objectives[:, i])\n            sorted_objectives_sorted = sorted_objectives[sorted_order]\n            crowding_distances[sorted_order[1:-1]] += (\n                sorted_objectives_sorted[2:, i] - sorted_objectives_sorted[:-2, i]\n            )\n            crowding_distances[sorted_order[0]] = np.inf\n            crowding_distances[sorted_order[-1]] = np.inf\n\n        selected_idx = np.argmin(crowding_distances)\n        base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n\n        new_solution[start:start+segment_length] = rotated_segment\n\n        if np.random.random() < 0.4:\n            insert_pos = np.random.randint(0, N)\n            if insert_pos >= start and insert_pos < start + segment_length:\n                pass\n            else:\n                node = new_solution[insert_pos]\n                new_solution = np.delete(new_solution, insert_pos)\n                insert_pos = np.random.randint(0, N - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This new algorithm selects a solution from the archive based on a balanced normalized objective score that emphasizes improvement potential in both objectives while applying a hybrid local search combining edge swaps with a probabilistic path reversal and segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            a, b, c = sorted(np.random.choice(range(N), 3, replace=False))\n            segment = new_solution[b:c]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.475556154913579,
            6.545829561135073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            a, b, c = sorted(np.random.choice(range(N), 3, replace=False))\n            segment = new_solution[b:c]\n            new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that balances improvement potential in both objectives while applying a hybrid local search combining edge swaps with a probabilistic path inversion and a novel segment rotation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            segment_length = np.random.randint(2, min(5, N))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            np.random.shuffle(segment)\n            new_solution[start:start+segment_length] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.5446493624899444,
            5.8901397526518755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            segment_length = np.random.randint(2, min(5, N))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            np.random.shuffle(segment)\n            new_solution[start:start+segment_length] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines objective improvement potential with solution uniqueness, then applies a hybrid local search that combines edge relinking with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i-1], sol[i]), max(sol[i-1], sol[i])))\n        diversity_scores.append(len(unique_edges) / (len(sol) - 1))\n\n    weights = np.array([0.5, 0.3, 0.2])\n    combined_scores = np.column_stack((normalized_scores, diversity_scores))\n    weighted_scores = np.sum(combined_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            insert_pos = np.random.randint(0, N)\n            if insert_pos >= start and insert_pos <= end:\n                insert_pos = (insert_pos + 1) % N\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                np.delete(new_solution, np.arange(start, end))\n            ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.619566031531694,
            8.147357906581153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i-1], sol[i]), max(sol[i-1], sol[i])))\n        diversity_scores.append(len(unique_edges) / (len(sol) - 1))\n\n    weights = np.array([0.5, 0.3, 0.2])\n    combined_scores = np.column_stack((normalized_scores, diversity_scores))\n    weighted_scores = np.sum(combined_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            insert_pos = np.random.randint(0, N)\n            if insert_pos >= start and insert_pos <= end:\n                insert_pos = (insert_pos + 1) % N\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                np.delete(new_solution, np.arange(start, end))\n            ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the second objective while applying a hybrid local search combining edge swaps with a probabilistic path reversal and segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            a = np.random.randint(0, N)\n            b = np.random.randint(0, N)\n            c = np.random.randint(0, N)\n            if a != b and b != c:\n                segment = new_solution[b:c]\n                new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.902980458735341,
            5.175018710432266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            a = np.random.randint(0, N)\n            b = np.random.randint(0, N)\n            c = np.random.randint(0, N)\n            if a != b and b != c:\n                segment = new_solution[b:c]\n                new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less explored regions, then applies a hybrid local search combining a probabilistic k-opt move with a segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1, i] - sorted_objectives[j-1, i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, k, replace=False)\n        indices.sort()\n        segments = [new_solution[i:j] for i, j in zip([0]+list(indices), list(indices)+[N])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        if np.random.random() < 0.3:\n            pos1 = np.random.randint(0, N)\n            pos2 = np.random.randint(0, N)\n            segment = new_solution[pos1:pos2]\n            new_solution = np.concatenate([new_solution[:pos1], new_solution[pos2:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.381514943625167,
            8.567226846034098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        sorted_objectives = objectives[sorted_indices]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1, i] - sorted_objectives[j-1, i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = np.random.randint(2, min(5, N//2))\n        indices = np.random.choice(N, k, replace=False)\n        indices.sort()\n        segments = [new_solution[i:j] for i, j in zip([0]+list(indices), list(indices)+[N])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        if np.random.random() < 0.3:\n            pos1 = np.random.randint(0, N)\n            pos2 = np.random.randint(0, N)\n            segment = new_solution[pos1:pos2]\n            new_solution = np.concatenate([new_solution[:pos1], new_solution[pos2:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining random edge swaps with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.3:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, slice(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.01972524096579,
            8.32500458857852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.3:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, slice(start, end))\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining random edge swaps with a probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to identify non-dominated solutions, then applies a novel local search operator that combines segment relocations with probabilistic edge insertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n\n    # Calculate crowding distance to identify non-dominated solutions\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[i+1], m] != objectives[sorted_indices[i-1], m]:\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Segment relocation operator\n        start = np.random.randint(0, N-2)\n        end = np.random.randint(start+1, N)\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.7:\n            pos = np.random.randint(0, len(new_solution))\n            node = np.random.choice(new_solution)\n            new_solution = np.insert(new_solution, pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.680080524443243,
            10.013038540942441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n\n    # Calculate crowding distance to identify non-dominated solutions\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = float('inf')\n        crowding_distances[sorted_indices[-1]] = float('inf')\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[i+1], m] != objectives[sorted_indices[i-1], m]:\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Segment relocation operator\n        start = np.random.randint(0, N-2)\n        end = np.random.randint(start+1, N)\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.7:\n            pos = np.random.randint(0, len(new_solution))\n            node = np.random.choice(new_solution)\n            new_solution = np.insert(new_solution, pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment insertion with a probabilistic segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N)\n            l = np.random.randint(k, N)\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([segment, new_solution[:k], new_solution[l:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.460646059205931,
            10.638378974177403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        pos = np.random.randint(0, N)\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N)\n            l = np.random.randint(k, N)\n            segment = new_solution[k:l]\n            new_solution = np.concatenate([segment, new_solution[:k], new_solution[l:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of normalized objective values, prioritizing the first objective, and applies a hybrid local search combining segment swaps with a probabilistic segment reversal and a novel edge insertion operator to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            pos1 = np.random.randint(0, N)\n            pos2 = np.random.randint(0, N)\n            node = new_solution[pos1]\n            new_solution = np.delete(new_solution, pos1)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.854587709816915,
            7.798593800992913
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.4:\n            pos1 = np.random.randint(0, N)\n            pos2 = np.random.randint(0, N)\n            node = new_solution[pos1]\n            new_solution = np.delete(new_solution, pos1)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a probabilistic 3-opt move with a segment-based inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_objectives = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (np.max(objectives[:, i]) - np.min(objectives[:, i]) + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.5:\n            i, j, k = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.586061814159734,
            9.483070888762995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_objectives = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[1:-1]] += (sorted_objectives[2:] - sorted_objectives[:-2]) / (np.max(objectives[:, i]) - np.min(objectives[:, i]) + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.5:\n            i, j, k = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based selection strategy, then applies a novel hybrid local search operator that combines a probabilistic k-swap with a geometric perturbation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                          (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        k = np.random.randint(2, min(5, N//2))\n        swap_indices = np.random.choice(N, size=k*2, replace=False)\n        for i in range(0, len(swap_indices), 2):\n            new_solution[swap_indices[i]], new_solution[swap_indices[i+1]] = new_solution[swap_indices[i+1]], new_solution[swap_indices[i]]\n\n        if np.random.random() < 0.5:\n            center = np.random.randint(0, N)\n            radius = np.random.randint(2, min(5, N//2))\n            left = max(0, center - radius)\n            right = min(N, center + radius)\n            new_solution[left:right] = np.roll(new_solution[left:right], np.random.randint(1, radius))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.527060418516553,
            7.644275486839803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                          (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        k = np.random.randint(2, min(5, N//2))\n        swap_indices = np.random.choice(N, size=k*2, replace=False)\n        for i in range(0, len(swap_indices), 2):\n            new_solution[swap_indices[i]], new_solution[swap_indices[i+1]] = new_solution[swap_indices[i+1]], new_solution[swap_indices[i]]\n\n        if np.random.random() < 0.5:\n            center = np.random.randint(0, N)\n            radius = np.random.randint(2, min(5, N//2))\n            left = max(0, center - radius)\n            right = min(N, center + radius)\n            new_solution[left:right] = np.roll(new_solution[left:right], np.random.randint(1, radius))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.638230681355866,
            9.451124023775709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.638230681355866,
            9.451124023775709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based approach that prioritizes solutions with better trade-offs between objectives, then applies a novel local search operator that combines segment relocations with probabilistic node swaps to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:],\n            segment\n        ])\n\n        if np.random.random() < 0.5:\n            swap_pos1 = np.random.randint(0, N - segment_length)\n            swap_pos2 = np.random.randint(swap_pos1 + 1, N)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.744390690103071,
            7.148945687298491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for other_obj in objectives:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:],\n            segment\n        ])\n\n        if np.random.random() < 0.5:\n            swap_pos1 = np.random.randint(0, N - segment_length)\n            swap_pos2 = np.random.randint(swap_pos1 + 1, N)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on a balanced objective score that emphasizes both objectives equally, then applies a novel local search operator that combines segment relocations with probabilistic segment reversals to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(1, min(5, N // 2) + 1)\n        start = np.random.randint(0, N - segment_length + 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        insertion_pos = np.random.randint(0, N - segment_length + 1)\n        if insertion_pos >= start:\n            insertion_pos += segment_length\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:insertion_pos],\n            segment,\n            new_solution[insertion_pos:]\n        ])\n\n        if np.random.random() < 0.5:\n            start_rev = np.random.randint(0, N - segment_length + 1)\n            end_rev = start_rev + segment_length\n            new_solution[start_rev:end_rev] = new_solution[start_rev:end_rev][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.165656922336,
            6.341065104114272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        segment_length = np.random.randint(1, min(5, N // 2) + 1)\n        start = np.random.randint(0, N - segment_length + 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        insertion_pos = np.random.randint(0, N - segment_length + 1)\n        if insertion_pos >= start:\n            insertion_pos += segment_length\n\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:insertion_pos],\n            segment,\n            new_solution[insertion_pos:]\n        ])\n\n        if np.random.random() < 0.5:\n            start_rev = np.random.randint(0, N - segment_length + 1)\n            end_rev = start_rev + segment_length\n            new_solution[start_rev:end_rev] = new_solution[start_rev:end_rev][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that emphasizes balanced improvement across both objectives, then applies a novel local search operator that combines a probabilistic segment rotation with a distance-aware edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Probabilistic segment rotation\n        if np.random.random() < 0.5:\n            k = np.random.randint(1, N//2)\n            rotation_point = np.random.randint(0, N)\n            segment = new_solution[rotation_point:rotation_point+k]\n            new_solution = np.concatenate([new_solution[:rotation_point], segment, new_solution[rotation_point+k:]])\n\n        # Distance-aware edge insertion\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insertion_pos = np.argmin(distance_matrix_1[node, new_solution] + distance_matrix_2[node, new_solution])\n                new_solution = np.insert(new_solution, insertion_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.4482393511660625,
            6.664790314116803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Probabilistic segment rotation\n        if np.random.random() < 0.5:\n            k = np.random.randint(1, N//2)\n            rotation_point = np.random.randint(0, N)\n            segment = new_solution[rotation_point:rotation_point+k]\n            new_solution = np.concatenate([new_solution[:rotation_point], segment, new_solution[rotation_point+k:]])\n\n        # Distance-aware edge insertion\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                insertion_pos = np.argmin(distance_matrix_1[node, new_solution] + distance_matrix_2[node, new_solution])\n                new_solution = np.insert(new_solution, insertion_pos, node)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.3:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.102376783340523,
            4.816106332254131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.3:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted Pareto dominance score that prioritizes solutions with better trade-offs between objectives, then applies a novel local search combining segment relocations with probabilistic edge crossings to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            segment_length = min(3, N - max(i, j))\n            if segment_length > 1:\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.5:\n            a = np.random.randint(0, N)\n            b = np.random.randint(0, N)\n            c = np.random.randint(0, N)\n            if a != b and b != c and a != c:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.400558653349755,
            7.5157800726777815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            segment_length = min(3, N - max(i, j))\n            if segment_length > 1:\n                segment = new_solution[i:i+segment_length]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.5:\n            a = np.random.randint(0, N)\n            b = np.random.randint(0, N)\n            c = np.random.randint(0, N)\n            if a != b and b != c and a != c:\n                new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that emphasizes improvement potential in the first objective while applying a hybrid local search combining edge swaps with a probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based ranking that emphasizes non-dominated solutions, then applies a novel local search operator that combines partial path reversal with probabilistic edge insertions to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = objectives.shape[0]\n\n    # Calculate dominance counts\n    dominance_counts = np.zeros(N)\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[j] += 1\n\n    # Select solution with lowest dominance count (most non-dominated)\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Partial path reversal with probabilistic edge insertion\n        a = np.random.randint(0, N)\n        b = np.random.randint(0, N)\n        c = np.random.randint(0, N)\n        if a != b and a != c and b != c:\n            # Reverse segment between min(a,b) and max(a,b)\n            start, end = sorted([a, b])\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n            # Insert node c at a random position\n            if np.random.random() < 0.5:\n                pos = np.random.randint(0, N)\n                new_solution = np.insert(new_solution, pos, new_solution[c])\n                new_solution = np.delete(new_solution, c + (1 if pos <= c else 0))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.837966871735056,
            6.899515589240414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = objectives.shape[0]\n\n    # Calculate dominance counts\n    dominance_counts = np.zeros(N)\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[j] += 1\n\n    # Select solution with lowest dominance count (most non-dominated)\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Partial path reversal with probabilistic edge insertion\n        a = np.random.randint(0, N)\n        b = np.random.randint(0, N)\n        c = np.random.randint(0, N)\n        if a != b and a != c and b != c:\n            # Reverse segment between min(a,b) and max(a,b)\n            start, end = sorted([a, b])\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n            # Insert node c at a random position\n            if np.random.random() < 0.5:\n                pos = np.random.randint(0, N)\n                new_solution = np.insert(new_solution, pos, new_solution[c])\n                new_solution = np.delete(new_solution, c + (1 if pos <= c else 0))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive using a dominance-based selection to prioritize solutions with better objective values, then applies a hybrid local search combining a probabilistic edge exchange with a segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.91169402384928,
            6.623045832327962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(non_dominated)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.452386658899551,
            9.051222215857612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.452386658899551,
            9.051222215857612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive weighted score that prioritizes improvement in the second objective while applying a hybrid local search combining 3-opt with a probabilistic segment rotation to generate neighbors, ensuring feasibility and enhanced exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        a = np.random.randint(0, N-2)\n        b = np.random.randint(a+1, N-1)\n        c = np.random.randint(b+1, N)\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(2, N//2)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.228188357164939,
            4.978017531979223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        a = np.random.randint(0, N-2)\n        b = np.random.randint(a+1, N-1)\n        c = np.random.randint(b+1, N)\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(2, N//2)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to identify non-dominated solutions, then applies a hybrid local search combining edge insertion with a probabilistic edge reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        while j == i or j == (i+1)%N:\n            j = np.random.randint(0, N)\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            while l == k or l == (k+1)%N:\n                l = np.random.randint(0, N)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.281674228508393,
            8.955761036551042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        while j == i or j == (i+1)%N:\n            j = np.random.randint(0, N)\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            while l == k or l == (k+1)%N:\n                l = np.random.randint(0, N)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-3)\n        j = np.random.randint(i+2, N-1)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N-2)\n            end = np.random.randint(start+1, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.614449560053894,
            8.519813278704765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-3)\n        j = np.random.randint(i+2, N-1)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N-2)\n            end = np.random.randint(start+1, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm selects a solution from the archive using an adaptive objective score that balances improvement in both objectives with a dynamic weight adjustment, then applies a hybrid local search combining edge exchanges with a controlled segment reversal to generate neighbors, ensuring feasibility and exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.837030216041976,
            7.7133469134751405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2, segment1])\n        else:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This new algorithm selects a solution from the archive using a diversity-aware selection based on both objective scores and tour structure similarity, then applies a hybrid local search combining segment relocations with probabilistic segment reversals, ensuring feasibility while promoting exploration of diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate structural diversity\n    solutions = [sol for (sol, _) in archive]\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        diversity = 0\n        for other_sol in solutions:\n            diversity += np.sum(sol != other_sol)\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    # Combined selection score\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Segment relocation with probabilistic swap\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        k = np.random.randint(0, N)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        # Probabilistic segment reversal with distance-based probability\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            if segment_cost1 > 0 or segment_cost2 > 0:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.756615461526864,
            7.944616021393985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware selection\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Calculate structural diversity\n    solutions = [sol for (sol, _) in archive]\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        diversity = 0\n        for other_sol in solutions:\n            diversity += np.sum(sol != other_sol)\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    # Combined selection score\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Segment relocation with probabilistic swap\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        k = np.random.randint(0, N)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        # Probabilistic segment reversal with distance-based probability\n        if np.random.random() < 0.6:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n            if segment_cost1 > 0 or segment_cost2 > 0:\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This algorithm selects a solution from the archive based on the combined dominance count and proximity to the ideal point, then applies a novel hybrid local search combining multi-segment swaps with a probabilistic node insertion and reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ideal_point = np.min(objectives, axis=0)\n\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]):\n                    dominance_counts[i] += 1\n\n    scores = np.linalg.norm(objectives - ideal_point, axis=1) / (dominance_counts + 1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        num_segments = np.random.randint(1, min(4, N//2))\n        segments = []\n        for _ in range(num_segments):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segments.append((i, j))\n\n        segments.sort()\n        merged = []\n        for seg in segments:\n            if not merged or seg[0] > merged[-1][1]:\n                merged.append(seg)\n            else:\n                merged[-1] = (merged[-1][0], max(merged[-1][1], seg[1]))\n\n        for i, j in reversed(merged):\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            for _ in range(np.random.randint(1, 3)):\n                if N > 3:\n                    pos = np.random.randint(1, N-1)\n                    node = new_solution[pos]\n                    new_solution = np.delete(new_solution, pos)\n                    new_pos = np.random.randint(1, N-1)\n                    new_solution = np.insert(new_solution, new_pos, node)\n\n        if np.random.random() < 0.5:\n            for _ in range(np.random.randint(1, 3)):\n                if N > 3:\n                    start = np.random.randint(0, N-1)\n                    end = np.random.randint(start+1, N)\n                    new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.064084141809695,
            7.03452853165119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ideal_point = np.min(objectives, axis=0)\n\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if all(objectives[i] <= objectives[j]):\n                    dominance_counts[i] += 1\n\n    scores = np.linalg.norm(objectives - ideal_point, axis=1) / (dominance_counts + 1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        num_segments = np.random.randint(1, min(4, N//2))\n        segments = []\n        for _ in range(num_segments):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segments.append((i, j))\n\n        segments.sort()\n        merged = []\n        for seg in segments:\n            if not merged or seg[0] > merged[-1][1]:\n                merged.append(seg)\n            else:\n                merged[-1] = (merged[-1][0], max(merged[-1][1], seg[1]))\n\n        for i, j in reversed(merged):\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            for _ in range(np.random.randint(1, 3)):\n                if N > 3:\n                    pos = np.random.randint(1, N-1)\n                    node = new_solution[pos]\n                    new_solution = np.delete(new_solution, pos)\n                    new_pos = np.random.randint(1, N-1)\n                    new_solution = np.insert(new_solution, new_pos, node)\n\n        if np.random.random() < 0.5:\n            for _ in range(np.random.randint(1, 3)):\n                if N > 3:\n                    start = np.random.randint(0, N-1)\n                    end = np.random.randint(start+1, N)\n                    new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive using a normalized objective score that emphasizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility and potentially better exploration.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid selection criterion combining normalized objective scores and solution diversity, then applies a novel multi-segment crossover operator with probabilistic segment reversal to generate a neighbor solution, ensuring feasibility while exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)):\n            diversity += abs(sol[i] - archive[0][0][i])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.1 * (diversity_scores / np.max(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        num_segments = np.random.randint(2, min(5, N//2))\n        segment_indices = sorted(np.random.choice(range(1, N), num_segments, replace=False))\n\n        segments = []\n        start = 0\n        for idx in segment_indices:\n            segments.append(new_solution[start:idx])\n            start = idx\n        segments.append(new_solution[start:])\n\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        for _ in range(min(3, N//3)):\n            if np.random.random() < 0.4:\n                i = np.random.randint(0, N-1)\n                j = np.random.randint(i+1, N)\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.06088470028377,
            7.848866985489117
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)):\n            diversity += abs(sol[i] - archive[0][0][i])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.1 * (diversity_scores / np.max(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        num_segments = np.random.randint(2, min(5, N//2))\n        segment_indices = sorted(np.random.choice(range(1, N), num_segments, replace=False))\n\n        segments = []\n        start = 0\n        for idx in segment_indices:\n            segments.append(new_solution[start:idx])\n            start = idx\n        segments.append(new_solution[start:])\n\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        for _ in range(min(3, N//3)):\n            if np.random.random() < 0.4:\n                i = np.random.randint(0, N-1)\n                j = np.random.randint(i+1, N)\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined ranking of both objectives, then applies a hybrid local search combining a probabilistic segment swap with a dynamic segment reversal and insertion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.6:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            segment = new_solution[i:j]\n            k = np.random.randint(0, N - len(segment))\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n        else:\n            start, end = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.00617940404819,
            10.10434972183793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = ranks[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.6:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            segment = new_solution[i:j]\n            k = np.random.randint(0, N - len(segment))\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n        else:\n            start, end = sorted(np.random.choice(N, 2, replace=False))\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive based on the combined improvement potential in both objectives, then applies a novel \"k-segment swap and inversion\" operator that randomly selects k non-overlapping segments, swaps them, and probabilistically inverts each segment to create a diverse and potentially high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        k = np.random.randint(1, min(4, N//2))\n        segments = []\n        indices = sorted(np.random.choice(range(1, N), size=2*k, replace=False))\n        for i in range(0, 2*k, 2):\n            segments.append((indices[i], indices[i+1]))\n\n        for i, j in segments:\n            segment = new_solution[i:j]\n            if np.random.random() < 0.6:\n                segment = segment[::-1]\n            new_solution[i:j] = segment\n\n        if len(np.unique(new_solution)) != N:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.276469833191894,
            6.304559325748959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        k = np.random.randint(1, min(4, N//2))\n        segments = []\n        indices = sorted(np.random.choice(range(1, N), size=2*k, replace=False))\n        for i in range(0, 2*k, 2):\n            segments.append((indices[i], indices[i+1]))\n\n        for i, j in segments:\n            segment = new_solution[i:j]\n            if np.random.random() < 0.6:\n                segment = segment[::-1]\n            new_solution[i:j] = segment\n\n        if len(np.unique(new_solution)) != N:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that prioritizes solutions with lower total distance in both objectives, then applies a novel hybrid local search combining segment inversion with a probabilistic node swap to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    combined_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, size=2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.703335415006449,
            6.094694860927372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    combined_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, size=2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to prioritize solutions in less-crowded regions, then applies a hybrid local search combining edge swaps with a probabilistic 2.5-opt move to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_order = sorted_indices[:, i]\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (objectives[sorted_order[j+1], i] - objectives[sorted_order[j-1], i]) / (objectives[sorted_order[-1], i] - objectives[sorted_order[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+1, N-1)\n        k = np.random.randint(j+1, N)\n\n        if np.random.random() < 0.5:\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if np.random.random() < 0.3:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.34806020631395,
            8.318579061321419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives, axis=0)\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_order = sorted_indices[:, i]\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (objectives[sorted_order[j+1], i] - objectives[sorted_order[j-1], i]) / (objectives[sorted_order[-1], i] - objectives[sorted_order[0], i] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+1, N-1)\n        k = np.random.randint(j+1, N)\n\n        if np.random.random() < 0.5:\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n        else:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            if np.random.random() < 0.3:\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and dominance relationships, then applies a hybrid local search combining a probabilistic 4-opt move with a segment rotation to generate neighbors while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] <= objectives[j]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.8:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(1, N-1)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.420448940151051,
            7.88933312547499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominance_counts = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and all(objectives[i] <= objectives[j]):\n                dominance_counts[i] += 1\n\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.8:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(1, N-1)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric that measures the solution's dominance in the objective space, then applies a hybrid local search combining edge exchanges with a probabilistic edge insertion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = np.argmin(np.sum((objectives - objectives[i])**2, axis=1))\n        right = np.argmax(np.sum((objectives - objectives[i])**2, axis=1))\n        crowding_distances[i] = np.linalg.norm(objectives[right] - objectives[left])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+2, N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            if k != l:\n                new_solution = np.insert(new_solution, k, new_solution[l])\n                new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.953995737717837,
            7.999285606493937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = np.argmin(np.sum((objectives - objectives[i])**2, axis=1))\n        right = np.argmax(np.sum((objectives - objectives[i])**2, axis=1))\n        crowding_distances[i] = np.linalg.norm(objectives[right] - objectives[left])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+2, N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            if k != l:\n                new_solution = np.insert(new_solution, k, new_solution[l])\n                new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal and a probabilistic swap of adjacent nodes to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.647978477536958,
            8.890236679560827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.270411145966689,
            9.573291101367683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.270411145966689,
            9.573291101367683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a novel 'double-bridge' local search operator that simultaneously exchanges two non-adjacent edge pairs while preserving feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distance = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distance[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    # Select solution with highest crowding distance (least crowded)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Double-bridge operator\n        a = np.random.randint(0, N-3)\n        b = np.random.randint(a+1, N-2)\n        c = np.random.randint(b+1, N-1)\n        d = np.random.randint(c+1, N)\n\n        # Create new solution by reconnecting the bridges\n        new_solution = np.concatenate([\n            base_solution[:a+1],\n            base_solution[b+1:c+1],\n            base_solution[a+1:b+1],\n            base_solution[d:],\n            base_solution[c+1:d]\n        ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.419394751903882,
            8.33196563955718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding_distance = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distance[sorted_indices[0]] = np.inf\n        crowding_distance[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distance[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    # Select solution with highest crowding distance (least crowded)\n    selected_idx = np.argmax(crowding_distance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Double-bridge operator\n        a = np.random.randint(0, N-3)\n        b = np.random.randint(a+1, N-2)\n        c = np.random.randint(b+1, N-1)\n        d = np.random.randint(c+1, N)\n\n        # Create new solution by reconnecting the bridges\n        new_solution = np.concatenate([\n            base_solution[:a+1],\n            base_solution[b+1:c+1],\n            base_solution[a+1:b+1],\n            base_solution[d:],\n            base_solution[c+1:d]\n        ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining both objectives, then applies a novel segment-based local search that iteratively merges and splits segments using a probabilistic approach to balance exploration and exploitation while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        for _ in range(3):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n\n            if np.random.random() < 0.6:\n                segment = np.concatenate([segment[1:], [segment[0]]])\n            else:\n                segment = np.concatenate([[segment[-1]], segment[:-1]])\n\n            new_solution[i:j] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.629677452754509,
            6.455624736674618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        for _ in range(3):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n\n            if np.random.random() < 0.6:\n                segment = np.concatenate([segment[1:], [segment[0]]])\n            else:\n                segment = np.concatenate([[segment[-1]], segment[:-1]])\n\n            new_solution[i:j] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement in both objectives while applying a hybrid local search combining a probabilistic segment rotation with a node swap to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.std(normalized_scores, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            k = np.random.randint(1, N)\n            rotated_segment = np.roll(new_solution[:k], 1)\n            new_solution[:k] = rotated_segment\n\n        if np.random.random() < 0.4:\n            u, v = np.random.choice(N, 2, replace=False)\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.099030053051281,
            6.027249018232877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.std(normalized_scores, axis=0)\n    weights = diversity_scores / np.sum(diversity_scores)\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            k = np.random.randint(1, N)\n            rotated_segment = np.roll(new_solution[:k], 1)\n            new_solution[:k] = rotated_segment\n\n        if np.random.random() < 0.4:\n            u, v = np.random.choice(N, 2, replace=False)\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining a probabilistic 4-opt move with a segment rotation to generate neighbors while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weighted_scores = np.sum(objectives * diversity_scores, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.6:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.490537693437666,
            10.608138554247933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    weighted_scores = np.sum(objectives * diversity_scores, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.6:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.471089720691122,
            8.777306772219088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection mechanism that considers both objective values and solution structure, then applies a hybrid local search combining a probabilistic segment crossover with a node insertion heuristic to generate neighbors while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        diversity = 0\n        for j, other_sol in enumerate(solutions):\n            if i != j:\n                diversity += np.sum(sol != other_sol)\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    if np.max(diversity_scores) > 0:\n        diversity_scores = diversity_scores / np.max(diversity_scores)\n\n    combined_scores = normalized_scores[:, 0] * 0.5 + normalized_scores[:, 1] * 0.5 + diversity_scores * 0.2\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.8:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            segment = base_solution[a:b]\n            new_solution = np.delete(new_solution, np.arange(a, b))\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.6:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            if np.random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.598757553076642,
            6.478796700128096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for i, sol in enumerate(solutions):\n        diversity = 0\n        for j, other_sol in enumerate(solutions):\n            if i != j:\n                diversity += np.sum(sol != other_sol)\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    if np.max(diversity_scores) > 0:\n        diversity_scores = diversity_scores / np.max(diversity_scores)\n\n    combined_scores = normalized_scores[:, 0] * 0.5 + normalized_scores[:, 1] * 0.5 + diversity_scores * 0.2\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.8:\n            a, b = sorted(np.random.choice(N, 2, replace=False))\n            segment = base_solution[a:b]\n            new_solution = np.delete(new_solution, np.arange(a, b))\n            insert_pos = np.random.randint(0, len(new_solution) + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.6:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            if np.random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection strategy that combines objective scores with solution uniqueness, then applies a hybrid local search combining a probabilistic 4-opt move with a segment rotation to generate neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        unique_pairs = set()\n        for j in range(len(sol)-1):\n            pair = tuple(sorted((sol[j], sol[j+1])))\n            unique_pairs.add(pair)\n        diversity_scores.append(1.0 / len(unique_pairs))\n\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.8:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.820564697680676,
            8.994189420788196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = []\n    for i, (sol, _) in enumerate(archive):\n        unique_pairs = set()\n        for j in range(len(sol)-1):\n            pair = tuple(sorted((sol[j], sol[j+1])))\n            unique_pairs.add(pair)\n        diversity_scores.append(1.0 / len(unique_pairs))\n\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - np.min(diversity_scores)) / (np.max(diversity_scores) - np.min(diversity_scores) + 1e-8)\n\n    combined_scores = 0.6 * normalized_scores[:, 0] + 0.3 * normalized_scores[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.8:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment2, segment3, segment1])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dynamically adjusted objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment swaps with a probabilistic segment inversion to generate neighbors, ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.6544004506828145,
            8.56307408958363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This new algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel hybrid local search combining a probabilistic segment relocation with a distance-aware 4-opt move to generate neighbors, ensuring feasibility through comprehensive validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    improvement_potential = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.6:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment3, segment2, segment1])\n\n        if np.random.random() < 0.4:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.814758745908817,
            6.372413135287381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    improvement_potential = np.sum(objectives, axis=1)\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 6:\n        if np.random.random() < 0.6:\n            a, b, c, d = sorted(np.random.choice(N, 4, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            segment3 = new_solution[c:d]\n            new_solution[a:d] = np.concatenate([segment3, segment2, segment1])\n\n        if np.random.random() < 0.4:\n            i, j = sorted(np.random.choice(N, 2, replace=False))\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic 3-opt move with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.7:\n            a, b, c = sorted(np.random.choice(N, 3, replace=False))\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized objective scores, then applies a hybrid local search combining a probabilistic segment rotation with a segment inversion to generate neighbors, while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.6:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.050412975257763,
            6.02495392426871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.6:\n            k = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, k)\n\n        if np.random.random() < 0.4:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in both objectives while applying a hybrid local search combining segment rotations with a probabilistic segment inversion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = np.random.randint(1, N)\n        rotated_segment = np.roll(new_solution, k)\n        new_solution[:] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.297113659131586,
            5.8230003515588695
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        k = np.random.randint(1, N)\n        rotated_segment = np.roll(new_solution, k)\n        new_solution[:] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less explored regions, then applies a hybrid local search combining edge insertion with a dynamic segment reversal based on the relative improvement potential in both objectives to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if max_vals[i] != min_vals[i]:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (max_vals[i] - min_vals[i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        improvement_potential = 0\n        for k in range(N-1):\n            delta1 = distance_matrix_1[new_solution[k], new_solution[k+1]] - distance_matrix_1[base_solution[k], base_solution[k+1]]\n            delta2 = distance_matrix_2[new_solution[k], new_solution[k+1]] - distance_matrix_2[base_solution[k], base_solution[k+1]]\n            improvement_potential += (delta1 + delta2)\n\n        if improvement_potential > 0 and np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.085408644197615,
            7.65167684845048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if max_vals[i] != min_vals[i]:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (max_vals[i] - min_vals[i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        improvement_potential = 0\n        for k in range(N-1):\n            delta1 = distance_matrix_1[new_solution[k], new_solution[k+1]] - distance_matrix_1[base_solution[k], base_solution[k+1]]\n            delta2 = distance_matrix_2[new_solution[k], new_solution[k+1]] - distance_matrix_2[base_solution[k], base_solution[k+1]]\n            improvement_potential += (delta1 + delta2)\n\n        if improvement_potential > 0 and np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.291134209612053,
            4.382364114471146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.291134209612053,
            4.382364114471146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment inversion with a probabilistic segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N)\n            segment = new_solution[k:]\n            np.roll(segment, shift=1, axis=0)\n            new_solution[k:] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.394261305889637,
            8.118480631706714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N)\n            segment = new_solution[k:]\n            np.roll(segment, shift=1, axis=0)\n            new_solution[k:] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining edge swaps with a probabilistic edge reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.8266618778955745,
            8.954285635537724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion combining both objectives and uses a novel multi-segment crossover and probabilistic inversion operator to generate neighbors, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        num_segments = np.random.randint(2, min(5, N//2))\n        segment_indices = sorted(np.random.choice(range(1, N), num_segments, replace=False))\n        segments = []\n        prev = 0\n        for idx in segment_indices:\n            segments.append(new_solution[prev:idx])\n            prev = idx\n        segments.append(new_solution[prev:])\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        if np.random.random() < 0.5:\n            for _ in range(np.random.randint(1, 3)):\n                start = np.random.randint(0, N)\n                end = np.random.randint(start, N)\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.156094053568746,
            6.366382429665495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        num_segments = np.random.randint(2, min(5, N//2))\n        segment_indices = sorted(np.random.choice(range(1, N), num_segments, replace=False))\n        segments = []\n        prev = 0\n        for idx in segment_indices:\n            segments.append(new_solution[prev:idx])\n            prev = idx\n        segments.append(new_solution[prev:])\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        if np.random.random() < 0.5:\n            for _ in range(np.random.randint(1, 3)):\n                start = np.random.randint(0, N)\n                end = np.random.randint(start, N)\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that balances both objectives while applying a novel hybrid local search that combines probabilistic segment relocation with a dynamic segment inversion strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            segment = new_solution[k:k+3]\n            new_solution[k:k+3] = segment[::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.560977419215656,
            6.113848878576039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            segment = new_solution[k:k+3]\n            new_solution[k:k+3] = segment[::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score that prioritizes solutions with balanced improvement in both objectives, then applies a hybrid local search combining a probabilistic 2-opt with a segment inversion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    combined_scores = np.prod(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.6:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.736322780867942,
            5.793868097806108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    combined_scores = np.prod(normalized_scores, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.6:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining segment relocations with a probabilistic segment inversion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        segment_length = np.random.randint(2, min(5, N//2))\n        segment = new_solution[i:i+segment_length]\n        new_solution = np.delete(new_solution, slice(i, i+segment_length))\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.610316562853442,
            8.873644788886612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        segment_length = np.random.randint(2, min(5, N//2))\n        segment = new_solution[i:i+segment_length]\n        new_solution = np.delete(new_solution, slice(i, i+segment_length))\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if np.random.random() < 0.5:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search combining a probabilistic edge swap and a segment rotation to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            new_solution[i:j+1] = np.roll(new_solution[i:j+1], 1)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.623156017119133,
            8.836757543294674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            new_solution[i:j+1] = np.roll(new_solution[i:j+1], 1)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel local search operator that combines a probabilistic k-opt move with a segment-based perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(len(archive)) if i != j])\n    diversity_scores = diversity_scores.reshape(len(archive), -1).mean(axis=1)\n\n    combined_scores = 0.6 * normalized_scores[:, 1] + 0.4 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        k = np.random.randint(2, min(5, N-1))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n        if np.random.random() < 0.6:\n            a = np.random.randint(0, N-1)\n            b = np.random.randint(a+1, N)\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.501522156813614,
            6.590140202006152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(len(archive)) if i != j])\n    diversity_scores = diversity_scores.reshape(len(archive), -1).mean(axis=1)\n\n    combined_scores = 0.6 * normalized_scores[:, 1] + 0.4 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        k = np.random.randint(2, min(5, N-1))\n        indices = np.random.choice(N, size=k, replace=False)\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n        if np.random.random() < 0.6:\n            a = np.random.randint(0, N-1)\n            b = np.random.randint(a+1, N)\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm selects a solution from the archive based on a score function that prioritizes solutions with better performance in the first objective, then applies a hybrid local search combining a probabilistic node swap and a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.5474310895789705,
            8.798063890311145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.641110317370018,
            4.309974453390293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.641110317370018,
            4.309974453390293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel 3-segment exchange local search that intelligently swaps three non-overlapping segments from different parts of the tour to generate diverse neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_values = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if sorted_values[-1] == sorted_values[0]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (sorted_values[j+1] - sorted_values[j-1]) / (sorted_values[-1] - sorted_values[0])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 9:\n        points = np.random.choice(N, 6, replace=False)\n        points.sort()\n        a, b, c, d, e, f = points\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        segment3 = new_solution[e:f]\n\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, segment3, segment1,\n            new_solution[b:c], new_solution[d:e], new_solution[f:]\n        ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.991321029539428,
            9.945555036250589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_values = objectives[sorted_indices, i]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if sorted_values[-1] == sorted_values[0]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (sorted_values[j+1] - sorted_values[j-1]) / (sorted_values[-1] - sorted_values[0])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 9:\n        points = np.random.choice(N, 6, replace=False)\n        points.sort()\n        a, b, c, d, e, f = points\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        segment3 = new_solution[e:f]\n\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, segment3, segment1,\n            new_solution[b:c], new_solution[d:e], new_solution[f:]\n        ])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with balanced improvement across both objectives, then applies a hybrid local search combining a probabilistic segment insertion and a segment reversal with position swapping to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            pos = np.random.randint(0, N)\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.481096357010227,
            6.577225361629152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            pos = np.random.randint(0, N)\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        if np.random.random() < 0.6:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to identify non-dominated solutions, then applies a hybrid local search combining a probabilistic edge insertion and a segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (sorted_objectives[sorted_idx[i+1], m] - sorted_objectives[sorted_idx[i-1], m]) / (sorted_objectives[sorted_idx[-1], m] - sorted_objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.384124934980937,
            10.711985187781748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_idx = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[i]] += (sorted_objectives[sorted_idx[i+1], m] - sorted_objectives[sorted_idx[i-1], m]) / (sorted_objectives[sorted_idx[-1], m] - sorted_objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.886346211858648,
            4.3477765200858896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment shuffle and a probabilistic node swap to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding[sorted_order[0]] = np.inf\n        crowding[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_order)-1):\n            crowding[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.783313678828448,
            11.025070477701902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding[sorted_order[0]] = np.inf\n        crowding[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_order)-1):\n            crowding[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            np.random.shuffle(segment)\n            new_solution[i:j] = segment\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N)\n            l = np.random.randint(0, N)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel segment insertion and shift operator to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                    (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.5:\n            shift = np.random.randint(1, N-1)\n            new_solution = np.roll(new_solution, shift)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.843972691628746,
            9.473688368534015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0] + 1e-8) + \\\n                                    (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.5:\n            shift = np.random.randint(1, N-1)\n            new_solution = np.roll(new_solution, shift)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search combining a probabilistic segment reversal and a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            segment_length = np.random.randint(1, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.268335446221891,
            9.222000127879799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            segment_length = np.random.randint(1, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a hybrid local search combining a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search combining a probabilistic segment reversal and a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            segment_length = np.random.randint(1, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.268335446221891,
            9.222000127879799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            segment_length = np.random.randint(1, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment relocation and a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment, new_solution[j+1:k]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.20506345578263,
            4.478596124522905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment, new_solution[j+1:k]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with high average distance from the archive centroid, then applies a novel local search combining a probabilistic segment reversal with a dynamic segment swap to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            l = np.random.randint(k+2, N-1)\n            segment1 = new_solution[k:k+2]\n            segment2 = new_solution[l:l+2]\n            new_solution = np.concatenate([new_solution[:k], segment2, new_solution[k+2:l], segment1, new_solution[l+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.195803234603757,
            8.006357183616476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            l = np.random.randint(k+2, N-1)\n            segment1 = new_solution[k:k+2]\n            segment2 = new_solution[l:l+2]\n            new_solution = np.concatenate([new_solution[:k], segment2, new_solution[k+2:l], segment1, new_solution[l+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.206923218193344,
            10.795075673160595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.206923218193344,
            10.795075673160595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining a segment reversal and a segment shift to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            segment = new_solution[k:k+3]\n            new_solution = np.concatenate([new_solution[:k], segment[1:], segment[:1], new_solution[k+3:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.40334639275967,
            4.399930709649505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            segment = new_solution[k:k+3]\n            new_solution = np.concatenate([new_solution[:k], segment[1:], segment[:1], new_solution[k+3:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search combining a probabilistic segment relocation and a segment reversal with a dynamic probability adjustment based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        segment_length = min(3, max(2, int(np.random.normal(N/4, N/8))))\n        segment_length = max(2, min(segment_length, N-1))\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-segment_length)\n            j = i + segment_length\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.4 + 0.3*(1 - normalized_scores[selected_idx][0]):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.690788276751735,
            8.59287553268892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        segment_length = min(3, max(2, int(np.random.normal(N/4, N/8))))\n        segment_length = max(2, min(segment_length, N-1))\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-segment_length)\n            j = i + segment_length\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.4 + 0.3*(1 - normalized_scores[selected_idx][0]):\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the second objective while applying a hybrid local search combining segment swaps with a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.2, 0.8])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        i = np.random.randint(0, N-1)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n        if np.random.random() < 0.7:\n            start = np.random.randint(0, N)\n            end = np.random.randint(start, N)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score that prioritizes both objectives equally while applying a novel hybrid local search combining a probabilistic segment reversal and a segment insertion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(0, N-1)\n            if k != l:\n                segment = new_solution[k]\n                new_solution = np.concatenate([new_solution[:l], [segment], new_solution[l:k], new_solution[k+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.89548249228581,
            6.254191864785152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(0, N-1)\n            if k != l:\n                segment = new_solution[k]\n                new_solution = np.concatenate([new_solution[:l], [segment], new_solution[l:k], new_solution[k+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that equally weights both objectives, then applies a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.106995974308614,
            6.111722737763057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify under-explored regions, then applies a novel adaptive segment relocation and inversion operator that dynamically adjusts the segment size based on the solution's current quality, ensuring feasibility while promoting diverse exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = np.array([sol for (sol, _) in archive])\n\n    if len(archive) > 1:\n        crowding_distances = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        segment_size = max(2, min(5, int(np.random.normal(N/4, N/8))))\n        segment_size = min(segment_size, N//2)\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N - segment_size + 1)\n            segment = new_solution[i:i+segment_size]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_size:], segment])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.222395002482457,
            10.167675959408044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = np.array([sol for (sol, _) in archive])\n\n    if len(archive) > 1:\n        crowding_distances = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-8)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        segment_size = max(2, min(5, int(np.random.normal(N/4, N/8))))\n        segment_size = min(segment_size, N//2)\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N - segment_size + 1)\n            segment = new_solution[i:i+segment_size]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_size:], segment])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N - segment_size + 1)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score that balances both objectives while applying a novel local search operator combining probabilistic segment insertion and a dynamic segment relocation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            new_pos = np.random.randint(0, N)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            segment = new_solution[k:k+3]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+3:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.759436460150836,
            7.665195316072884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            segment = new_solution[i:j]\n            new_pos = np.random.randint(0, N)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n        if np.random.random() < 0.4:\n            k = np.random.randint(0, N-3)\n            segment = new_solution[k:k+3]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+3:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation with a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k in range(i, j+1):\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.041007596456298,
            5.276032746432992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k in range(i, j+1):\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score that prioritizes improvement in the first objective while applying a hybrid local search combining a probabilistic segment inversion and a segment rotation to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.8, 0.2])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(i, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.5:\n            k = np.random.randint(0, N-2)\n            segment = new_solution[k:k+2]\n            new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[k+2:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score that prioritizes solutions with balanced improvement in both objectives, while applying a novel hybrid local search combining a probabilistic segment relocation and a segment reversal with adaptive size selection to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        segment_size = min(3, max(2, np.random.randint(1, N//2)))\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N - segment_size)\n            segment = new_solution[i:i+segment_size]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_size:], segment])\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N - segment_size)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.44595752526841,
            9.14415180686798
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        segment_size = min(3, max(2, np.random.randint(1, N//2)))\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N - segment_size)\n            segment = new_solution[i:i+segment_size]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_size:], segment])\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N - segment_size)\n            new_solution[i:i+segment_size] = new_solution[i:i+segment_size][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment reversal and a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            shift = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, shift)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.302931744351728,
            8.663334418310082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            shift = np.random.randint(1, N)\n            new_solution = np.roll(new_solution, shift)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic edge exchange with a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.716266328640837,
            8.742596776535992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic 3-opt move with a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_segment = np.concatenate([segment2, segment1])\n            new_solution[i:k] = new_segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.603966423884804,
            8.822469933892258
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_segment = np.concatenate([segment2, segment1])\n            new_solution[i:k] = new_segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based selection strategy, then applies a novel local search operator that combines a multi-segment insertion and a probabilistic edge exchange to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is not dominated by any other solution in the archive\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Multi-segment insertion\n        if np.random.random() < 0.6:\n            a = np.random.randint(0, N-3)\n            b = np.random.randint(a+2, N-1)\n            c = np.random.randint(b+1, N)\n            new_segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:c], new_segment, new_solution[c:]])\n\n        # Probabilistic edge exchange\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.89475634659226,
            7.457482879197999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution that is not dominated by any other solution in the archive\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated_indices:\n        non_dominated_indices = range(len(archive))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Multi-segment insertion\n        if np.random.random() < 0.6:\n            a = np.random.randint(0, N-3)\n            b = np.random.randint(a+2, N-1)\n            c = np.random.randint(b+1, N)\n            new_segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:c], new_segment, new_solution[c:]])\n\n        # Probabilistic edge exchange\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric that combines crowding distance with objective space dominance, then applies a novel hybrid local search combining a probabilistic segment rotation and a distance-based edge swap to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    diversity_scores = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        diversity_scores[sorted_order[0]] += 1\n        diversity_scores[sorted_order[-1]] += 1\n        for i in range(1, len(sorted_objectives)-1):\n            diversity_scores[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j and abs(i-j) > 1:\n                d1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                d1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                d2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                d2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (d1_after < d1_before and d2_after < d2_before) or (np.random.random() < 0.3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.198278551602017,
            8.218832242418298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    diversity_scores = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        diversity_scores[sorted_order[0]] += 1\n        diversity_scores[sorted_order[-1]] += 1\n        for i in range(1, len(sorted_objectives)-1):\n            diversity_scores[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j and abs(i-j) > 1:\n                d1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                d1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                d2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                d2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (d1_after < d1_before and d2_after < d2_before) or (np.random.random() < 0.3):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This new algorithm selects a solution from the archive based on a dominance rank metric, then applies a hybrid local search combining a probabilistic k-exchange and a segment inversion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] > objectives[j, 1]) or \\\n                   (objectives[i, 0] > objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                    dominated += 1\n        ranks[i] = dominated\n\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            k = np.random.randint(2, 5)\n            indices = np.random.choice(range(N), size=k, replace=False)\n            new_solution[indices] = np.random.permutation(new_solution[indices])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+3, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.85149612440108,
            7.596559184314296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] > objectives[j, 1]) or \\\n                   (objectives[i, 0] > objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                    dominated += 1\n        ranks[i] = dominated\n\n    selected_idx = np.argmin(ranks)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            k = np.random.randint(2, 5)\n            indices = np.random.choice(range(N), size=k, replace=False)\n            new_solution[indices] = np.random.permutation(new_solution[indices])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+3, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy combining a segment reversal with a probabilistic edge swap to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            if i != j and i != (j+1)%N and (i+1)%N != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.324800242999652,
            8.59205551026859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            if i != j and i != (j+1)%N and (i+1)%N != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy combining a segment swap and a node insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            while k in [i, i+1, j]:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.703295765564256,
            8.264234921122585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            while k in [i, i+1, j]:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the combined normalized objective scores, then applies a novel local search strategy that combines a probabilistic segment reversal with a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            while j == i:\n                j = np.random.randint(0, N-1)\n            segment = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.851999135239279,
            6.297559160415172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            while j == i:\n                j = np.random.randint(0, N-1)\n            segment = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance relationship and applies a hybrid local search combining a probabilistic segment insertion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            if i != k and j != k:\n                new_solution[i:j] = np.roll(new_solution[i:j], k-i)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.163312996842597,
            7.7090973955524795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]):\n                dominated[i] = True\n                break\n\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            if i != k and j != k:\n                new_solution[i:j] = np.roll(new_solution[i:j], k-i)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.513563284024154,
            8.389109472575349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of crowding distance and solution quality, then applies a novel hybrid local search combining a probabilistic segment rotation and a multi-swap operation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    quality_scores = np.zeros(len(sorted_objectives))\n    for i in range(len(sorted_objectives)):\n        sol = archive[sorted_indices[i]][0]\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        quality_scores[i] = 1 / (cost1 + cost2 + 1e-8)\n\n    combined_scores = crowding_distances * quality_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            k = np.random.randint(1, min(j-i, 3))\n            segment = new_solution[i:j]\n            rotated = np.roll(segment, k)\n            new_solution[i:j] = rotated\n\n        if np.random.random() < 0.5:\n            num_swaps = np.random.randint(1, min(3, N//2))\n            for _ in range(num_swaps):\n                a, b = np.random.choice(N, 2, replace=False)\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.4206341529526085,
            10.475402377755197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    quality_scores = np.zeros(len(sorted_objectives))\n    for i in range(len(sorted_objectives)):\n        sol = archive[sorted_indices[i]][0]\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        quality_scores[i] = 1 / (cost1 + cost2 + 1e-8)\n\n    combined_scores = crowding_distances * quality_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            k = np.random.randint(1, min(j-i, 3))\n            segment = new_solution[i:j]\n            rotated = np.roll(segment, k)\n            new_solution[i:j] = rotated\n\n        if np.random.random() < 0.5:\n            num_swaps = np.random.randint(1, min(3, N//2))\n            for _ in range(num_swaps):\n                a, b = np.random.choice(N, 2, replace=False)\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest potential improvement in both objectives, then applies a novel local search strategy that combines a probabilistic segment shift and a segment reversal with a dynamic segment length to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            segment_length = np.random.randint(2, min(6, N//2))\n            start = np.random.randint(0, N - segment_length)\n            end = start + segment_length\n            shift = np.random.randint(1, N - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:end+shift], segment, new_solution[end+shift:]])\n\n        if np.random.random() < 0.6:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.168677874001222,
            6.309556339675012
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            segment_length = np.random.randint(2, min(6, N//2))\n            start = np.random.randint(0, N - segment_length)\n            end = start + segment_length\n            shift = np.random.randint(1, N - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:end+shift], segment, new_solution[end+shift:]])\n\n        if np.random.random() < 0.6:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - segment_length)\n            end = start + segment_length\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the best trade-off between objectives using a hypervolume-based selection, then applies a novel local search strategy combining a probabilistic segment transposition and a segment inversion with adaptive probabilities to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ref_point = np.max(objectives, axis=0) + 0.1 * (np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    hv_contributions = np.zeros(len(objectives))\n\n    for i in range(len(objectives)):\n        dominated = np.all((objectives[i] >= objectives) | (objectives == objectives[i]), axis=1)\n        hv_contributions[i] = np.prod(ref_point - objectives[i]) - np.sum(np.prod(ref_point - objectives[dominated]) / len(objectives[dominated]))\n\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+1, N-2)\n            k = np.random.randint(i+1, N-1)\n            l = np.random.randint(k+1, N)\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.201134696604364,
            7.486167630205607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    ref_point = np.max(objectives, axis=0) + 0.1 * (np.max(objectives, axis=0) - np.min(objectives, axis=0))\n    hv_contributions = np.zeros(len(objectives))\n\n    for i in range(len(objectives)):\n        dominated = np.all((objectives[i] >= objectives) | (objectives == objectives[i]), axis=1)\n        hv_contributions[i] = np.prod(ref_point - objectives[i]) - np.sum(np.prod(ref_point - objectives[dominated]) / len(objectives[dominated]))\n\n    selected_idx = np.argmax(hv_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+1, N-2)\n            k = np.random.randint(i+1, N-1)\n            l = np.random.randint(k+1, N)\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = np.roll(new_solution[i:j], shift=1)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.171418363091451,
            4.425958085410281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = np.roll(new_solution[i:j], shift=1)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective improvement potential, then applies a hybrid local search combining a segment rotation and a probabilistic edge exchange to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    improvements = objectives - objectives.min(axis=0)\n    improvement_scores = improvements[:, 0] * improvements[:, 1]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            k = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.443003764415794,
            10.63645908847699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    improvements = objectives - objectives.min(axis=0)\n    improvement_scores = improvements[:, 0] * improvements[:, 1]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            k = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic 3-opt with a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i, j, k = sorted(np.random.choice(N, 3, replace=False))\n            a, b, c, d = new_solution[i], new_solution[j], new_solution[i+1], new_solution[k]\n            new_solution[i], new_solution[j], new_solution[i+1], new_solution[k] = a, c, b, d\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.669378248637191,
            8.32606310281834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i, j, k = sorted(np.random.choice(N, 3, replace=False))\n            a, b, c, d = new_solution[i], new_solution[j], new_solution[i+1], new_solution[k]\n            new_solution[i], new_solution[j], new_solution[i+1], new_solution[k] = a, c, b, d\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance count to identify non-dominated solutions, then applies a hybrid local search combining a probabilistic edge exchange and a segment inversion to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = np.array([sol for (sol, _) in archive])\n    N = len(solutions[0])\n\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[j] += 1\n\n    non_dominated_indices = np.where(dominance_counts == 0)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            while k == i or k == j:\n                k = np.random.randint(0, N-1)\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.800419195944844,
            7.447548372654217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = np.array([sol for (sol, _) in archive])\n    N = len(solutions[0])\n\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[j] += 1\n\n    non_dominated_indices = np.where(dominance_counts == 0)[0]\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            while k == i or k == j:\n                k = np.random.randint(0, N-1)\n            new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-based selection to prioritize non-dominated solutions, then applies a novel local search combining a probabilistic segment insertion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            rotation = np.random.randint(1, j-i)\n            new_solution[i:j] = np.roll(new_solution[i:j], rotation)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.491152690651511,
            6.931222841093254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            rotation = np.random.randint(1, j-i)\n            new_solution[i:j] = np.roll(new_solution[i:j], rotation)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment swapping and a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:k+1], new_solution[i+1:k], segment, new_solution[k+1:]])\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.310779686559415,
            9.151035033975093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:k+1], new_solution[i+1:k], segment, new_solution[k+1:]])\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment relocation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            if k < i:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j+1:]])\n            elif k > j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n            else:\n                new_solution[i:j+1] = segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.574435700935084,
            8.757414457960717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            if k < i:\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:i], new_solution[j+1:]])\n            elif k > j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n            else:\n                new_solution[i:j+1] = segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment reversal and a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            if k < i:\n                new_solution = np.concatenate([segment, new_solution[:k], new_solution[k:i], new_solution[j+1:]])\n            elif k > j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n            else:\n                new_solution[i:j+1] = np.roll(segment, np.random.randint(1, len(segment)))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.57362652978697,
            8.699808726004587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            if k < i:\n                new_solution = np.concatenate([segment, new_solution[:k], new_solution[k:i], new_solution[j+1:]])\n            elif k > j:\n                new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n            else:\n                new_solution[i:j+1] = np.roll(segment, np.random.randint(1, len(segment)))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection strategy combining objective dominance and crowding distance, then applies a novel segment rotation and probabilistic edge exchange operator to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    fronts = np.zeros(len(archive), dtype=int)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            fronts[i] = 1\n\n    if np.sum(fronts) > 0:\n        candidates = [i for i in range(len(archive)) if fronts[i] == 1]\n    else:\n        candidates = list(range(len(archive)))\n\n    if len(candidates) > 1:\n        objectives = objectives[candidates]\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_distances = np.zeros(len(sorted_objectives))\n        for m in range(2):\n            sorted_order = np.argsort(sorted_objectives[:, m])\n            crowding_distances[sorted_order[0]] = np.inf\n            crowding_distances[sorted_order[-1]] = np.inf\n            for i in range(1, len(sorted_objectives)-1):\n                crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[candidates[sorted_indices[selected_idx]]][0].copy()\n    else:\n        base_solution = archive[candidates[0]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            k = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if np.random.random() < 0.3:\n                k = np.random.randint(0, N-1)\n                l = np.random.randint(k+1, N)\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.382388111235594,
            10.329916027507025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    fronts = np.zeros(len(archive), dtype=int)\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            fronts[i] = 1\n\n    if np.sum(fronts) > 0:\n        candidates = [i for i in range(len(archive)) if fronts[i] == 1]\n    else:\n        candidates = list(range(len(archive)))\n\n    if len(candidates) > 1:\n        objectives = objectives[candidates]\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        sorted_objectives = objectives[sorted_indices]\n\n        crowding_distances = np.zeros(len(sorted_objectives))\n        for m in range(2):\n            sorted_order = np.argsort(sorted_objectives[:, m])\n            crowding_distances[sorted_order[0]] = np.inf\n            crowding_distances[sorted_order[-1]] = np.inf\n            for i in range(1, len(sorted_objectives)-1):\n                crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n        selected_idx = np.argmax(crowding_distances)\n        base_solution = archive[candidates[sorted_indices[selected_idx]]][0].copy()\n    else:\n        base_solution = archive[candidates[0]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            k = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if np.random.random() < 0.3:\n                k = np.random.randint(0, N-1)\n                l = np.random.randint(k+1, N)\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm prioritizes solutions with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment reversal with a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.522131341745065,
            8.968938960365998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the combined objective space, then applies a novel local search strategy that combines a probabilistic segment insertion and a segment reversal with a dynamic segment length adjustment to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            segment_length = np.random.randint(2, min(5, N//2))\n            i = np.random.randint(0, N-segment_length)\n            j = np.random.randint(0, N-segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.385012549391026,
            6.115585729386149
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            segment_length = np.random.randint(2, min(5, N//2))\n            i = np.random.randint(0, N-segment_length)\n            j = np.random.randint(0, N-segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment reversal with a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+1, N-2)\n            k = np.random.randint(j+1, N-1)\n            segment = new_solution[i:j+1]\n            shifted_segment = np.concatenate([new_solution[j+1:k+1], segment])\n            new_solution[i:k+1] = shifted_segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.655556011621614,
            9.016667871109757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+1, N-2)\n            k = np.random.randint(j+1, N-1)\n            segment = new_solution[i:j+1]\n            shifted_segment = np.concatenate([new_solution[j+1:k+1], segment])\n            new_solution[i:k+1] = shifted_segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the sum of normalized objectives, then applies a novel local search strategy that combines a probabilistic segment insertion and a segment reversal with a distance-aware swap to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    sum_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(sum_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N-1)\n            while k == i or k == j:\n                k = np.random.randint(0, N-1)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            while j == i or abs(i-j) < 2:\n                j = np.random.randint(0, N-1)\n            if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]] < distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.165577273515492,
            6.075481339132971
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    sum_scores = np.sum(normalized_scores, axis=1)\n    selected_idx = np.argmin(sum_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N-1)\n            while k == i or k == j:\n                k = np.random.randint(0, N-1)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(0, N-1)\n            while j == i or abs(i-j) < 2:\n                j = np.random.randint(0, N-1)\n            if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]] < distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment reversal with a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.563573570350762,
            8.432960326109452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment shift and a segment reversal with a dynamic segment length adjustment to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.65:\n            segment_length = np.random.randint(2, min(6, N//2))\n            i = np.random.randint(0, N-segment_length)\n            j = np.random.randint(0, N-segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.55:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, min(i+8, N))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.916177765299955,
            8.62767784899848
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        if np.random.random() < 0.65:\n            segment_length = np.random.randint(2, min(6, N//2))\n            i = np.random.randint(0, N-segment_length)\n            j = np.random.randint(0, N-segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.55:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, min(i+8, N))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a hybrid local search combining a probabilistic edge exchange and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N-2)\n            l = np.random.randint(k+1, N-1)\n            if i != k and j != l:\n                segment1 = new_solution[i:j+1]\n                segment2 = new_solution[k:l+1]\n                new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if j - i > 1:\n                rotation = np.random.randint(1, j - i)\n                new_solution[i:j] = np.roll(new_solution[i:j], rotation)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.477109680867144,
            10.553559297610237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N-2)\n            l = np.random.randint(k+1, N-1)\n            if i != k and j != l:\n                segment1 = new_solution[i:j+1]\n                segment2 = new_solution[k:l+1]\n                new_solution = np.concatenate([new_solution[:i], segment2, new_solution[j+1:k], segment1, new_solution[l+1:]])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if j - i > 1:\n                rotation = np.random.randint(1, j - i)\n                new_solution[i:j] = np.roll(new_solution[i:j], rotation)\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.50300017780092,
            8.709684781177215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel segment insertion and cyclic permutation operator to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        diversity_scores = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            diversity_scores[i] = np.sum(np.sqrt(np.sum((objectives[i] - objectives)**2, axis=1)))\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        if np.random.random() < 0.6:\n            insert_pos = np.random.randint(0, N - segment_length)\n            if insert_pos < start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[start+segment_length:]])\n            else:\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            if segment_length > 2:\n                new_solution[start:start+segment_length] = np.roll(segment, np.random.randint(1, segment_length))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.697240903897789,
            7.175825155944804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        diversity_scores = np.zeros(len(objectives))\n        for i in range(len(objectives)):\n            diversity_scores[i] = np.sum(np.sqrt(np.sum((objectives[i] - objectives)**2, axis=1)))\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        segment_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        if np.random.random() < 0.6:\n            insert_pos = np.random.randint(0, N - segment_length)\n            if insert_pos < start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[start+segment_length:]])\n            else:\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:insert_pos], segment, new_solution[insert_pos:]])\n        else:\n            if segment_length > 2:\n                new_solution[start:start+segment_length] = np.roll(segment, np.random.randint(1, segment_length))\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment shuffle and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            np.random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.690329768253845,
            8.51502481061269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            np.random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm uses a non-dominated sorting approach to prioritize solutions with better Pareto front rankings, then applies a novel hybrid local search combining a probabilistic segment rotation and a conditional segment inversion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    fronts = []\n    remaining = np.arange(len(archive))\n    current_front = []\n\n    while len(remaining) > 0:\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                    dominated = True\n                    break\n            if not dominated:\n                current_front.append(i)\n        fronts.append(current_front)\n        remaining = np.setdiff1d(remaining, current_front)\n        current_front = []\n\n    selected_front = fronts[0] if len(fronts) > 0 else [0]\n    selected_idx = np.random.choice(selected_front)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if j - i > 2:\n                segment = new_solution[i:j]\n                new_solution[i:j] = np.concatenate([segment[-1:], segment[:-1]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.8439416304491285,
            8.02434087105155
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    fronts = []\n    remaining = np.arange(len(archive))\n    current_front = []\n\n    while len(remaining) > 0:\n        for i in remaining:\n            dominated = False\n            for j in remaining:\n                if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                    dominated = True\n                    break\n            if not dominated:\n                current_front.append(i)\n        fronts.append(current_front)\n        remaining = np.setdiff1d(remaining, current_front)\n        current_front = []\n\n    selected_front = fronts[0] if len(fronts) > 0 else [0]\n    selected_idx = np.random.choice(selected_front)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if j - i > 2:\n                segment = new_solution[i:j]\n                new_solution[i:j] = np.concatenate([segment[-1:], segment[:-1]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the combined objective space (using a novel weighted sum of normalized objectives), then applies a hybrid local search strategy that combines a probabilistic segment insertion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            if k < i or k > j:\n                new_solution = np.concatenate([new_solution[:k], segment, np.delete(new_solution, np.arange(i, j+1))])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[-1:], segment[:-1]])\n            new_solution[i:j+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.848334990603027,
            6.857256389871109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.5, 0.5])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            if k < i or k > j:\n                new_solution = np.concatenate([new_solution[:k], segment, np.delete(new_solution, np.arange(i, j+1))])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[-1:], segment[:-1]])\n            new_solution[i:j+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a segment crossover and a segment reversal with a probabilistic bias to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.434554481116059,
            8.247874546049966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search strategy that combines adaptive segment rotation with probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive[0][0])\n\n    # Select solution with good balance between objectives\n    objective_ratios = objectives[:, 0] / (objectives[:, 1] + 1e-8)\n    selected_idx = np.argmin(np.abs(objective_ratios - np.median(objective_ratios)))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Adaptive segment rotation\n        segment_length = max(2, min(5, N // 4))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.464092736913816,
            9.20466535306594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive[0][0])\n\n    # Select solution with good balance between objectives\n    objective_ratios = objectives[:, 0] / (objectives[:, 1] + 1e-8)\n    selected_idx = np.argmin(np.abs(objective_ratios - np.median(objective_ratios)))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Adaptive segment rotation\n        segment_length = max(2, min(5, N // 4))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment reversal with a segment relocation to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:k+1], segment, new_solution[k+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.074675634171886,
            4.396666119230714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:k+1], segment, new_solution[k+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance probability metric to identify non-dominated solutions, then applies a hybrid local search combining a probabilistic segment insertion and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    probs = 1 / (1 + dominance_counts)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            k = np.random.randint(1, j-i)\n            segment = new_solution[i:i+k]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+k:j], segment, new_solution[j:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.112054753205547,
            7.264754194146056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    probs = 1 / (1 + dominance_counts)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            k = np.random.randint(1, j-i)\n            segment = new_solution[i:i+k]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+k:j], segment, new_solution[j:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment reversal with a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            segment = new_solution[i:]\n            shifted_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:] = shifted_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.524458997644992,
            8.579693536500539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            segment = new_solution[i:]\n            shifted_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:] = shifted_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm selects a solution from the archive based on a probabilistic selection weighted by the inverse of its objective values, then applies a hybrid local search combining a probabilistic edge exchange and a segment rotation to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    inv_objectives = 1 / (objectives + 1e-8)\n    selection_probs = inv_objectives[:, 0] * inv_objectives[:, 1]\n    selection_probs /= np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i or (i == N-1 and j == 0) or (j == N-1 and i == 0):\n                j = np.random.randint(0, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.959870681868164,
            7.106575064870761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    inv_objectives = 1 / (objectives + 1e-8)\n    selection_probs = inv_objectives[:, 0] * inv_objectives[:, 1]\n    selection_probs /= np.sum(selection_probs)\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i or (i == N-1 and j == 0) or (j == N-1 and i == 0):\n                j = np.random.randint(0, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            segment = new_solution[i:j]\n            rotation = np.random.randint(1, len(segment))\n            new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment reversal and a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(1, N - (j-i))\n            segment = new_solution[i:j+1]\n            shifted_segment = np.concatenate([segment[k:], segment[:k]])\n            new_solution[i:j+1] = shifted_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.398722509037191,
            8.303871522871383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(1, N - (j-i))\n            segment = new_solution[i:j+1]\n            shifted_segment = np.concatenate([segment[k:], segment[:k]])\n            new_solution[i:j+1] = shifted_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined improvement in both objectives, then applies a novel local search strategy that combines a probabilistic segment insertion and a segment reversal with position swapping to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    improvements = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        total_cost = obj[0] + obj[1]\n        improvements[i] = total_cost\n\n    selected_idx = np.argmin(improvements)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j]\n            new_segment = np.concatenate([new_solution[:i], [new_solution[k]], new_solution[i:k], new_solution[k+1:]])\n            new_solution = new_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            if np.random.random() < 0.3:\n                p = np.random.randint(0, N)\n                q = np.random.randint(0, N)\n                new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.484291549785882,
            5.9940390090707805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    improvements = np.zeros(len(archive))\n    for i, (sol, obj) in enumerate(archive):\n        total_cost = obj[0] + obj[1]\n        improvements[i] = total_cost\n\n    selected_idx = np.argmin(improvements)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j]\n            new_segment = np.concatenate([new_solution[:i], [new_solution[k]], new_solution[i:k], new_solution[k+1:]])\n            new_solution = new_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            if np.random.random() < 0.3:\n                p = np.random.randint(0, N)\n                q = np.random.randint(0, N)\n                new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion, and also incorporates a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N-1)\n            if k != i and k != j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:k+1], segment, new_solution[k+1:i], new_solution[j+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.167520399959663,
            4.476474478176657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N-1)\n            if k != i and k != j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:k+1], segment, new_solution[k+1:i], new_solution[j+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment reversal with a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.413652025869839,
            8.800412955402255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement and solution diversity, then applies a novel local search strategy that combines a multi-segment shuffle and a probabilistic edge swap with objective-aware selection to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [s for s, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    if len(solutions) > 1:\n        objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        if np.any(objective_ranges > 0):\n            normalized = (objectives - np.min(objectives, axis=0)) / objective_ranges\n            diversity = np.mean(np.std([s for s in solutions], axis=0))\n            scores = np.sum(normalized * [0.4, 0.6], axis=1) + 0.3 * diversity\n            selected_idx = np.argmin(scores)\n        else:\n            selected_idx = np.random.randint(len(solutions))\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            num_segments = np.random.randint(2, min(4, N//2))\n            segments = []\n            points = sorted(np.random.choice(range(1, N), num_segments-1, replace=False))\n            points = [0] + points + [N]\n            for i in range(num_segments):\n                segments.append(new_solution[points[i]:points[i+1]])\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        if np.random.random() < 0.5:\n            for _ in range(min(3, N//2)):\n                i = np.random.randint(0, N-1)\n                j = np.random.randint(i+1, N)\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n                if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.264533136236405,
            5.171183338719175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [s for s, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    if len(solutions) > 1:\n        objective_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        if np.any(objective_ranges > 0):\n            normalized = (objectives - np.min(objectives, axis=0)) / objective_ranges\n            diversity = np.mean(np.std([s for s in solutions], axis=0))\n            scores = np.sum(normalized * [0.4, 0.6], axis=1) + 0.3 * diversity\n            selected_idx = np.argmin(scores)\n        else:\n            selected_idx = np.random.randint(len(solutions))\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            num_segments = np.random.randint(2, min(4, N//2))\n            segments = []\n            points = sorted(np.random.choice(range(1, N), num_segments-1, replace=False))\n            points = [0] + points + [N]\n            for i in range(num_segments):\n                segments.append(new_solution[points[i]:points[i+1]])\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n        if np.random.random() < 0.5:\n            for _ in range(min(3, N//2)):\n                i = np.random.randint(0, N-1)\n                j = np.random.randint(i+1, N)\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%N]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%N]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%N]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%N]]\n\n                if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment reversal with a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.432959139398072,
            4.457090125403847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy that combines a probabilistic segment relocation with a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.760263973555581,
            8.715921736571596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:], segment])\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment swap and a segment reversal to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.517776665152645,
            8.378894029552677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n            new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment insertion and a segment reversal with a dynamic segment length to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.8:\n            segment_length = np.random.randint(2, min(6, N-1))\n            i = np.random.randint(0, N-segment_length)\n            j = np.random.randint(0, N-segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, min(i+5, N))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.249839866744071,
            8.45565904897755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.8:\n            segment_length = np.random.randint(2, min(6, N-1))\n            i = np.random.randint(0, N-segment_length)\n            j = np.random.randint(0, N-segment_length)\n            segment = new_solution[i:i+segment_length]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+segment_length:j], segment, new_solution[j:]])\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, min(i+5, N))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment reversal and a segment rotation to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.4376504368632705,
            8.743692462145484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a novel local search strategy that combines a probabilistic segment reversal and a segment insertion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1].copy()\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.358611060210297,
            8.724314519838952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            segment = new_solution[i:j+1].copy()\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm selects a solution from the archive based on a hypervolume contribution metric to prioritize solutions with high potential for improvement, then applies a hybrid local search combining a probabilistic segment rotation and a segment inversion with adaptive probabilities to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolume_contributions = np.zeros(len(objectives))\n\n    for i in range(len(objectives)):\n        dominated = np.all((objectives <= objectives[i]) & (objectives != objectives[i]), axis=1)\n        if not np.any(dominated):\n            hypervolume_contributions[i] = np.prod(max_obj - objectives[i])\n        else:\n            dominated_indices = np.where(dominated)[0]\n            for j in dominated_indices:\n                hypervolume_contributions[i] += np.prod(objectives[j] - objectives[i])\n\n    selected_idx = np.argmax(hypervolume_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+2, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.5 * (1 - selected_idx/len(archive)):\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.431174971596116,
            10.688228506740728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    max_obj = np.max(objectives, axis=0)\n    hypervolume_contributions = np.zeros(len(objectives))\n\n    for i in range(len(objectives)):\n        dominated = np.all((objectives <= objectives[i]) & (objectives != objectives[i]), axis=1)\n        if not np.any(dominated):\n            hypervolume_contributions[i] = np.prod(max_obj - objectives[i])\n        else:\n            dominated_indices = np.where(dominated)[0]\n            for j in dominated_indices:\n                hypervolume_contributions[i] += np.prod(objectives[j] - objectives[i])\n\n    selected_idx = np.argmax(hypervolume_contributions)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+2, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.5 * (1 - selected_idx/len(archive)):\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance count metric to prioritize solutions with fewer dominating solutions, then applies a hybrid local search combining a segment rotation and a probabilistic edge exchange to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate((new_solution[:i], new_solution[j:k], segment, new_solution[k:]))\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.488029954413232,
            10.654953883710254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance_counts[i] += 1\n\n    selected_idx = np.argmin(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j]\n            new_solution = np.concatenate((new_solution[:i], new_solution[j:k], segment, new_solution[k:]))\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the first objective, then applies a hybrid local search strategy combining a probabilistic segment reversal and a segment shift to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+1, N-2)\n            k = np.random.randint(j+1, N-1)\n            segment = new_solution[j:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[k+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.803885527712023,
            8.72170778235787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.7, 0.3])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-3)\n            j = np.random.randint(i+1, N-2)\n            k = np.random.randint(j+1, N-1)\n            segment = new_solution[j:k+1]\n            new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[k+1:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized dominance metric that balances dominance rank and crowding distance, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive)\n\n    # Normalized dominance metric\n    ranks = np.zeros(N)\n    for i in range(N):\n        dominated = 0\n        for j in range(N):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated += 1\n        ranks[i] = dominated\n\n    # Crowding distance\n    crowding_distances = np.zeros(N)\n    for m in range(2):\n        sorted_order = np.argsort(objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, N-1):\n            crowding_distances[sorted_order[i]] += (objectives[sorted_order[i+1], m] - objectives[sorted_order[i-1], m]) / (objectives[sorted_order[-1], m] - objectives[sorted_order[0], m] + 1e-8)\n\n    # Combine metrics\n    scores = (ranks / (N-1)) + (1 - crowding_distances / (np.max(crowding_distances) + 1e-8))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N_nodes = len(new_solution)\n\n    if N_nodes > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N_nodes-1)\n            j = np.random.randint(i+1, N_nodes)\n            k = np.random.randint(0, N_nodes-1)\n            l = np.random.randint(k+1, N_nodes)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N_nodes-2)\n            j = np.random.randint(i+2, N_nodes)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.534322552036448,
            8.997646565350331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(archive)\n\n    # Normalized dominance metric\n    ranks = np.zeros(N)\n    for i in range(N):\n        dominated = 0\n        for j in range(N):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated += 1\n        ranks[i] = dominated\n\n    # Crowding distance\n    crowding_distances = np.zeros(N)\n    for m in range(2):\n        sorted_order = np.argsort(objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, N-1):\n            crowding_distances[sorted_order[i]] += (objectives[sorted_order[i+1], m] - objectives[sorted_order[i-1], m]) / (objectives[sorted_order[-1], m] - objectives[sorted_order[0], m] + 1e-8)\n\n    # Combine metrics\n    scores = (ranks / (N-1)) + (1 - crowding_distances / (np.max(crowding_distances) + 1e-8))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N_nodes = len(new_solution)\n\n    if N_nodes > 3:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N_nodes-1)\n            j = np.random.randint(i+1, N_nodes)\n            k = np.random.randint(0, N_nodes-1)\n            l = np.random.randint(k+1, N_nodes)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N_nodes-2)\n            j = np.random.randint(i+2, N_nodes)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N_nodes:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]