[
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic path fragmentation with probabilistic node swapping and objective-guided segment inversion to explore high-quality diverse neighborhoods while maintaining feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic path fragmentation\n    frag_size = max(2, min(5, n // 5))\n    breaks = sorted(random.sample(range(1, n), frag_size - 1))\n    fragments = []\n    prev = 0\n    for b in breaks:\n        fragments.append(new_solution[prev:b])\n        prev = b\n    fragments.append(new_solution[prev:])\n\n    # Phase 2: Probabilistic node swapping\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 3: Objective-guided segment inversion\n    if random.random() < 0.3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        segment = new_solution[start:end+1]\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        if obj1 + obj2 > (obj1 + obj2) * 1.1:\n            new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9592359181059527,
            0.4170905351638794
        ]
    }
]