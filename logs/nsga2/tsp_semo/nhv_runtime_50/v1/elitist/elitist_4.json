[
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9562472386861592,
            0.4804345369338989
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9459011245393834,
            0.46104997396469116
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9562472386861592,
            0.4804345369338989
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9459011245393834,
            0.46104997396469116
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    }
]