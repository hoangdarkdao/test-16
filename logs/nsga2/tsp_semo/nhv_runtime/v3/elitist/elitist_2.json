[
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9604449175379328,
            2.4669695496559143
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.81865648773061,
            0.2664041519165039
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9448300072074868,
            1.8027246594429016
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.81865648773061,
            0.2664041519165039
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert (ensuring feasibility)\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a multi-objective-aware 3-opt move to further refine the solution\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Evaluate the two possible 3-opt moves and choose the one that improves the most\n    option1 = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    option2 = np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]])\n\n    # Calculate the cost difference for both options\n    def calculate_cost(solution):\n        total1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        total2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return total1, total2\n\n    cost1_orig, cost2_orig = calculate_cost(new_solution)\n    cost1_opt1, cost2_opt1 = calculate_cost(option1)\n    cost1_opt2, cost2_opt2 = calculate_cost(option2)\n\n    # Choose the option that improves both objectives or the one that improves the most\n    if (cost1_opt1 < cost1_orig and cost2_opt1 < cost2_orig) or (cost1_opt2 < cost1_orig and cost2_opt2 < cost2_orig):\n        if cost1_opt1 + cost2_opt1 < cost1_opt2 + cost2_opt2:\n            new_solution = option1\n        else:\n            new_solution = option2\n    else:\n        if (cost1_opt1 < cost1_orig or cost2_opt1 < cost2_orig) and (cost1_opt1 + cost2_opt1 < cost1_opt2 + cost2_opt2):\n            new_solution = option1\n        elif (cost1_opt2 < cost1_orig or cost2_opt2 < cost2_orig):\n            new_solution = option2\n\n    return new_solution\n\n",
        "score": [
            -0.869824652952374,
            0.45603346824645996
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with non-dominated objectives, then applies a novel multi-objective-aware segment rotation that combines elements of both objective spaces to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[np.random.choice(len(archive))][0].copy()\n    else:\n        base_solution = non_dominated[np.random.choice(len(non_dominated))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment rotation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Determine rotation direction based on both objectives\n    # Calculate cost difference for both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    rotated_segment = segment[::-1]\n    candidate = new_solution.copy()\n    candidate[a:b+1] = rotated_segment\n\n    rotated_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n    rotated_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n    # Calculate dominance relationship\n    dominates = (rotated_cost1 <= original_cost1 and rotated_cost2 <= original_cost2 and\n                (rotated_cost1 < original_cost1 or rotated_cost2 < original_cost2))\n\n    if dominates:\n        new_solution = candidate\n    else:\n        # Alternative: rotate based on which objective has higher improvement\n        if (original_cost1 - rotated_cost1) > (original_cost2 - rotated_cost2):\n            # Rotate based on first objective\n            new_solution[a:b+1] = rotated_segment\n        else:\n            # Rotate based on second objective\n            new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9045322115781274,
            0.5668517351150513
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9604449175379328,
            2.4669695496559143
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9542055396975432,
            2.0111894607543945
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9448300072074868,
            1.8027246594429016
        ]
    }
]