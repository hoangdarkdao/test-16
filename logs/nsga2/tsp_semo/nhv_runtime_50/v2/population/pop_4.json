[
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    # Calculate crowding distance\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Distance-aware segment reversal\n    if n > 5:\n        # Calculate segment costs\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        # Find segments to reverse\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.994337138149379,
            0.4075266718864441
        ]
    },
    {
        "algorithm": "{This algorithm selects the most diverse solution from the archive based on the maximum of objectives, then applies a \"segmented crossover\" operator that combines segments from two randomly selected solutions, followed by a \"adaptive reversal\" that reverses segments based on their current position in the tour to explore different configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: max(x[1]))\n    base_solution = archive[-1][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1:\n        other_solution = archive[np.random.randint(1, len(archive))][0].copy()\n\n        # Segmented crossover\n        crossover_point = np.random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if crossover causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive reversal\n    if n > 3:\n        reversal_point = np.random.randint(1, n-2)\n        if reversal_point < n//2:\n            new_solution[reversal_point:] = new_solution[reversal_point:][::-1]\n        else:\n            new_solution[:reversal_point] = new_solution[:reversal_point][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9007001667518985,
            0.0945250391960144
        ]
    }
]