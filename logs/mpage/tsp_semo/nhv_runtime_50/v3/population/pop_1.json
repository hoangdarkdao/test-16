[
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-objective adaptive local search strategy that intelligently selects a promising solution from the archive based on a combined objective score (normalized sum of both objectives), then applies a novel hybrid local search operator that combines edge insertion with a biased random walk to explore high-potential regions of the search space. The method first identifies the Pareto-frontier solutions in the archive, then selects a base solution probabilistically weighted by its dominance and diversity, followed by a two-stage perturbation: 1) a constrained segment inversion that preserves node connectivity, and 2) a multi-objective-aware edge swap that prioritizes improvements in both objectives while ensuring feasibility through a validation check. The generated neighbor solution is guaranteed to be a valid TSP tour through the use of a permutation repair mechanism that corrects any invalid sequences.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Stage 1: Constrained segment inversion\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n    # Stage 2: Multi-objective-aware edge swap\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        prev_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        prev_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if both objectives improve\n        if (new_cost1 < prev_cost1) and (new_cost2 < prev_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.9434502893378602,
               0.6291956901550293
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize those with lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: a combination of segment reversal and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (to avoid getting stuck in local optima)\n    start = np.random.randint(0, n - 1)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert (to explore new neighborhoods)\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = np.concatenate([new_solution[mask], [node_to_move]])\n\n    return new_solution\n\n",
          "score": [
               -0.7095738278032713,
               0.4901522397994995
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select a solution that is not dominated by others\n        selected_idx = 0\n        for i in range(1, len(archive)):\n            if (objectives[i][0] < objectives[selected_idx][0] and objectives[i][1] <= objectives[selected_idx][1]) or \\\n               (objectives[i][0] <= objectives[selected_idx][0] and objectives[i][1] < objectives[selected_idx][1]):\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to reverse (novel segment reversal)\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 2-opt to improve the solution\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if not (np.array_equal(np.unique(new_solution), np.arange(n)) and len(new_solution) == n):\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               -0.8398412362557686,
               0.5397500395774841
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a promising solution from the archive by prioritizing those with the highest potential for improvement, measured by the ratio of their objective values to the average objective values in the archive. It then applies a hybrid local search operator that combines a novel edge-swapping strategy with a perturbation mechanism. The edge-swapping strategy identifies the most critical edges in the solution based on their contribution to the total cost in both objective spaces, and swaps them with alternative edges that reduce the total cost. The perturbation mechanism introduces controlled randomness to escape local optima by randomly swapping a subset of edges. The algorithm ensures feasibility by maintaining a valid TSP tour throughout the process, and it iteratively refines the solution until no further improvement is possible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (highest potential for improvement)\n    avg_cost1 = np.mean([obj[0] for _, obj in archive])\n    avg_cost2 = np.mean([obj[1] for _, obj in archive])\n\n    # Calculate the improvement potential for each solution\n    potentials = []\n    for sol, obj in archive:\n        cost1, cost2 = obj\n        potential = (cost1 / avg_cost1) + (cost2 / avg_cost2)  # Higher is better (more potential)\n        potentials.append(potential)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping strategy (novel approach)\n    # Identify the most critical edges in both objective spaces\n    critical_edges = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        critical_edges.append((i, (i + 1) % n, cost1, cost2))\n\n    # Sort edges by their contribution to the total cost (descending)\n    critical_edges.sort(key=lambda x: -(x[2] + x[3]))\n\n    # Swap the most critical edges with alternative edges\n    for i in range(min(3, len(critical_edges))):  # Limit to top 3 critical edges\n        pos1, pos2, _, _ = critical_edges[i]\n        # Find alternative edges to swap with\n        for j in range(n):\n            if j == pos1 or j == pos2 or (j + 1) % n == pos1 or (j + 1) % n == pos2:\n                continue\n            # Calculate the cost of the alternative edge\n            u = new_solution[pos1]\n            v = new_solution[(pos1 + 1) % n]\n            new_u = new_solution[j]\n            new_v = new_solution[(j + 1) % n]\n            cost1_old = distance_matrix_1[u, v] + distance_matrix_1[new_u, new_v]\n            cost1_new = distance_matrix_1[u, new_u] + distance_matrix_1[new_v, v]\n            cost2_old = distance_matrix_2[u, v] + distance_matrix_2[new_u, new_v]\n            cost2_new = distance_matrix_2[u, new_u] + distance_matrix_2[new_v, v]\n            # If the alternative edge reduces the total cost, perform the swap\n            if (cost1_new + cost2_new) < (cost1_old + cost2_old):\n                # Perform the swap\n                new_solution[pos1] = new_u\n                new_solution[(pos1 + 1) % n] = new_v\n                new_solution[j] = u\n                new_solution[(j + 1) % n] = v\n                break\n\n    # Step 2: Perturbation mechanism (introduce controlled randomness)\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        # Randomly select a segment to reverse\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n // 2))  # Random segment length\n        end = (start + length) % n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            segment = segment[::-1]\n            new_solution[start:] = segment[:n - start]\n            new_solution[:end] = segment[n - start:]\n\n    return new_solution\n\n",
          "score": [
               -0.8612723930221843,
               0.5997492074966431
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with low crowding distance)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Dynamic segment replacement\n    n = len(selected_solution)\n    if n < 3:\n        return selected_solution  # No improvement possible\n\n    # Randomly select a segment length (between 2 and n/2)\n    segment_length = np.random.randint(2, max(2, n // 2 + 1))\n\n    # Randomly select a starting index for the segment\n    start_idx = np.random.randint(0, n - segment_length)\n\n    # Extract the segment to be replaced\n    segment = selected_solution[start_idx:start_idx + segment_length]\n\n    # Generate a new segment using a greedy insertion approach weighted by both objectives\n    remaining_nodes = [node for node in selected_solution if node not in segment]\n    new_segment = []\n\n    # Start with a random node from the remaining nodes\n    current_node = np.random.choice(remaining_nodes)\n    new_segment.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while len(new_segment) < segment_length and remaining_nodes:\n        # Find the best next node based on weighted distance\n        best_node = None\n        best_score = float('inf')\n\n        for candidate in remaining_nodes:\n            # Calculate weighted distance to the last node in the new segment\n            dist1 = distance_matrix_1[new_segment[-1], candidate]\n            dist2 = distance_matrix_2[new_segment[-1], candidate]\n            weighted_dist = 0.5 * dist1 + 0.5 * dist2  # Equal weight for simplicity\n\n            if weighted_dist < best_score:\n                best_score = weighted_dist\n                best_node = candidate\n\n        if best_node is not None:\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n    # Replace the segment in the original solution\n    new_solution = np.concatenate([\n        selected_solution[:start_idx],\n        np.array(new_segment),\n        selected_solution[start_idx + segment_length:]\n    ])\n\n    # Ensure the solution is a valid tour (circular)\n    if not np.array_equal(new_solution, selected_solution):\n        # Validate the tour (optional, but good practice)\n        if len(np.unique(new_solution)) == len(selected_solution):\n            return new_solution\n\n    return selected_solution  # Return original if no improvement\n\n",
          "score": [
               -0.8751655686311861,
               0.8388110995292664
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions from the archive by evaluating their Pareto dominance and objective diversity, then intelligently selects one using a weighted random choice based on their non-dominated status and objective values. It then applies a novel hybrid local search operator that combines a randomized edge insertion with a constrained 3-opt move, where segments of the tour are dynamically selected and rearranged to balance exploration and exploitation, while ensuring feasibility by always maintaining a valid Hamiltonian cycle. The operator prioritizes edges with high potential for cost reduction in both objectives, using the instance's coordinate data to guide the selection of move candidates. The function returns the new neighbor solution after validating its feasibility, with the new tour ensuring all nodes are visited exactly once without revisits or omissions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify promising solutions (non-dominated or diverse)\n    non_dominated = []\n    obj_values = np.array([obj for _, obj in archive])\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with weighted random choice\n    weights = []\n    for _, obj in non_dominated:\n        # Higher weight for solutions with better combined objective values\n        combined = obj[0] + obj[1]\n        weights.append(1.0 / (1.0 + combined))\n\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(non_dominated)] * len(non_dominated)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(non_dominated), p=weights)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Randomized edge insertion + constrained 3-opt\n    if n > 3:\n        # Select a random segment of length 3-5\n        segment_length = random.randint(3, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n\n        # Extract the segment and remove it from the solution\n        segment = new_solution[start:start+segment_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Find best insertion points for the segment in both objectives\n        best_insert_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            # Try inserting the segment at position i\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n            # Calculate total cost in both objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n        # Additional 3-opt move to refine the solution\n        if n > 4:\n            # Select three random edges to reconnect\n            i, j, k = sorted(random.sample(range(n), 3))\n\n            # Try different 3-opt moves and keep the best one\n            moves = [\n                (i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)\n            ]\n\n            best_move = None\n            best_move_cost = float('inf')\n\n            for a, b, c in moves:\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[a:b] = np.flip(candidate[a:b])\n                candidate[b:c] = np.flip(candidate[b:c])\n                candidate[c:] = np.flip(candidate[c:])\n\n                # Calculate total cost\n                cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_move_cost:\n                    best_move_cost = total_cost\n                    best_move = (a, b, c)\n\n            if best_move:\n                a, b, c = best_move\n                new_solution[a:b] = np.flip(new_solution[a:b])\n                new_solution[b:c] = np.flip(new_solution[b:c])\n                new_solution[c:] = np.flip(new_solution[c:])\n\n    return new_solution\n\n",
          "score": [
               -0.9288830679944554,
               3.37129807472229
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' employs a novel hybrid local search strategy that combines adaptive selection pressure with a multi-phase perturbation mechanism. It first intelligently samples the archive to identify solutions with high potential for improvement by evaluating their dominance and crowding distance in the bi-objective space, then applies a dynamic 3-exchange operator followed by a targeted inversion of a subtour segment, guided by a weighted objective-aware fitness function that balances the trade-offs between the two objectives. The method ensures feasibility by strictly maintaining permutation properties and includes a validity check to revert to the original solution if the generated neighbor is invalid, guaranteeing the output is always a feasible TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a weighted selection based on dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance and crowding distance (simplified approach)\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                if objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]:\n                    dominated[i] = True\n                    break\n\n    # Select non-dominated solutions if available, otherwise select all\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    selected_indices = non_dominated if non_dominated else list(range(len(archive)))\n\n    # Calculate crowding distance for selected solutions\n    if len(selected_indices) > 1:\n        # Sort by first objective\n        sorted_indices = sorted(selected_indices, key=lambda i: objectives[i][0])\n        crowding = [0.0] * len(archive)\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, len(sorted_indices)-1):\n            crowding[sorted_indices[i]] = abs(objectives[sorted_indices[i+1]][0] - objectives[sorted_indices[i-1]][0])\n\n        # Sort by second objective\n        sorted_indices = sorted(selected_indices, key=lambda i: objectives[i][1])\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, len(sorted_indices)-1):\n            crowding[sorted_indices[i]] += abs(objectives[sorted_indices[i+1]][1] - objectives[sorted_indices[i-1]][1])\n\n        # Select solution with highest crowding distance\n        best_idx = max(selected_indices, key=lambda i: crowding[i])\n    else:\n        best_idx = selected_indices[0]\n\n    base_solution = solutions[best_idx].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive 3-exchange\n    if n >= 3:\n        # Select three distinct positions\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Perform 3-exchange\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Phase 2: Targeted inversion\n    if n >= 2:\n        # Select a segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Verify the solution is valid (permutation)\n    if not (np.array_equal(np.sort(new_solution), np.sort(base_solution)) and len(np.unique(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.692138007707279,
               0.504461407661438
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance and combined cost for each solution\n    dominated = [False] * len(archive)\n    combined_costs = []\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        combined_cost = obj_i[0] + obj_i[1]\n        combined_costs.append(combined_cost)\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated[i] = True\n                break\n\n    # Select non-dominated solutions or those with lowest combined cost\n    promising_indices = [i for i, dom in enumerate(dominated) if not dom]\n    if not promising_indices:\n        promising_indices = [i for i, _ in sorted(enumerate(combined_costs), key=lambda x: x[1])[:max(1, len(archive)//3)]]\n\n    # Step 2: Select a base solution with weighted randomness\n    weights = [1.0 / (1.0 + combined_costs[i]) for i in promising_indices]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = random.choices(promising_indices, weights=probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Adaptive segment inversion with multi-objective awareness\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment boundaries\n    segment_length = max(2, n // 5)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Calculate segment cost before inversion\n    def calculate_segment_cost(sol, start, end):\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(start, end):\n            cost1 += distance_matrix_1[sol[i], sol[(i+1)%n]]\n            cost2 += distance_matrix_2[sol[i], sol[(i+1)%n]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Perform inversion\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Calculate segment cost after inversion\n    new_cost1, new_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Acceptance criterion: accept if at least one objective improves\n    if not (new_cost1 <= original_cost1 and new_cost2 <= original_cost2):\n        # If no improvement, try to find a better segment\n        for _ in range(3):  # Try a few more segments\n            new_start = random.randint(0, n - segment_length - 1)\n            new_end = new_start + segment_length\n            new_new_solution = new_solution.copy()\n            new_new_solution[new_start:new_end] = new_new_solution[new_start:new_end][::-1]\n            new_new_cost1, new_new_cost2 = calculate_segment_cost(new_new_solution, new_start, new_end)\n            if (new_new_cost1 <= original_cost1 and new_new_cost2 <= original_cost2) or \\\n               random.random() < 0.3:  # Small probability of accepting worse solution\n                new_solution = new_new_solution\n                break\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.791548686523524,
               0.5963345170021057
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by ranking them based on a combined objective score, favoring those with lower costs in either objective while also considering their relative diversity in the Pareto front. It then intelligently selects a base solution using a biased random selection that prioritizes solutions with high potential for improvement, measured by their deviation from the average cost in each objective space. The function then applies a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge insertion mechanism. In the inversion phase, it randomly selects 2-4 contiguous segments of the tour and reverses each segment, ensuring feasibility by maintaining node uniqueness. In the edge insertion phase, it identifies high-cost edges in both objective spaces and attempts to reinsert them into the tour using a guided search that minimizes the combined cost of the affected edges while respecting the TSP constraints. The operator dynamically balances exploration and exploitation by adjusting the segment size and insertion candidates based on the current solution's quality and the instance's characteristics. The function ensures the generated neighbor solution remains feasible by strictly enforcing the TSP constraints throughout the local search process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Rank solutions based on combined objective score\n    scores = []\n    for sol, obj in archive:\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        scores.append(score)\n\n    # Select top 30% solutions\n    top_indices = np.argsort(scores)[:max(1, len(archive) // 3)]\n    selected_solutions = [archive[i][0] for i in top_indices]\n\n    if not selected_solutions:\n        selected_solutions = [archive[0][0]]\n\n    # Select a base solution with bias towards higher potential\n    base_solution = selected_solutions[np.random.randint(0, len(selected_solutions))].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(2, 5)\n    segment_length = n // num_segments\n\n    for i in range(num_segments):\n        start = i * segment_length\n        end = (i + 1) * segment_length if i < num_segments - 1 else n\n        if end - start > 1:\n            # Reverse the segment\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge insertion\n    # Calculate edge costs\n    edge_costs = []\n    for i in range(n):\n        from_node = new_solution[i]\n        to_node = new_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[from_node, to_node]\n        cost2 = distance_matrix_2[from_node, to_node]\n        edge_costs.append((cost1 + cost2, i))\n\n    # Sort edges by cost (descending)\n    edge_costs.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 20% edges for potential reinsertion\n    num_edges = max(1, len(edge_costs) // 5)\n    for cost, idx in edge_costs[:num_edges]:\n        i = idx\n        j = (i + 1) % n\n\n        # Try to find a better insertion point\n        best_pos = -1\n        best_improvement = 0\n\n        # Check positions around the current edge\n        for k in range(n):\n            if k == i or k == j or (k + 1) % n == i or (k + 1) % n == j:\n                continue\n\n            # Calculate cost of removing current edge and adding two new edges\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n            new_cost1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                         distance_matrix_1[new_solution[j], new_solution[(k + 1) % n]])\n            new_cost2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                         distance_matrix_2[new_solution[j], new_solution[(k + 1) % n]])\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = k\n\n        if best_pos != -1:\n            # Perform the insertion\n            if best_pos > i:\n                # Move segment between i and j to after best_pos\n                segment = new_solution[i+1:j+1] if j > i else np.concatenate([new_solution[i+1:], new_solution[:j+1]])\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[j+1:best_pos+1],\n                    segment,\n                    new_solution[best_pos+1:]\n                ])\n            else:\n                # Move segment between i and j to before best_pos\n                segment = new_solution[i+1:j+1] if j > i else np.concatenate([new_solution[i+1:], new_solution[:j+1]])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    segment,\n                    new_solution[best_pos+1:i+1],\n                    new_solution[j+1:]\n                ])\n\n    return new_solution\n\n",
          "score": [
               -0.5718668601168597,
               1.6703229546546936
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a scalarizing approach\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scalarized_scores = normalized_objectives.mean(axis=1)\n    best_idx = np.argmin(scalarized_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: randomized 3-opt with biased edge insertion\n    if n >= 3:\n        # Randomly select 3 distinct indices\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # With 20% probability, perform a biased edge insertion\n        if np.random.rand() < 0.2:\n            # Evaluate the current solution\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            # Determine which objective to prioritize\n            if current_cost1 > current_cost2:\n                # Prioritize the first objective\n                best_insert_pos = -1\n                best_insert_cost = float('inf')\n                for pos in range(n):\n                    for node in range(n):\n                        if node not in new_solution:\n                            # Insert node at position pos\n                            temp_solution = np.insert(new_solution, pos, node)\n                            temp_cost = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n+1)]] for i in range(n+1))\n                            if temp_cost < best_insert_cost:\n                                best_insert_cost = temp_cost\n                                best_insert_pos = pos\n                                best_node = node\n                if best_insert_pos != -1:\n                    new_solution = np.insert(new_solution, best_insert_pos, best_node)\n            else:\n                # Prioritize the second objective\n                best_insert_pos = -1\n                best_insert_cost = float('inf')\n                for pos in range(n):\n                    for node in range(n):\n                        if node not in new_solution:\n                            # Insert node at position pos\n                            temp_solution = np.insert(new_solution, pos, node)\n                            temp_cost = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n+1)]] for i in range(n+1))\n                            if temp_cost < best_insert_cost:\n                                best_insert_cost = temp_cost\n                                best_insert_pos = pos\n                                best_node = node\n                if best_insert_pos != -1:\n                    new_solution = np.insert(new_solution, best_insert_pos, best_node)\n\n    return new_solution\n\n",
          "score": [
               -0.6312668495890807,
               1.9907766580581665
          ]
     }
]