[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.842318304956346,
            7.953715747109067
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score that balances improvement potential and solution uniqueness, then applies a hybrid local search combining edge insertion with a probabilistic segment relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware score\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    # Diversity-aware weighting: emphasize less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dist = np.sum(np.abs(normalized_scores - normalized_scores[i]))\n        crowding_distances[i] = dist\n    crowding_weights = 1 / (crowding_distances + 1e-8)\n    crowding_weights = crowding_weights / np.sum(crowding_weights)\n\n    weights = np.array([0.4, 0.6])  # Different weight for second objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1) * crowding_weights\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: edge insertion with probabilistic segment relocation\n        i = np.random.randint(0, N)\n        j = np.random.randint(0, N)\n        if i != j:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, base_solution[i])\n\n        # Probabilistic segment relocation\n        if np.random.random() < 0.3:\n            seg_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N - seg_length)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - seg_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.107927898422226,
            5.4204044935054885
        ]
    }
]