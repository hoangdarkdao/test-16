[
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9616101432470179,
            0.2687221169471741
        ]
    }
]