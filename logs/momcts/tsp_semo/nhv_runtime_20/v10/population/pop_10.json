[
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted probability favoring solutions with lower average normalized objective values, then applies either a standard 2-opt operation or a novel segment inversion/reinsertion strategy to generate a neighbor solution while ensuring feasibility. The segment operation specifically inverts a random segment of the tour and reinserts it at the best position to minimize the combined cost of both objectives, providing a more exploratory local search compared to pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and segment inversion/reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment operation\n    if random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion and reinsertion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9353011851346344,
            1.5762245655059814
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8179669842566333,
            0.3183813691139221
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search that randomly chooses between node swaps or edge insertions to generate a neighbor solution while ensuring feasibility. It selects from the top 10 solutions (or fewer if the archive is small) and verifies the new solution has no duplicates or missing nodes. The method balances exploration (random selection) with exploitation (focusing on lower-cost solutions) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower objectives (prioritize non-dominated solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and edge insertions\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or insertion\n    if random.random() < 0.5:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion\n        if n >= 3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Remove segment from i to j and reinsert at a random position\n            segment = new_solution[i:j+1]\n            remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8861771732022544,
            3.430252432823181
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement by normalizing and combining its two objective values, then applies a hybrid local search that either performs edge insertion (removing and reinserting a node) or node swapping (exchanging two nodes) to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with worse fitness (higher combined normalized objectives) to explore less-explored regions, while the local search balances exploration and exploitation through randomized edge manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Compute normalized objectives for selection\n    obj1 = np.array([obj[0] for obj in archive_objectives])\n    obj2 = np.array([obj[1] for obj in archive_objectives])\n\n    # Normalize objectives\n    if len(obj1) > 1:\n        obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n        obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n\n    # Compute a combined fitness score (lower is better)\n    fitness = obj1 + obj2\n\n    # Select the solution with the highest fitness (most potential for improvement)\n    selected_idx = np.argmax(fitness)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to modify\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Hybrid local search: combine edge insertion and node swapping\n    if np.random.rand() < 0.5:\n        # Edge insertion: remove edge (i, i+1) and insert it between (j, j+1)\n        removed_node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, removed_node)\n    else:\n        # Node swapping: swap nodes at positions i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8780519228388297,
            1.816645324230194
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive and applies a hybrid local search combining 3-opt with a custom edge-swap heuristic to generate a neighbor solution, ensuring feasibility by checking for duplicate nodes and missing nodes. The selection prioritizes solutions with promising potential for improvement, while the hybrid search balances exploration and exploitation across both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a custom edge-swap heuristic\n    n = len(new_solution)\n    if n >= 4:\n        # Randomly select three edges to modify (3-opt)\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Custom edge-swap heuristic: Swap edges in both objective spaces\n        for _ in range(2):  # Perform 2 edge swaps\n            a, b = np.random.choice(range(n), 2, replace=False)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == len(selected_solution), \"Invalid solution: Duplicate nodes\"\n    assert len(new_solution) == len(selected_solution), \"Invalid solution: Missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8380232830229785,
            1.871150016784668
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive using Pareto dominance and hybrid normalization (prioritizing the first objective 60% and the second 40%), then applies a segment-based local search combining inversion, reinsertion, and edge refinement to explore diverse neighborhoods while ensuring feasibility. It balances improvement across objectives by evaluating both distance matrices during segment insertion and refinement. The selection process uses weighted random choice based on normalized objective values, while the local search dynamically adapts segment lengths and performs constrained optimizations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto dominance and hybrid normalization\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    weights = 1 - (normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4)  # Weighted sum\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid segment-based local search\n    if n < 4:\n        # Simple swap for small tours\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment inversion with constrained reinsertion\n        segment_len = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n\n        # Invert and find best insertion point\n        inverted = segment[::-1]\n        remaining = np.delete(new_solution, range(start, start+segment_len))\n\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) - segment_len + 1):\n            temp = np.insert(remaining, pos, inverted)\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(len(temp)))\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted)\n\n        # Edge refinement\n        for _ in range(min(2, n//4)):\n            i, j = sorted(random.sample(range(n), 2))\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8752180633859628,
            3.6663344502449036
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with probability inversely proportional to its normalized objectives, then applies either a 3-opt local search (reversing segments and swapping sub-segments) or a segment rotation operation (rotating a segment by 90\u00b0 in the first objective space and reinserting it optimally). The selection prioritizes solutions with worse normalized objectives, while the local search diversifies improvement strategies to balance exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with inverse probability proportional to its normalized objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    weights = 1 / (normalized.mean(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 3-opt or segment rotation\n    if random.random() < 0.5:\n        # 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n        if random.random() < 0.5:\n            # Swap segments\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Segment rotation in first objective space\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Rotate segment by 90 degrees in first objective space\n        rotated_segment = segment.copy()\n        for i in range(len(segment)):\n            node_idx = segment[i]\n            x1, y1, x2, y2 = instance[node_idx]\n            # Rotate (x1, y1) by 90 degrees\n            new_x1 = -y1\n            new_y1 = x1\n            # Find closest node to rotated position\n            distances = np.sqrt((instance[:, 0] - new_x1)**2 + (instance[:, 1] - new_y1)**2)\n            closest_node = np.argmin(distances)\n            rotated_segment[i] = closest_node\n\n        # Insert rotated segment at best position\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, rotated_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8302917509215617,
            2.358815908432007
        ]
    },
    {
        "algorithm": "The algorithm dynamically selects a promising solution from the archive using a fitness-based approach that balances exploration and exploitation, then applies a hybrid local search combining segment reversal and optimal reinsertion while considering both objectives' costs. It prioritizes solutions with better normalized objective values and uses an adaptive segment size for local improvement, ensuring feasibility by always maintaining a valid TSP tour. The combined cost metric (sum of individual costs plus a balance term) guides the insertion decisions, favoring solutions that improve both objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dynamic selection based on normalized objectives with exploration factor\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    exploration_factor = 0.3  # Balance between exploitation and exploration\n    fitness = (1 - normalized.mean(axis=1)) * (1 - exploration_factor) + exploration_factor * np.random.rand(len(archive))\n    fitness = fitness / fitness.sum()\n    selected_idx = np.random.choice(len(archive), p=fitness)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: segment reversal with optimal reinsertion considering both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select segment with adaptive size\n    segment_size = max(2, min(5, int(n**0.5)))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Reverse the segment with probability to maintain diversity\n    if random.random() < 0.7:\n        segment = segment[::-1]\n\n    # Calculate insertion costs for both objectives\n    remaining = np.delete(new_solution, range(start, start+segment_size))\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        combined_cost = cost1 + cost2 + 0.1 * abs(cost1 - cost2)  # Balance between objectives\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.7686448573942685,
            3.2390204071998596
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing lower combined objectives) and applies an adaptive local search that probabilistically reorders segments to improve the stronger objective or inverts and reinserts segments to enhance the weaker objective, ensuring feasibility through validation checks. The operator dynamically adjusts its strategy based on the solution's relative performance in each objective space, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower combined objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Analyze solution's performance in each objective space\n    obj1, obj2 = archive_sorted[selected_idx][1]\n    obj_ratio = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0.5\n\n    # Adaptive local search based on objective performance\n    if random.random() < obj_ratio:\n        # Focus on improving the stronger objective (obj1)\n        segment_length = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Reorder nodes in segment to improve obj1\n        segment_costs = [distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment))]\n        sorted_indices = sorted(range(len(segment)), key=lambda i: segment_costs[i])\n        new_segment = segment[sorted_indices]\n\n        # Replace original segment with reordered one\n        new_solution[start:start+segment_length] = new_segment\n    else:\n        # Focus on improving the weaker objective (obj2)\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Invert segment and find best insertion point for obj2\n        inverted_segment = segment[::-1]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    # Ensure solution is valid\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.7468920046331512,
            4.526884973049164
        ]
    }
]