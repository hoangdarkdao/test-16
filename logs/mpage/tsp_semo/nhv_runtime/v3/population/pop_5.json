[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge assembly with partial 3-opt\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge assembly: reconnect edges to form a new tour segment\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse another segment\n\n    # Partial 3-opt: attempt to improve the tour by reconnecting three edges\n    if np.random.rand() < 0.5:\n        # Randomly select three nodes and attempt to reconnect them\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Ensure feasibility: verify no duplicates and all nodes are included\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8337802753264643,
               0.16590946912765503
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in non_dominated])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1.0 / (normalized_obj + 1e-10)\n    probs = weights.sum(axis=1) / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search - edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to remove and reinsert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n - 1, 5))  # Segment length between 2 and 4\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find a new position to insert the segment\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    if insert_pos == 0:\n        new_solution = np.concatenate([segment, remaining])\n    elif insert_pos == len(remaining):\n        new_solution = np.concatenate([remaining, segment])\n    else:\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly relocate a node\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9880560877894095,
               0.30501770973205566
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a base solution from the archive by evaluating the potential improvement areas in both objective spaces, then applying a novel segment inversion and dynamic edge reconnection strategy that adaptively selects and inverts segments of varying lengths based on their relative performance in each objective space, while simultaneously reconnecting edges in a way that maintains tour validity and potentially reduces costs in either or both objectives. The algorithm uses a probabilistic segment selection mechanism that favors longer segments when they show promise in one objective but not the other, and incorporates a dynamic edge reconnection phase that prioritizes edges with high cost savings in either space, ensuring the solution remains feasible while exploring diverse regions of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on potential improvement areas\n    base_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion based on objective performance\n    segment_length = np.random.randint(2, min(7, n//2))\n    start = np.random.randint(0, n - segment_length)\n\n    # Calculate segment costs in both objectives\n    segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n\n    # Invert segment if it shows potential for improvement in either objective\n    if np.random.rand() < 0.7 or segment_cost1 > np.median(distance_matrix_1) or segment_cost2 > np.median(distance_matrix_2):\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Dynamic edge reconnection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Reconnect edges with potential savings\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n             (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.8886579445842926,
               0.24850594997406006
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective-aware path reconstruction strategy\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Phase 1: Identify critical nodes in each objective space\n    critical_nodes1 = np.argsort(np.sum(distance_matrix_1, axis=1))[:len(solutions)//2]\n    critical_nodes2 = np.argsort(np.sum(distance_matrix_2, axis=1))[:len(solutions)//2]\n    critical_nodes = np.unique(np.concatenate([critical_nodes1, critical_nodes2]))\n\n    # Phase 2: Select a solution with high diversity in objectives\n    obj_ranges = objectives.max(axis=0) - objectives.min(axis=0)\n    diversity_scores = np.prod(objectives / (obj_ranges + 1e-10), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Phase 3: Construct new solution by inserting critical nodes\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    current_node = base_solution[0]\n\n    while remaining_nodes:\n        new_solution.append(current_node)\n        remaining_nodes.remove(current_node)\n\n        # Find next node with best combined objective improvement\n        candidates = list(remaining_nodes)\n        if not candidates:\n            break\n\n        # Evaluate potential next nodes\n        candidate_scores = []\n        for candidate in candidates:\n            # Calculate potential improvement in both objectives\n            cost1 = distance_matrix_1[current_node, candidate]\n            cost2 = distance_matrix_2[current_node, candidate]\n\n            # Combine with critical node preference\n            is_critical = candidate in critical_nodes\n            score = (cost1 + cost2) * (1.5 if is_critical else 1.0)\n            candidate_scores.append(score)\n\n        # Select node with best combined score\n        next_idx = np.argmin(candidate_scores)\n        current_node = candidates[next_idx]\n\n    # Ensure Hamiltonian cycle\n    new_solution.append(new_solution[0])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9911737239425997,
               0.8463422656059265
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is to select a base solution from the archive and apply a hybrid local search operator that combines multiple neighborhood structures to explore the solution space more effectively. The new algorithm will first identify the most promising solution in the archive by considering both objective values and their diversity, then apply a novel combination of edge reversal, segment insertion, and node swapping that dynamically adapts to the local topology of the solution, while ensuring feasibility through careful permutation maintenance and using a probabilistic acceptance criterion to balance exploration and exploitation of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_obj = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: Dynamic edge reversal based on both objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate cost change in both objectives\n    cost_change1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[new_solution[i-1], segment[0]]) - \\\n                   (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[-1], new_solution[j+1] if j+1 < n else new_solution[0]])\n    cost_change2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[new_solution[i-1], segment[0]]) - \\\n                   (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[-1], new_solution[j+1] if j+1 < n else new_solution[0]])\n\n    if np.random.rand() < 0.7 or (cost_change1 < 0 and cost_change2 < 0):\n        new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Adaptive node swapping based on objective improvement\n    a, b = np.random.choice(n, 2, replace=False)\n    node_a, node_b = new_solution[a], new_solution[b]\n\n    # Calculate potential cost change\n    cost_change1 = (distance_matrix_1[new_solution[a-1], node_b] + distance_matrix_1[node_b, new_solution[(a+1)%n]] +\n                   distance_matrix_1[new_solution[b-1], node_a] + distance_matrix_1[node_a, new_solution[(b+1)%n]]) - \\\n                  (distance_matrix_1[new_solution[a-1], node_a] + distance_matrix_1[node_a, new_solution[(a+1)%n]] +\n                   distance_matrix_1[new_solution[b-1], node_b] + distance_matrix_1[node_b, new_solution[(b+1)%n]])\n\n    cost_change2 = (distance_matrix_2[new_solution[a-1], node_b] + distance_matrix_2[node_b, new_solution[(a+1)%n]] +\n                   distance_matrix_2[new_solution[b-1], node_a] + distance_matrix_2[node_a, new_solution[(b+1)%n]]) - \\\n                  (distance_matrix_2[new_solution[a-1], node_a] + distance_matrix_2[node_a, new_solution[(a+1)%n]] +\n                   distance_matrix_2[new_solution[b-1], node_b] + distance_matrix_2[node_b, new_solution[(b+1)%n]])\n\n    if np.random.rand() < 0.5 or (cost_change1 < 0 and cost_change2 < 0):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.9052131790120768,
               0.2818329930305481
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the hybrid approach seen in both provided solutions by combining a novel segment inversion strategy with a bi-objective-aware edge reconnection mechanism. It first selects a solution from the archive based on a weighted combination of its objectives, then applies a segment inversion that reverses a randomly selected segment while considering both distance matrices to maintain balance between objectives. Following this, it performs a targeted edge reconnection by swapping edges that show potential for improvement in both objective spaces, ensuring feasibility through careful validation. The method also incorporates a probabilistic element to occasionally perform a complete segment relocation when the current solution shows limited improvement, promoting exploration while preserving the tour's validity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/(obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Bi-objective segment inversion\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(6, n-1))\n    segment_end = (segment_start + segment_length) % n\n\n    if segment_start < segment_end:\n        new_solution[segment_start:segment_end] = base_solution[segment_start:segment_end][::-1]\n    else:\n        new_solution[:segment_end] = base_solution[:segment_end][::-1]\n        new_solution[segment_start:] = base_solution[segment_start:][::-1]\n\n    # Bi-objective edge reconnection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 + delta2 < 0:  # If improvement in both objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic segment relocation\n    if np.random.rand() < 0.3 and len(archive) > 1:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8571488457382084,
               0.2382320761680603
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a promising base solution from the archive by prioritizing those with objectives that are neither dominated nor excessively similar to others, ensuring diversity. Then, it applies a hybrid local search operator that combines a novel edge-swapping mechanism with a variable-length segment relocation strategy. The edge-swapping mechanism identifies critical edges in both objective spaces, swapping them while preserving tour validity, while the segment relocation strategy dynamically adjusts the length of relocated segments based on the local topology of the solution, favoring segments that yield significant cost reductions in either objective. The algorithm ensures feasibility by maintaining permutation validity throughout all operations and uses a probabilistic acceptance criterion to balance exploration and exploitation, favoring neighbors that improve Pareto dominance or show potential for further improvement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping mechanism\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Variable-length segment relocation\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure solution remains valid (permutation of all nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.8379564264344043,
               0.2384818196296692
          ]
     },
     {
          "algorithm": "{This new algorithm first identifies the solution with the highest combined objective value in the archive as the base solution, then applies a novel \"multi-objective segment inversion and insertion\" strategy. It randomly selects a segment of nodes from the base solution, inverts their order within the segment, and strategically reinserts this inverted segment into a different position in the tour. The reinsertion position is chosen based on a weighted combination of the distance matrices from both objectives to ensure balance between the two spaces. The algorithm also includes an optional \"node exchange\" step where nodes are swapped between the inverted segment and the remaining tour if it improves the combined objective. The solution is validated to ensure it remains a valid TSP tour, and the neighbor solution is returned with the improved segment structure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_objectives = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Randomly select a segment to invert and reinsert\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(n, 6))  # Segment length between 2 and 5\n    segment_end = (segment_start + segment_length) % n\n\n    if segment_start < segment_end:\n        segment = new_solution[segment_start:segment_end]\n        remaining = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end]])\n        remaining = new_solution[segment_end:segment_start]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Step 3: Find the best insertion position for the inverted segment\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(remaining) + 1):\n        if pos == 0:\n            candidate = np.concatenate([inverted_segment, remaining])\n        elif pos == len(remaining):\n            candidate = np.concatenate([remaining, inverted_segment])\n        else:\n            candidate = np.concatenate([remaining[:pos], inverted_segment, remaining[pos:]])\n\n        # Calculate the cost of the candidate solution\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the inverted segment at the best position\n    if best_pos == 0:\n        new_solution = np.concatenate([inverted_segment, remaining])\n    elif best_pos == len(remaining):\n        new_solution = np.concatenate([remaining, inverted_segment])\n    else:\n        new_solution = np.concatenate([remaining[:best_pos], inverted_segment, remaining[best_pos:]])\n\n    # Step 4: Optional node exchange between inverted segment and remaining tour\n    if np.random.rand() < 0.3:  # 30% chance to perform exchange\n        segment_nodes = set(inverted_segment)\n        remaining_nodes = [node for node in new_solution if node not in segment_nodes]\n\n        if len(remaining_nodes) > 0:\n            # Select a random node from the inverted segment and a random node from the remaining tour\n            seg_node_idx = np.random.randint(0, len(inverted_segment))\n            rem_node_idx = np.random.randint(0, len(remaining_nodes))\n\n            # Swap the nodes\n            seg_node = inverted_segment[seg_node_idx]\n            rem_node = remaining_nodes[rem_node_idx]\n\n            # Find and replace the nodes in the new solution\n            seg_pos = np.where(new_solution == seg_node)[0][0]\n            rem_pos = np.where(new_solution == rem_node)[0][0]\n            new_solution[seg_pos], new_solution[rem_pos] = new_solution[rem_pos], new_solution[seg_pos]\n\n    # Step 5: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9446570864424071,
               0.6622089743614197
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify edges with high cost in either objective space\n    high_cost_edges = []\n    for i in range(n):\n        u, v = selected_solution[i], selected_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_edges.append((i, (i+1)%n))\n\n    if high_cost_edges:\n        # Randomly select a high-cost edge to modify\n        edge_start, edge_end = random.choice(high_cost_edges)\n        # Apply 3-opt: reconnect three edges to form a new cycle\n        i, j, k = edge_start, (edge_start + 1) % n, (edge_start + 2) % n\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n    return new_solution\n\n",
          "score": [
               -0.9228213845482578,
               0.32953977584838867
          ]
     }
]