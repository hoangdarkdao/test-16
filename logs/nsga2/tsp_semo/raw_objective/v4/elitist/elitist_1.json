[
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt move with a probabilistic edge insertion heuristic, guided by a weighted Pareto dominance criterion to balance improvements in both objectives while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply dynamic 3-opt with probabilistic edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create candidate solutions for 3-opt\n    candidates = []\n    # 3-opt move 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j] = candidate1[i:j][::-1]\n    candidates.append(candidate1)\n\n    # 3-opt move 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k] = candidate2[j:k][::-1]\n    candidates.append(candidate2)\n\n    # 3-opt move 3: Reverse entire segment between i and k\n    candidate3 = new_solution.copy()\n    candidate3[i:k] = candidate3[i:k][::-1]\n    candidates.append(candidate3)\n\n    # Evaluate candidates based on weighted improvement in both objectives\n    best_candidate = new_solution.copy()\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Weighted score (simple sum for this example)\n        score = total_dist1 + total_dist2\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    # Probabilistic edge insertion for further improvement\n    if random.random() < 0.3:  # 30% chance to apply edge insertion\n        # Select two random edges to potentially insert\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Create candidate by inserting edge (a,b) before another edge\n        candidate_insert = best_candidate.copy()\n        candidate_insert = np.concatenate([candidate_insert[:a], [candidate_insert[b]], candidate_insert[a:b], candidate_insert[b+1:]])\n\n        # Validate the candidate is still a valid tour\n        if len(np.unique(candidate_insert)) == n:\n            best_candidate = candidate_insert\n\n    return best_candidate\n\n",
        "score": [
            6.561414430282145,
            6.004608720725639
        ]
    },
    {
        "algorithm": "{The heuristic function selects a promising solution from the archive based on a novel hybrid local search strategy that combines adaptive 3-opt with a multi-objective edge-swap operator, ensuring feasibility and exploring diverse regions of the search space to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: adaptive 3-opt with multi-objective edge-swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Apply multi-objective edge-swap: swap edges if it improves both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        if a == b or abs(a - b) == 1:\n            continue\n\n        # Current and candidate edges\n        current_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n        candidate_edges = [(new_solution[a-1], new_solution[b]), (new_solution[a], new_solution[b-1])]\n\n        # Calculate cost difference in both objectives\n        delta_cost1 = (distance_matrix_1[current_edges[0][0], current_edges[0][1]] + distance_matrix_1[current_edges[1][0], current_edges[1][1]] -\n                       distance_matrix_1[candidate_edges[0][0], candidate_edges[0][1]] - distance_matrix_1[candidate_edges[1][0], candidate_edges[1][1]])\n        delta_cost2 = (distance_matrix_2[current_edges[0][0], current_edges[0][1]] + distance_matrix_2[current_edges[1][0], current_edges[1][1]] -\n                       distance_matrix_2[candidate_edges[0][0], candidate_edges[0][1]] - distance_matrix_2[candidate_edges[1][0], candidate_edges[1][1]])\n\n        # Apply swap if both objectives improve\n        if delta_cost1 < 0 and delta_cost2 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.478148322284692,
            8.371851479562594
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt move with a probabilistic edge insertion heuristic, guided by a weighted Pareto dominance criterion to balance improvements in both objectives while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply dynamic 3-opt with probabilistic edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create candidate solutions for 3-opt\n    candidates = []\n    # 3-opt move 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j] = candidate1[i:j][::-1]\n    candidates.append(candidate1)\n\n    # 3-opt move 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k] = candidate2[j:k][::-1]\n    candidates.append(candidate2)\n\n    # 3-opt move 3: Reverse entire segment between i and k\n    candidate3 = new_solution.copy()\n    candidate3[i:k] = candidate3[i:k][::-1]\n    candidates.append(candidate3)\n\n    # Evaluate candidates based on weighted improvement in both objectives\n    best_candidate = new_solution.copy()\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Weighted score (simple sum for this example)\n        score = total_dist1 + total_dist2\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    # Probabilistic edge insertion for further improvement\n    if random.random() < 0.3:  # 30% chance to apply edge insertion\n        # Select two random edges to potentially insert\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Create candidate by inserting edge (a,b) before another edge\n        candidate_insert = best_candidate.copy()\n        candidate_insert = np.concatenate([candidate_insert[:a], [candidate_insert[b]], candidate_insert[a:b], candidate_insert[b+1:]])\n\n        # Validate the candidate is still a valid tour\n        if len(np.unique(candidate_insert)) == n:\n            best_candidate = candidate_insert\n\n    return best_candidate\n\n",
        "score": [
            6.561414430282145,
            6.004608720725639
        ]
    }
]