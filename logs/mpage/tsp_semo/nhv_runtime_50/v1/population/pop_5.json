[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Step 2: Select a solution probabilistically based on non-domination rank and crowding distance\n    selected = random.choices(non_dominated, k=1)[0][0].copy()\n\n    # Step 3: Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Variable-length segment relocation\n    if n > 3:\n        seg_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Biased 3-opt move\n    if n > 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n\n        # Try all possible 3-opt configurations\n        options = [\n            (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n        ]\n\n        best_option = None\n        best_improvement = 0\n\n        for opt in options:\n            temp_sol = np.concatenate([new_solution[:i], opt[0], opt[1], opt[2]])\n            new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_option = opt\n\n        if best_option is not None:\n            new_solution = np.concatenate([new_solution[:i], best_option[0], best_option[1], best_option[2]])\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism: reorder nodes to form a valid tour\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9209101573486693,
               0.6316920518875122
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with the lowest combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + multi-objective edge exchange\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Segment inversion\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Multi-objective edge exchange\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.7895915616322705,
               0.45019596815109253
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by intelligently selecting a promising solution from the archive using a combined fitness criterion that balances the normalized objectives and the solution's current Pareto dominance status. It then applies a novel hybrid local search strategy: a two-phase approach where first a variable-length segment inversion is performed, followed by a guided edge exchange that prioritizes edges with high improvement potential in both objectives. The segment inversion length is dynamically determined based on the solution's current objective values, while the edge exchange phase uses a Pareto-dominance-aware selection mechanism to choose the most beneficial edge swaps. The function ensures feasibility by strictly maintaining a valid TSP tour throughout all operations, and includes a diversification mechanism that occasionally performs a random segment inversion when no improving moves are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (could be improved with more sophisticated selection)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Variable-length segment inversion\n    segment_length = max(2, min(n // 4, int(np.random.normal(loc=n//3, scale=n//6))))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Guided edge exchange\n    for _ in range(10):  # Limit the number of attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        # Calculate cost change for both objectives\n        cost_change_1 = sum(distance_matrix_1[e1] - distance_matrix_1[e2] for e1, e2 in zip(new_edges, current_edges))\n        cost_change_2 = sum(distance_matrix_2[e1] - distance_matrix_2[e2] for e1, e2 in zip(new_edges, current_edges))\n\n        # Accept if non-worsening in both objectives\n        if cost_change_1 <= 0 and cost_change_2 <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the solution is valid (this is redundant but safe)\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8690813752066894,
               0.609645664691925
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.7458745936860245,
               0.4126279354095459
          ]
     },
     {
          "algorithm": "{The new algorithm first selects the solution with the highest combined objective improvement potential, then applies a novel adaptive cluster-based perturbation operator that dynamically groups nodes based on their relative importance in each objective space, followed by a guided multi-segment insertion heuristic that intelligently reinserts segments of the tour while maintaining feasibility, and finally incorporates a probabilistic edge swapping mechanism that selectively exchanges edges between clusters while considering the trade-off between the two objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive cluster-based perturbation operator\n    if n > 3:\n        # Calculate node importance based on both objectives\n        node_importance = np.zeros(n)\n        for i in range(n):\n            node = base_solution[i]\n            prev_node = base_solution[i-1]\n            next_node = base_solution[(i+1)%n]\n\n            # Importance is inversely proportional to the sum of edge costs\n            node_importance[i] = 1.0 / (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] + 1e-10)\n\n        # Cluster nodes based on importance\n        sorted_indices = np.argsort(node_importance)[::-1]\n        cluster_size = max(2, min(5, n // 3))\n        clusters = [sorted_indices[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n        # Randomly select a cluster to perturb\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        # Perturb the cluster by reversing it\n        new_solution[cluster] = new_solution[cluster][::-1]\n\n    # Step 3: Guided multi-segment insertion heuristic\n    if n > 3:\n        # Select two random segments\n        seg1_start = random.randint(0, n-2)\n        seg1_end = random.randint(seg1_start+1, n-1)\n        seg1 = new_solution[seg1_start:seg1_end]\n\n        seg2_start = random.randint(0, n-2)\n        seg2_end = random.randint(seg2_start+1, n-1)\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        # Calculate potential improvements\n        current_cost1 = (distance_matrix_1[new_solution[seg1_start-1], new_solution[seg1_start]] +\n                         distance_matrix_1[new_solution[seg1_end-1], new_solution[seg1_end]] +\n                         distance_matrix_1[new_solution[seg2_start-1], new_solution[seg2_start]] +\n                         distance_matrix_1[new_solution[seg2_end-1], new_solution[seg2_end]])\n\n        current_cost2 = (distance_matrix_2[new_solution[seg1_start-1], new_solution[seg1_start]] +\n                         distance_matrix_2[new_solution[seg1_end-1], new_solution[seg1_end]] +\n                         distance_matrix_2[new_solution[seg2_start-1], new_solution[seg2_start]] +\n                         distance_matrix_2[new_solution[seg2_end-1], new_solution[seg2_end]])\n\n        # Try inserting segments in new positions\n        temp_sol = new_solution.copy()\n        temp_sol = np.concatenate([temp_sol[:seg1_start], temp_sol[seg1_end:]])\n        temp_sol = np.insert(temp_sol, random.randint(0, len(temp_sol)), seg1)\n\n        temp_sol = np.concatenate([temp_sol[:seg2_start], temp_sol[seg2_end:]])\n        temp_sol = np.insert(temp_sol, random.randint(0, len(temp_sol)), seg2)\n\n        new_cost1 = (distance_matrix_1[temp_sol[seg1_start-1], temp_sol[seg1_start]] +\n                     distance_matrix_1[temp_sol[seg1_end-1], temp_sol[seg1_end]] +\n                     distance_matrix_1[temp_sol[seg2_start-1], temp_sol[seg2_start]] +\n                     distance_matrix_1[temp_sol[seg2_end-1], temp_sol[seg2_end]])\n\n        new_cost2 = (distance_matrix_2[temp_sol[seg1_start-1], temp_sol[seg1_start]] +\n                     distance_matrix_2[temp_sol[seg1_end-1], temp_sol[seg1_end]] +\n                     distance_matrix_2[temp_sol[seg2_start-1], temp_sol[seg2_start]] +\n                     distance_matrix_2[temp_sol[seg2_end-1], temp_sol[seg2_end]])\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic edge swapping mechanism\n    if n > 3:\n        # Select two random edges from different clusters\n        cluster1 = clusters[random.randint(0, len(clusters)-1)]\n        cluster2 = clusters[random.randint(0, len(clusters)-1)]\n        if len(cluster1) > 1 and len(cluster2) > 1:\n            i1 = random.choice(cluster1)\n            j1 = random.choice(cluster1)\n            while j1 == i1:\n                j1 = random.choice(cluster1)\n\n            i2 = random.choice(cluster2)\n            j2 = random.choice(cluster2)\n            while j2 == i2:\n                j2 = random.choice(cluster2)\n\n            # Calculate potential improvements\n            current_cost1 = (distance_matrix_1[new_solution[i1-1], new_solution[i1]] +\n                            distance_matrix_1[new_solution[j1-1], new_solution[j1]] +\n                            distance_matrix_1[new_solution[i2-1], new_solution[i2]] +\n                            distance_matrix_1[new_solution[j2-1], new_solution[j2]])\n\n            current_cost2 = (distance_matrix_2[new_solution[i1-1], new_solution[i1]] +\n                            distance_matrix_2[new_solution[j1-1], new_solution[j1]] +\n                            distance_matrix_2[new_solution[i2-1], new_solution[i2]] +\n                            distance_matrix_2[new_solution[j2-1], new_solution[j2]])\n\n            # Try swapping edges between clusters\n            temp_sol = new_solution.copy()\n            temp_sol[i1], temp_sol[j2] = temp_sol[j2], temp_sol[i1]\n\n            new_cost1 = (distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] +\n                        distance_matrix_1[temp_sol[j1-1], temp_sol[j1]] +\n                        distance_matrix_1[temp_sol[i2-1], temp_sol[i2]] +\n                        distance_matrix_1[temp_sol[j2-1], temp_sol[j2]])\n\n            new_cost2 = (distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] +\n                        distance_matrix_2[temp_sol[j1-1], temp_sol[j1]] +\n                        distance_matrix_2[temp_sol[i2-1], temp_sol[i2]] +\n                        distance_matrix_2[temp_sol[j2-1], temp_sol[j2]])\n\n            # Accept with probability based on improvement\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (random.random() < 0.3 and (new_cost1 < current_cost1 * 1.1 or new_cost2 < current_cost2 * 1.1)):\n                new_solution = temp_sol\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: reinsert missing nodes at random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.8164173000167771,
               0.5985003709793091
          ]
     },
     {
          "algorithm": "{This new algorithm will select a solution from the archive based on a hybrid selection criterion that combines objective values and solution diversity, then apply a novel \"objective-aware segment rotation\" operator that rotates a randomly selected segment of the tour by a variable number of positions, with acceptance based on Pareto dominance or significant improvement in one objective while allowing controlled worsening in the other, ensuring feasibility by maintaining node uniqueness and completeness throughout the operation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Hybrid selection: balance between objective values and solution diversity\n    archive.sort(key=lambda x: -(x[1][0] * 0.6 + x[1][1] * 0.4 + random.random() * 0.1))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment rotation\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(1, j - i) if j - i > 1 else 1\n\n        # Calculate cost before rotation\n        cost1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n        cost2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n        # Rotate the segment\n        temp_sol = new_solution.copy()\n        segment = temp_sol[i:j+1]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        temp_sol[i:j+1] = rotated\n\n        # Calculate cost after rotation\n        cost1_after = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(i, j+1))\n        cost2_after = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(i, j+1))\n\n        # Accept if Pareto dominates or significant improvement in one objective with controlled worsening in the other\n        if (cost1_after < cost1_before and cost2_after <= cost2_before) or \\\n           (cost1_after <= cost1_before and cost2_after < cost2_before) or \\\n           (cost1_after < 0.9 * cost1_before and cost2_after < 1.1 * cost2_before) or \\\n           (cost2_after < 0.9 * cost2_before and cost1_after < 1.1 * cost1_before):\n            new_solution = temp_sol\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9910556685809437,
               0.7008278965950012
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.5971599357255759,
               0.4110575318336487
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive based on a novel multi-objective dominance metric that balances improvement potential in both objectives, then applies a hybrid local search operator that combines a dynamic path decomposition approach with a guided multi-segment relocation strategy, which intelligently reallocates segments of the tour between critical path components while maintaining feasibility, and finally incorporates an adaptive edge insertion mechanism that selectively inserts new edges between high-potential nodes while considering the trade-off between the two objectives through a probabilistic acceptance criterion.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution using a dominance-based metric\n    def dominance_metric(obj):\n        return -np.sqrt(obj[0]**2 + obj[1]**2)  # Negative for minimization\n\n    archive.sort(key=lambda x: dominance_metric(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic path decomposition and segment relocation\n    if n > 3:\n        # Identify critical path components\n        critical_nodes = set()\n        for i in range(n):\n            node = base_solution[i]\n            prev_node = base_solution[i-1]\n            next_node = base_solution[(i+1)%n]\n\n            # Identify nodes that are critical in either objective\n            if (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] > np.mean(distance_matrix_1) or\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] > np.mean(distance_matrix_2)):\n                critical_nodes.add(node)\n\n        # Decompose the path into segments\n        segments = []\n        current_segment = [base_solution[0]]\n        for i in range(1, n):\n            if base_solution[i] in critical_nodes and len(current_segment) > 1:\n                segments.append(current_segment)\n                current_segment = [base_solution[i]]\n            else:\n                current_segment.append(base_solution[i])\n        segments.append(current_segment)\n\n        # Relocate segments between critical components\n        if len(segments) > 1:\n            seg_idx = random.randint(0, len(segments)-1)\n            segment = segments.pop(seg_idx)\n            insert_pos = random.randint(0, len(segments)-1)\n            segments.insert(insert_pos, segment)\n\n            # Reconstruct the solution\n            new_solution = np.concatenate(segments)\n\n    # Step 3: Adaptive edge insertion mechanism\n    if n > 3:\n        # Identify high-potential insertion points\n        insertion_points = []\n        for i in range(n):\n            node = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Potential insertion points are between non-critical nodes\n            if node not in critical_nodes and next_node not in critical_nodes:\n                insertion_points.append((i, (i+1)%n))\n\n        if insertion_points:\n            # Select a random insertion point\n            i, j = random.choice(insertion_points)\n\n            # Find a high-potential node to insert\n            candidate_nodes = list(set(range(n)) - set(new_solution))\n            if candidate_nodes:\n                new_node = random.choice(candidate_nodes)\n\n                # Calculate potential improvement\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n                new_cost1 = (distance_matrix_1[new_solution[i], new_node] +\n                             distance_matrix_1[new_node, new_solution[j]])\n                new_cost2 = (distance_matrix_2[new_solution[i], new_node] +\n                             distance_matrix_2[new_node, new_solution[j]])\n\n                # Accept with probability based on improvement\n                improvement1 = current_cost1 - new_cost1\n                improvement2 = current_cost2 - new_cost2\n\n                if (improvement1 > 0 and improvement2 > 0) or \\\n                   (random.random() < 0.5 and (improvement1 > 0 or improvement2 > 0)):\n                    new_solution = np.insert(new_solution, j, new_node)\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: reinsert missing nodes at random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
          "score": [
               -1.0196944403878097,
               0.9443355202674866
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.6561629267549149,
               0.41754186153411865
          ]
     },
     {
          "algorithm": "{This new algorithm first identifies the most diverse solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution based on both objectives\n    best_idx = 0\n    best_diversity = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        diversity = obj[0] * obj[1]  # Product of objectives to find diverse solutions\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover with objective-aware segment selection\n    if n > 3:\n        # Calculate objective weights\n        total_cost = archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10\n        weight1 = archive[best_idx][1][0] / total_cost\n        weight2 = archive[best_idx][1][1] / total_cost\n\n        # Determine segment lengths based on objective weights\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments with different strategies\n        if random.random() < 0.7:  # 70% chance for balanced approach\n            start1 = random.randint(0, n - seg_length1)\n            start2 = random.randint(0, n - seg_length2)\n            # Swap segments\n            new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n                new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n        else:  # 30% chance for aggressive approach\n            # Select segments based on high-cost edges\n            def get_high_cost_segment(sol, matrix):\n                max_cost = -1\n                best_start = 0\n                for i in range(n - seg_length1):\n                    segment_cost = sum(matrix[sol[i+j-1], sol[i+j]] for j in range(seg_length1))\n                    if segment_cost > max_cost:\n                        max_cost = segment_cost\n                        best_start = i\n                return best_start\n\n            start1 = get_high_cost_segment(new_solution, distance_matrix_1)\n            start2 = get_high_cost_segment(new_solution, distance_matrix_2)\n            # Swap segments\n            new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n                new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap with objective-aware acceptance\n    if n > 3:\n        # Select edges based on both objectives\n        def select_critical_edge(sol, matrix):\n            max_diff = -1\n            best_i, best_j = 0, 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    diff = matrix[sol[i-1], sol[i]] + matrix[sol[j-1], sol[j]] - \\\n                          (matrix[sol[i-1], sol[j]] + matrix[sol[j-1], sol[i]])\n                    if diff > max_diff:\n                        max_diff = diff\n                        best_i, best_j = i, j\n            return best_i, best_j\n\n        i1, j1 = select_critical_edge(new_solution, distance_matrix_1)\n        i2, j2 = select_critical_edge(new_solution, distance_matrix_2)\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        # Calculate cost improvements\n        cost1_before = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        cost2_before = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n        cost1_after = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        cost2_after = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly with controlled degradation\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (cost1_after < cost1_before * 0.95 and cost2_after < cost1_before * 1.05) or \\\n           (cost2_after < cost2_before * 0.95 and cost1_after < cost2_before * 1.05):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair with objective-aware insertion\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.9307861622212523,
               4.820932924747467
          ]
     }
]