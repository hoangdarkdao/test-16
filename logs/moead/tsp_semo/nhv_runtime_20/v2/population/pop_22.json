[
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ]
    },
    {
        "algorithm": "{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0228806646253488,
            0.3678058981895447
        ]
    }
]