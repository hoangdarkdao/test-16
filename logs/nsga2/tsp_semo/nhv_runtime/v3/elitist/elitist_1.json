[
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8142085941284019,
            0.571387529373169
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9448300072074868,
            1.8027246594429016
        ]
    },
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8142085941284019,
            0.571387529373169
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9448300072074868,
            1.8027246594429016
        ]
    }
]