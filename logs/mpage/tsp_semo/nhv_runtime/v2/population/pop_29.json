[
     {
          "algorithm": "{The new heuristic function 'select_neighbor' employs a novel adaptive path decomposition and multi-objective guided crossover strategy to generate high-quality neighbors. It first decomposes the base solution into multiple non-overlapping segments based on the variance of edge costs across both objective spaces, then selectively recombines these segments using a guided crossover operator that prioritizes edges with complementary cost reductions in both objectives. The algorithm dynamically adjusts the segment size and crossover points based on the local Pareto front of edge improvements, ensuring feasibility through a segment validation and repair mechanism that maintains tour continuity and node uniqueness. To further enhance exploration, it incorporates a probabilistic edge flipping mechanism that flips segments with high objective cost variance, while preserving the overall tour structure. The function intelligently balances exploitation of known good segments with exploration of new segment combinations, using the distance matrices to evaluate the quality of generated neighbors and ensuring the solution remains feasible throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution in the archive\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Decompose the tour into segments based on edge cost variance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate edge costs\n        cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n        variance = abs(cost1 - cost2)\n\n        if variance > 0.3 * (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n    segments.append(current_segment)\n\n    # Guided segment crossover\n    if len(segments) > 1:\n        # Select two segments to crossover\n        seg_indices = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg_indices[0]], segments[seg_indices[1]]\n\n        # Find crossover points based on edge improvements\n        min_improvement = float('inf')\n        best_crossover = (0, 0)\n        for i in range(len(seg1)):\n            for j in range(len(seg2)):\n                # Calculate potential improvement\n                a, b = seg1[i], seg1[(i+1)%len(seg1)]\n                c, d = seg2[j], seg2[(j+1)%len(seg2)]\n                original_cost = (distance_matrix_1[a,b] + distance_matrix_1[c,d] +\n                                distance_matrix_2[a,b] + distance_matrix_2[c,d])\n                new_cost = (distance_matrix_1[a,c] + distance_matrix_1[b,d] +\n                            distance_matrix_2[a,c] + distance_matrix_2[b,d])\n                improvement = original_cost - new_cost\n                if improvement < min_improvement:\n                    min_improvement = improvement\n                    best_crossover = (i, j)\n\n        # Perform crossover\n        i, j = best_crossover\n        new_seg1 = seg1[:i+1] + seg2[j:] + seg2[:j]\n        new_seg2 = seg2[:j+1] + seg1[i:] + seg1[:i]\n        segments[seg_indices[0]] = new_seg1\n        segments[seg_indices[1]] = new_seg2\n\n    # Reconstruct the tour\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        flip_start = np.random.randint(n)\n        flip_length = min(3, n - flip_start)\n        new_solution[flip_start:flip_start+flip_length] = new_solution[flip_start:flip_start+flip_length][::-1]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.9122878710931449,
               0.1251642107963562
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle with cost-aware segment selection\n        segment_lengths = np.random.randint(2, min(5, n//2), size=np.random.randint(1, min(3, n//2)))\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths), len(segment_lengths), replace=False))\n        segments = []\n        current_pos = 0\n        for i, start in enumerate(segment_starts):\n            segments.append(new_solution[current_pos:start])\n            segments.append(new_solution[start:start+segment_lengths[i]])\n            current_pos = start + segment_lengths[i]\n        segments.append(new_solution[current_pos:])\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion with cost balancing\n        for _ in range(min(3, n//2)):\n            # Select a node to move based on its cost imbalance\n            costs = []\n            for i in range(n):\n                u = new_solution[i]\n                v = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[u, v]\n                cost2 = distance_matrix_2[u, v]\n                costs.append(abs(cost1 - cost2))\n            node_idx = np.argmax(costs)\n            node = new_solution[node_idx]\n\n            # Find insertion position that balances both costs\n            best_pos = -1\n            best_balance = float('inf')\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                balance = abs(cost1 - cost2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.03763919442391,
               0.25300854444503784
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9736372770910497,
               0.17719495296478271
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.978710112200484,
               0.17739611864089966
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Based Tour Reconstruction with Hybrid Segment Rebalancing,\" begins by selecting a solution from the archive using a hybrid selection metric that combines both objective values and structural diversity, then employs a novel tour reconstruction strategy that first identifies critical segments where the solution's objective costs are most imbalanced, followed by an adaptive segment rebalancing process where segments are strategically split, merged, or reordered based on their relative contributions to each objective, with rebalancing decisions made using a weighted combination of segment costs, objective-specific diversity, and spatial proximity in both coordinate spaces, ensuring a more balanced exploration of the solution space while maintaining tour validity through a comprehensive segment validation mechanism that checks for node uniqueness, connectivity, and objective-specific constraints at each step, and incorporates a hybrid local search phase that combines restricted 3-opt operations with a novel \"objective-aware\" edge swap mechanism to further improve the solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection metric combining objectives and diversity\n    def hybrid_metric(obj, sol):\n        norm_obj1 = obj[0] / (np.max(distance_matrix_1) * len(sol))\n        norm_obj2 = obj[1] / (np.max(distance_matrix_2) * len(sol))\n        diversity = len(np.unique(sol)) / len(sol)\n        obj_balance = 1 - abs(norm_obj1 - norm_obj2) / (norm_obj1 + norm_obj2 + 1e-6)\n        return (norm_obj1 + norm_obj2) * diversity * obj_balance\n\n    base_solution, _ = max(archive, key=lambda x: hybrid_metric(x[1], x[0]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical segments with most imbalanced costs\n    segments = []\n    current_segment = [new_solution[0]]\n    segment_costs = []\n\n    for i in range(1, n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        cost1 = distance_matrix_1[prev, curr]\n        cost2 = distance_matrix_2[prev, curr]\n\n        if i > 1:\n            prev_cost1 = distance_matrix_1[new_solution[i-2], prev]\n            prev_cost2 = distance_matrix_2[new_solution[i-2], prev]\n\n            # Split if significant cost imbalance in either objective\n            if (abs(cost1 - prev_cost1) > 0.3 * (cost1 + prev_cost1) or\n                abs(cost2 - prev_cost2) > 0.3 * (cost2 + prev_cost2)):\n                segments.append(current_segment)\n                segment_costs.append((sum(distance_matrix_1[s-1, s] for s in current_segment),\n                                     sum(distance_matrix_2[s-1, s] for s in current_segment)))\n                current_segment = [prev, curr]\n            else:\n                current_segment.append(curr)\n        else:\n            current_segment.append(curr)\n\n    if current_segment:\n        segments.append(current_segment)\n        segment_costs.append((sum(distance_matrix_1[s-1, s] for s in current_segment),\n                             sum(distance_matrix_2[s-1, s] for s in current_segment)))\n\n    # Adaptive segment rebalancing\n    if len(segments) > 1:\n        # Calculate segment characteristics\n        segment_features = []\n        for i, seg in enumerate(segments):\n            seg_cost1, seg_cost2 = segment_costs[i]\n            seg_len = len(seg)\n\n            # Calculate spatial diversity\n            coords1 = instance[seg, :2]\n            coords2 = instance[seg, 2:]\n            diversity1 = np.std(coords1[:, 0]) + np.std(coords1[:, 1])\n            diversity2 = np.std(coords2[:, 0]) + np.std(coords2[:, 1])\n\n            segment_features.append((seg_cost1, seg_cost2, seg_len, diversity1, diversity2))\n\n        # Find best rebalancing operations\n        best_operation = None\n        best_score = -float('inf')\n\n        # Consider all possible segment operations (split, merge, reorder)\n        for i in range(len(segments)):\n            # Split operation\n            if len(segments[i]) > 2:\n                split_pos = len(segments[i]) // 2\n                new_seg1 = segments[i][:split_pos]\n                new_seg2 = segments[i][split_pos:]\n\n                # Calculate new costs\n                new_cost1_1 = sum(distance_matrix_1[s-1, s] for s in new_seg1)\n                new_cost2_1 = sum(distance_matrix_2[s-1, s] for s in new_seg1)\n                new_cost1_2 = sum(distance_matrix_1[s-1, s] for s in new_seg2)\n                new_cost2_2 = sum(distance_matrix_2[s-1, s] for s in new_seg2)\n\n                # Calculate improvement score\n                old_balance = abs(segment_costs[i][0] - segment_costs[i][1]) / (segment_costs[i][0] + segment_costs[i][1] + 1e-6)\n                new_balance = (abs(new_cost1_1 - new_cost2_1) / (new_cost1_1 + new_cost2_1 + 1e-6) +\n                              abs(new_cost1_2 - new_cost2_2) / (new_cost1_2 + new_cost2_2 + 1e-6)) / 2\n                score = old_balance - new_balance\n\n                if score > best_score:\n                    best_score = score\n                    best_operation = ('split', i, split_pos)\n\n            # Merge operation with adjacent segment\n            if i < len(segments) - 1:\n                merged_seg = segments[i] + segments[i+1]\n                merged_cost1 = sum(distance_matrix_1[s-1, s] for s in merged_seg)\n                merged_cost2 = sum(distance_matrix_2[s-1, s] for s in merged_seg)\n\n                # Calculate improvement score\n                old_balance1 = abs(segment_costs[i][0] - segment_costs[i][1]) / (segment_costs[i][0] + segment_costs[i][1] + 1e-6)\n                old_balance2 = abs(segment_costs[i+1][0] - segment_costs[i+1][1]) / (segment_costs[i+1][0] + segment_costs[i+1][1] + 1e-6)\n                new_balance = abs(merged_cost1 - merged_cost2) / (merged_cost1 + merged_cost2 + 1e-6)\n                score = (old_balance1 + old_balance2) / 2 - new_balance\n\n                if score > best_score:\n                    best_score = score\n                    best_operation = ('merge', i, i+1)\n\n            # Reorder operation with adjacent segment\n            if i < len(segments) - 1:\n                reordered_seg1 = segments[i+1] + segments[i]\n                reordered_cost1 = sum(distance_matrix_1[s-1, s] for s in reordered_seg1)\n                reordered_cost2 = sum(distance_matrix_2[s-1, s] for s in reordered_seg1)\n\n                # Calculate improvement score\n                old_balance1 = abs(segment_costs[i][0] - segment_costs[i][1]) / (segment_costs[i][0] + segment_costs[i][1] + 1e-6)\n                old_balance2 = abs(segment_costs[i+1][0] - segment_costs[i+1][1]) / (segment_costs[i+1][0] + segment_costs[i+1][1] + 1e-6)\n                new_balance = abs(reordered_cost1 - reordered_cost2) / (reordered_cost1 + reordered_cost2 + 1e-6)\n                score = (old_balance1 + old_balance2) / 2 - new_balance\n\n                if score > best_score:\n                    best_score = score\n                    best_operation = ('reorder', i, i+1)\n\n        # Perform the best operation\n        if best_operation is not None:\n            op_type, i, j = best_operation\n            if op_type == 'split':\n                new_seg1 = segments[i][:j]\n                new_seg2 = segments[i][j:]\n                new_segments = segments[:i] + [new_seg1, new_seg2] + segments[i+1:]\n            elif op_type == 'merge':\n                merged_seg = segments[i] + segments[j]\n                new_segments = segments[:i] + [merged_seg] + segments[j+1:]\n            elif op_type == 'reorder':\n                reordered_seg = segments[j] + segments[i]\n                new_segments = segments[:i] + [reordered_seg] + segments[j+1:]\n\n            # Reconstruct solution from segments\n            new_solution = []\n            for seg in new_segments:\n                new_solution.extend(seg)\n            new_solution = np.array(new_solution)\n\n    # Hybrid local search phase\n    if n >= 4:\n        # Objective-aware edge swap\n        for _ in range(min(3, n // 2)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j and abs(i - j) > 1:\n                # Calculate original costs\n                orig_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                              distance_matrix_1[new_solution[j-1], new_solution[j]])\n                orig_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                              distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n                # Calculate swapped costs\n                if i < j:\n                    swapped_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                                    distance_matrix_1[new_solution[j-1], new_solution[i]])\n                    swapped_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n                else:\n                    swapped_cost1 = (distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                                    distance_matrix_1[new_solution[i-1], new_solution[j]])\n                    swapped_cost2 = (distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                                    distance_matrix_2[new_solution[i-1], new_solution[j]])\n\n                # Calculate improvement score\n                orig_balance = abs(orig_cost1 - orig_cost2) / (orig_cost1 + orig_cost2 + 1e-6)\n                swapped_balance = abs(swapped_cost1 - swapped_cost2) / (swapped_cost1 + swapped_cost2 + 1e-6)\n                improvement = orig_balance - swapped_balance\n\n                if improvement > 0:\n                    # Perform the swap\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -1.039237016035549,
               2.404217541217804
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' employs a hierarchical clustering-based tour decomposition and adaptive edge fusion strategy to generate high-quality neighbors. It first clusters the nodes into hierarchical groups based on their relative positions in both objective spaces, then selectively fuses edges between clusters using a multi-objective aware edge selection criterion that prioritizes edges with complementary cost characteristics. The algorithm dynamically adjusts the cluster hierarchy based on the local Pareto front of edge improvements, ensuring feasibility through a cluster validation and repair mechanism that maintains tour continuity and node uniqueness. To further enhance exploration, it incorporates a probabilistic cluster inversion mechanism that reverses entire clusters with high inter-cluster cost variance, while preserving the overall tour structure. The function intelligently balances exploitation of known cluster structures with exploration of new cluster configurations, using the distance matrices to evaluate the quality of generated neighbors and ensuring the solution remains feasible throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high edge diversity\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Hierarchical clustering-based decomposition\n        clusters = []\n        current_cluster = [new_solution[0]]\n        for i in range(1, n):\n            prev_node = new_solution[i-1]\n            current_node = new_solution[i]\n\n            # Calculate cost characteristics\n            cost1 = distance_matrix_1[prev_node, current_node]\n            cost2 = distance_matrix_2[prev_node, current_node]\n            ratio = cost1 / cost2 if cost2 != 0 else float('inf')\n\n            # Cluster formation criteria\n            if ratio > 1.5 or ratio < 0.66:\n                clusters.append(current_cluster)\n                current_cluster = [current_node]\n            else:\n                current_cluster.append(current_node)\n        clusters.append(current_cluster)\n\n        # Multi-objective edge fusion\n        if len(clusters) > 1:\n            # Select clusters to fuse\n            cluster_indices = np.random.choice(len(clusters), 2, replace=False)\n            cluster1, cluster2 = clusters[cluster_indices[0]], clusters[cluster_indices[1]]\n\n            # Find best fusion point based on cost balance\n            best_fusion = (0, 0)\n            best_balance = float('inf')\n            for i in range(len(cluster1)):\n                for j in range(len(cluster2)):\n                    # Calculate potential cost balance\n                    a, b = cluster1[i], cluster1[(i+1)%len(cluster1)]\n                    c, d = cluster2[j], cluster2[(j+1)%len(cluster2)]\n                    cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n                    cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n                    balance = abs(cost1 - cost2)\n                    if balance < best_balance:\n                        best_balance = balance\n                        best_fusion = (i, j)\n\n            # Perform fusion\n            i, j = best_fusion\n            new_cluster = cluster1[:i+1] + cluster2[j:] + cluster2[:j]\n            clusters[cluster_indices[0]] = new_cluster\n            clusters[cluster_indices[1]] = cluster1[i:] + cluster1[:i]\n\n        # Reconstruct the tour\n        new_solution = np.concatenate(clusters)\n\n        # Probabilistic cluster inversion\n        if np.random.rand() < 0.4:\n            cluster_idx = np.random.randint(len(clusters))\n            clusters[cluster_idx] = clusters[cluster_idx][::-1]\n            new_solution = np.concatenate(clusters)\n\n        # Validate and repair\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to original\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9396853378218559,
               0.13791805505752563
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Centric Path Evolution with Adaptive Segment Fusion,\" begins by selecting a solution from the archive using a novel objective-centric selection metric that prioritizes solutions with high structural diversity and imbalanced objective contributions, then employs a multi-phase evolution strategy that first identifies critical path segments where objective costs diverge most significantly, followed by an adaptive segment fusion process where these segments are strategically combined or reordered based on their objective-specific characteristics, with fusion decisions made using a weighted combination of segment costs, objective-specific diversity metrics, and spatial proximity in both coordinate spaces, ensuring a more balanced exploration of the solution space while maintaining tour validity through comprehensive feasibility checks at each evolutionary step, and incorporates a hybrid path evolution phase that combines restricted k-opt operations with an objective-aware segment inversion mechanism to further refine the solution quality across both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective-centric selection metric\n    def objective_metric(obj, sol):\n        norm_obj1 = obj[0] / (np.max(distance_matrix_1) * len(sol))\n        norm_obj2 = obj[1] / (np.max(distance_matrix_2) * len(sol))\n        diversity = len(np.unique(sol)) / len(sol)\n        obj_diff = abs(norm_obj1 - norm_obj2)\n        return obj_diff * diversity\n\n    base_solution, _ = max(archive, key=lambda x: objective_metric(x[1], x[0]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Identify critical segments with objective divergence\n    segments = []\n    current_segment = [new_solution[0]]\n    segment_costs = []\n\n    for i in range(1, n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        cost1 = distance_matrix_1[prev, curr]\n        cost2 = distance_matrix_2[prev, curr]\n\n        if i > 1:\n            prev_cost1 = distance_matrix_1[new_solution[i-2], prev]\n            prev_cost2 = distance_matrix_2[new_solution[i-2], prev]\n\n            # Split if significant objective divergence\n            if (abs(cost1 - prev_cost1) > 0.25 * (cost1 + prev_cost1) or\n                abs(cost2 - prev_cost2) > 0.25 * (cost2 + prev_cost2)):\n                segments.append(current_segment)\n                segment_costs.append((sum(distance_matrix_1[s-1, s] for s in current_segment),\n                                     sum(distance_matrix_2[s-1, s] for s in current_segment)))\n                current_segment = [prev, curr]\n            else:\n                current_segment.append(curr)\n        else:\n            current_segment.append(curr)\n\n    if current_segment:\n        segments.append(current_segment)\n        segment_costs.append((sum(distance_matrix_1[s-1, s] for s in current_segment),\n                             sum(distance_matrix_2[s-1, s] for s in current_segment)))\n\n    # Adaptive segment fusion\n    if len(segments) > 1:\n        # Calculate segment characteristics\n        segment_features = []\n        for i, seg in enumerate(segments):\n            seg_cost1, seg_cost2 = segment_costs[i]\n            seg_len = len(seg)\n\n            # Calculate objective divergence\n            obj_divergence = abs(seg_cost1 - seg_cost2) / (seg_cost1 + seg_cost2 + 1e-6)\n\n            # Calculate spatial characteristics\n            coords1 = instance[seg, :2]\n            coords2 = instance[seg, 2:]\n            centroid1 = np.mean(coords1, axis=0)\n            centroid2 = np.mean(coords2, axis=0)\n\n            segment_features.append((obj_divergence, seg_len, centroid1, centroid2))\n\n        # Find best fusion operations\n        best_operation = None\n        best_score = -float('inf')\n\n        # Consider all possible segment operations (fusion, inversion, reorder)\n        for i in range(len(segments)):\n            # Fusion operation with adjacent segment\n            if i < len(segments) - 1:\n                # Calculate fusion score\n                current_divergence = (segment_features[i][0] + segment_features[i+1][0]) / 2\n                fusion_divergence = abs(segment_costs[i][0] + segment_costs[i+1][0] -\n                                       segment_costs[i][1] - segment_costs[i+1][1]) / (\n                                       segment_costs[i][0] + segment_costs[i+1][0] +\n                                       segment_costs[i][1] + segment_costs[i+1][1] + 1e-6)\n                score = current_divergence - fusion_divergence\n\n                if score > best_score:\n                    best_score = score\n                    best_operation = ('fusion', i, i+1)\n\n            # Inversion operation\n            if len(segments[i]) > 2:\n                inverted_seg = segments[i][::-1]\n                inverted_cost1 = sum(distance_matrix_1[s-1, s] for s in inverted_seg)\n                inverted_cost2 = sum(distance_matrix_2[s-1, s] for s in inverted_seg)\n                inverted_divergence = abs(inverted_cost1 - inverted_cost2) / (inverted_cost1 + inverted_cost2 + 1e-6)\n\n                score = segment_features[i][0] - inverted_divergence\n\n                if score > best_score:\n                    best_score = score\n                    best_operation = ('inversion', i)\n\n        # Perform the best operation\n        if best_operation is not None:\n            op_type = best_operation[0]\n            if op_type == 'fusion':\n                i, j = best_operation[1], best_operation[2]\n                fused_seg = segments[i] + segments[j]\n                new_segments = segments[:i] + [fused_seg] + segments[j+1:]\n            elif op_type == 'inversion':\n                i = best_operation[1]\n                inverted_seg = segments[i][::-1]\n                new_segments = segments[:i] + [inverted_seg] + segments[i+1:]\n\n            # Reconstruct solution from segments\n            new_solution = []\n            for seg in new_segments:\n                new_solution.extend(seg)\n            new_solution = np.array(new_solution)\n\n    # Hybrid path evolution phase\n    if n >= 4:\n        # Objective-aware segment inversion\n        for _ in range(min(2, n // 3)):\n            i = np.random.randint(0, len(segments))\n            seg = segments[i]\n\n            if len(seg) > 2:\n                # Calculate original costs\n                orig_cost1 = sum(distance_matrix_1[s-1, s] for s in seg)\n                orig_cost2 = sum(distance_matrix_2[s-1, s] for s in seg)\n\n                # Invert the segment\n                inverted_seg = seg[::-1]\n                inverted_cost1 = sum(distance_matrix_1[s-1, s] for s in inverted_seg)\n                inverted_cost2 = sum(distance_matrix_2[s-1, s] for s in inverted_seg)\n\n                # Calculate improvement score\n                orig_divergence = abs(orig_cost1 - orig_cost2) / (orig_cost1 + orig_cost2 + 1e-6)\n                inverted_divergence = abs(inverted_cost1 - inverted_cost2) / (inverted_cost1 + inverted_cost2 + 1e-6)\n                improvement = orig_divergence - inverted_divergence\n\n                if improvement > 0:\n                    # Apply inversion to the solution\n                    seg_start = sum(len(s) for s in segments[:i])\n                    seg_end = seg_start + len(seg)\n                    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -1.022020881206335,
               1.760653555393219
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9773673423984225,
               0.18285882472991943
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify the most promising candidate for local improvement, prioritizing those with lower objective values or exhibiting characteristics of suboptimality (e.g., high edge crossings or non-dominated solutions). It then applies a novel hybrid local search strategy that combines a segment inversion operator with a biased 3-opt move, where the inversion is guided by the relative costs of edges in the two objective spaces, and the 3-opt is constrained to preserve feasibility by ensuring no nodes are skipped or revisited. The inversion operator selects two random segments of the tour and reverses their order, while the 3-opt operator identifies three non-adjacent edges and reconnects them to form a new cycle, with the selection of edges biased towards those with higher relative costs in either objective space. The function ensures feasibility by validating the generated neighbor solution before returning it, thus maintaining the integrity of the TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives as the base\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with biased 3-opt\n    if n >= 4:\n        # Segment inversion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Biased 3-opt: select edges with higher relative costs\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            edges.append((i, (i + 1) % n, max(cost1, cost2)))\n\n        # Sort edges by descending cost and select top 3\n        edges.sort(key=lambda x: -x[2])\n        selected_edges = [edge for edge in edges[:3]]\n\n        if len(selected_edges) == 3:\n            # Perform 3-opt swap\n            i1, j1, _ = selected_edges[0]\n            i2, j2, _ = selected_edges[1]\n            i3, j3, _ = selected_edges[2]\n\n            # Ensure edges are non-adjacent and can form a valid cycle\n            if not (abs(i1 - i2) == 1 or abs(i1 - i3) == 1 or abs(i2 - i3) == 1):\n                # Create a new segment by reconnecting the edges\n                segment = new_solution[i1:j1] + new_solution[i2:j2] + new_solution[i3:j3]\n                new_solution = np.concatenate([new_solution[:i1], segment[::-1], new_solution[j3:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8976962591238635,
               0.14388447999954224
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge diversity or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-node relocation with a guided edge swapping, where the relocation strategically moves nodes based on their relative costs in both objective spaces while the swapping reorders edges to balance the costs, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-node relocation with cost-aware node selection\n        num_relocations = np.random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            # Select a node to relocate based on its cost imbalance\n            costs = []\n            for i in range(n):\n                u = new_solution[i]\n                v = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[u, v]\n                cost2 = distance_matrix_2[u, v]\n                costs.append(abs(cost1 - cost2))\n            node_idx = np.argmax(costs)\n            node = new_solution[node_idx]\n\n            # Find relocation position that balances both costs\n            best_pos = -1\n            best_balance = float('inf')\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                balance = abs(cost1 - cost2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9395760865330904,
               0.14884144067764282
          ]
     }
]