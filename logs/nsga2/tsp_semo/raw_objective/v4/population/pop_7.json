[
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid approach that combines a probabilistic segment inversion with a multi-objective node insertion heuristic, where segments are randomly inverted and refined through adaptive node insertions guided by a Pareto-based selection criterion to balance improvements across both objectives while ensuring solution feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive segment length\n    if random.random() < 0.7:  # Increased chance to 70%\n        segment_length = max(2, min(5, int(n * 0.2)))  # Adaptive segment length\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node insertion with adaptive selection\n    for _ in range(3):  # Increased to 3 rounds\n        # Select a random node to remove\n        remove_idx = random.randint(1, n-1)\n        node = new_solution[remove_idx]\n        temp_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Find best insertion position for the removed node\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(1, n):\n            # Insert node at position pos\n            candidate = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Modified weight calculation based on relative improvement\n            weight = 0.5 + 0.5 * np.tanh((current_cost1 - candidate_cost1) + (current_cost2 - candidate_cost2))\n\n            # Weighted score with different balance\n            score = (1 - weight) * candidate_cost1 + weight * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.633452515673034,
            5.405026437418702
        ]
    }
]