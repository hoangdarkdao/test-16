[
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversion, probabilistic edge swapping, and dynamic objective-balanced 3-opt moves to intelligently explore the solution space while maintaining feasibility, focusing on diverse high-quality neighbors for bi-objective TSP.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, min(5, n // 5))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Probabilistic edge swapping\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Dynamic objective-balanced 3-opt\n    if random.random() < 0.5:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Choose the 3-opt move that improves both objectives\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c+1], new_solution[c+1:]]),\n            np.concatenate([new_solution[:b], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n        ]\n\n        best_option = new_solution\n        best_cost1 = np.sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        best_cost2 = np.sum([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n\n        for option in options:\n            cost1 = np.sum([distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n)])\n            cost2 = np.sum([distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n)])\n            if (cost1 + cost2) < (best_cost1 + best_cost2):\n                best_option = option.copy()\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.8602711591922098,
            0.25676828622817993
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive based on Pareto dominance and objective diversity, then applies a hybrid local search combining a novel edge-swap operator with a biased random walk to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < sol[0] and other_obj[1] <= sol[1]) or (other_obj[0] <= sol[0] and other_obj[1] < sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Hybrid of edge-swap and biased random walk\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge-swap operator\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Biased random walk: swap nodes based on objective improvement\n    for _ in range(3):  # Limit steps to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7657535075037692,
            0.3182288408279419
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment inversion, probabilistic edge swapping, and dynamic objective-balanced 3-opt moves to intelligently explore the solution space while maintaining feasibility, focusing on diverse high-quality neighbors for bi-objective TSP.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, min(5, n // 5))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Probabilistic edge swapping\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Dynamic objective-balanced 3-opt\n    if random.random() < 0.5:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Choose the 3-opt move that improves both objectives\n        options = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c+1], new_solution[c+1:]]),\n            np.concatenate([new_solution[:b], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n        ]\n\n        best_option = new_solution\n        best_cost1 = np.sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        best_cost2 = np.sum([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n\n        for option in options:\n            cost1 = np.sum([distance_matrix_1[option[i], option[(i+1)%n]] for i in range(n)])\n            cost2 = np.sum([distance_matrix_2[option[i], option[(i+1)%n]] for i in range(n)])\n            if (cost1 + cost2) < (best_cost1 + best_cost2):\n                best_option = option.copy()\n                best_cost1, best_cost2 = cost1, cost2\n\n        new_solution = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.8602711591922098,
            0.25676828622817993
        ]
    }
]