[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    normalized_objectives = [(obj[0] / (obj[0] + obj[1] + 1e-10), obj[1] / (obj[0] + obj[1] + 1e-10)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to modify\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k = np.random.randint(1, n-1)\n\n    # Novel move: reverse segment between i and j, then insert segment between k and k+1\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen due to segment insertion)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.343084386472292,
               6.398679333078661
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    scores = []\n    for sol, _ in archive:\n        # Calculate diversity score (number of unique edges not in other solutions)\n        diversity = 0\n        edges = set(zip(sol, np.roll(sol, -1)))\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges - other_edges)\n        scores.append(diversity)\n\n    if all(s == 0 for s in scores):\n        # If all solutions are identical, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Normalize scores and select with probability\n        total = sum(scores)\n        probs = [s / total for s in scores]\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for segment relocation\n        # Select segment length based on instance size\n        max_segment = min(5, n // 4)\n        segment_length = random.randint(2, max_segment)\n\n        # Select random segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position that improves both objectives\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue  # Skip current position\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and best_cost < float('inf'):\n            # Apply the best move\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n    else:  # Edge insertion\n        # Select random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select random node to insert between\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i-1)%n:\n            k = random.randint(0, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]  # Reverse the edge\n        candidate = np.roll(candidate, -i)  # Make i the first element\n        candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n        candidate = np.roll(candidate, i)  # Restore original order\n\n        # Check if the move is valid (visits all nodes exactly once)\n        if len(set(candidate)) == n:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.602584769458544,
               5.827298074802924
          ]
     },
     {
          "algorithm": "{The new algorithm begins by selecting a base solution from the archive using a multi-criteria approach that combines objective values, diversity, and structural features, then employs a novel hybrid local search strategy that integrates adaptive segment swapping with probabilistic edge reversal, followed by a constrained node reinsertion phase to ensure feasibility while exploring the solution space more effectively than standard methods, ultimately generating a high-quality neighbor solution that balances exploration and exploitation through dynamic parameter adaptation and objective-aware move selection.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective and structural diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate combined objective score (normalized)\n        obj_score = (obj1 + obj2) / (sum(x[1][0] + x[1][1] for x in archive) / len(archive))\n\n        # Calculate structural diversity\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity = 0\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges.symmetric_difference(other_edges))\n\n        # Combine scores with adaptive weights\n        alpha = 0.7 if len(archive) > 10 else 0.5\n        scores.append(alpha * obj_score + (1 - alpha) * diversity)\n\n    # Select solution with highest combined score\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Phase 1: Adaptive segment swapping\n    segment_length = max(3, min(7, n // 5))\n    for _ in range(2):\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        # Swap segments with probability based on objective improvement\n        seg1 = new_solution[start1:start1+segment_length]\n        seg2 = new_solution[start2:start2+segment_length]\n\n        # Calculate potential improvement\n        old_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        candidate = new_solution.copy()\n        candidate[start1:start1+segment_length] = seg2\n        candidate[start2:start2+segment_length] = seg1\n\n        new_cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[candidate[-1], candidate[0]] +\n                    sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[candidate[-1], candidate[0]])\n\n        if new_cost < old_cost or np.random.random() < 0.3:\n            new_solution = candidate\n\n    # Phase 2: Probabilistic edge reversal with objective awareness\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        if new_cost < old_cost or np.random.random() < 0.2:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Phase 3: Constrained node reinsertion\n    for _ in range(2):\n        # Select a random node to remove\n        idx = np.random.randint(1, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        candidate = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find best insertion position that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            if pos == idx or pos == idx-1:\n                continue\n\n            # Insert node at position pos\n            temp = np.insert(candidate, pos, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[temp[-1], temp[0]]\n\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[temp[-1], temp[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.982530730904809,
               6.4238842089255845
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a novel adaptive path decomposition and recombination strategy that dynamically partitions the tour into segments based on both objective spaces' characteristics, then reconstructs the tour by interleaving these segments in a way that maximizes the trade-off between the two objectives. The selection process prioritizes solutions that exhibit non-dominated segments in the Pareto front, while the local search operator uses a probabilistic segment recombination mechanism guided by a multi-objective utility function that considers the segment's contribution to both objectives. The function ensures feasibility by maintaining the permutation property through a series of carefully designed segment swaps and rotations, with the segment length and recombination pattern determined by an adaptive probability model that learns from the current solution's structure and the distance matrices.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using adaptive segment analysis\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive path decomposition based on both objectives\n    segment_length = np.random.randint(3, min(7, n // 2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Extract segment and analyze its contribution to both objectives\n    segment = new_solution[start_pos:start_pos + segment_length]\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n\n    # Determine segment's Pareto dominance relative to the rest of the tour\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Probabilistic recombination based on segment's characteristics\n    if segment_cost1 / total_cost1 < 0.3 or segment_cost2 / total_cost2 < 0.3:\n        # If segment is significantly worse in one objective, consider removing it\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        # Insert the segment in a different position\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        # If segment is balanced, consider rotating it\n        rotation = np.random.randint(1, segment_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start_pos:start_pos + segment_length] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to restore feasibility\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.4586950415254565,
               5.903120343468656
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone idea of selecting a promising solution from the archive and applying a hybrid local search strategy, but it introduces a novel approach by combining adaptive segment relocation with a guided path inversion mechanism. The algorithm first evaluates solutions based on their objective diversity and local search potential, then selects a base solution with high potential for improvement. The selected solution undergoes a multi-stage local search process: first, it adaptively identifies and relocates promising segments of varying lengths based on their contribution to reducing both objectives, while dynamically adjusting segment lengths based on the solution's structure and the distance matrices. Next, it applies a guided path inversion where paths between critical nodes are inverted based on their weighted contribution to both objectives, with inversion length determined by a probabilistic model that considers the current solution's structure and the distance matrices. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    num_segments = np.random.randint(1, min(3, n // 3))\n    segment_lengths = []\n\n    for _ in range(num_segments):\n        # Determine segment length based on local structure\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate edge weights in both objectives\n        w1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[k]]\n        w2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[k]]\n\n        # Use weighted combination to determine segment length\n        length = max(2, min(5, int(3 * (w1 + w2) / (distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[i], base_solution[k]]))))\n        segment_lengths.append(length)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    # Relocate segments\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        # Find best insertion position\n        best_pos = current_pos\n        best_cost = float('inf')\n\n        for pos in range(n - length + 1):\n            if pos >= current_pos and pos < current_pos + length:\n                continue\n\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:current_pos],\n                new_solution[current_pos + length:]\n            ])\n\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != current_pos:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:current_pos],\n                new_solution[current_pos + length:]\n            ])\n\n        current_pos += length\n\n    # Guided path inversion\n    for _ in range(min(2, n // 3)):\n        # Select critical nodes based on both objectives\n        critical_nodes = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n                critical_nodes.append(i)\n\n        if len(critical_nodes) >= 2:\n            i, j = np.random.choice(critical_nodes, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate inversion length based on node distances\n            inversion_length = max(2, min(5, int(3 * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                                   distance_matrix_2[new_solution[i], new_solution[j]]) /\n                                                   (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))))\n\n            # Perform inversion\n            if j - i + 1 <= inversion_length:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                mid = i + inversion_length // 2\n                new_solution[i:mid] = new_solution[i:mid][::-1]\n                new_solution[mid:j+1] = new_solution[mid:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               6.455092419352846,
               6.242420963522866
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first evaluates the archive of solutions by computing their Pareto dominance relationships, then selects a promising solution with high potential for improvement using a custom selection criterion that balances objective diversity and local search potential. The selected solution undergoes a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge exchange mechanism, where segments of varying lengths are inverted and edges are exchanged based on their contribution to reducing the total tour length in both objective spaces. The inversion length is dynamically determined using a probabilistic model that considers both the distance matrices and the current solution's structure, while the edge exchange is guided by a weighted combination of the two objectives. The function ensures feasibility by maintaining the permutation property of TSP tours throughout the local search process, and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n // 2))\n    segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        new_solution[current_pos:current_pos + length] = segment[::-1]\n        current_pos += length\n\n    # Guided edge exchange\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Weighted decision based on both objectives\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               6.372959628179613,
               6.543599011883715
          ]
     },
     {
          "algorithm": "{The new algorithm combines a multi-objective aware path decomposition strategy with a probabilistic segment reassembly technique. It first decomposes the current solution into variable-length paths by identifying segments with balanced contributions to both objectives, then probabilistically reassembles these segments by considering their spatial proximity in both objective spaces, followed by a guided edge swapping operation that prioritizes edges with complementary improvements in both objectives while maintaining tour feasibility, and finally refines the solution with a novel node relocation heuristic that dynamically adjusts the relocation probability based on the current solution's structure and the relative improvement potential in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Multi-objective path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        prev_cost1 = distance_matrix_1[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n        prev_cost2 = distance_matrix_2[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n\n        # Check if segment should be split\n        if (current_cost1 > 1.2 * prev_cost1 and current_cost2 > 1.2 * prev_cost2) or np.random.random() < 0.1:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic segment reassembly\n    if len(segments) > 1:\n        # Calculate segment scores based on spatial proximity in both objectives\n        segment_scores = []\n        for seg in segments:\n            # Calculate centroids in both objective spaces\n            centroid1 = np.mean(instance[seg, :2], axis=0)\n            centroid2 = np.mean(instance[seg, 2:], axis=0)\n\n            # Calculate average distance to other segments\n            avg_dist1 = np.mean([np.linalg.norm(centroid1 - np.mean(instance[other_seg, :2], axis=0))\n                                for other_seg in segments if other_seg != seg])\n            avg_dist2 = np.mean([np.linalg.norm(centroid2 - np.mean(instance[other_seg, 2:], axis=0))\n                               for other_seg in segments if other_seg != seg])\n\n            # Combined score (weighted average)\n            score = 0.5 * avg_dist1 + 0.5 * avg_dist2\n            segment_scores.append(score)\n\n        # Reassemble segments in order of decreasing score\n        sorted_indices = np.argsort(segment_scores)[::-1]\n        new_solution = np.concatenate([segments[i] for i in sorted_indices])\n\n    # Guided edge swapping\n    for _ in range(min(5, n//2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try swapping edges\n        candidate = new_solution.copy()\n        if i < j:\n            candidate[i:j+1] = np.concatenate([candidate[j:j+1], candidate[i+1:j], candidate[i:i+1]])\n        else:\n            candidate[j:i+1] = np.concatenate([candidate[i:i+1], candidate[j+1:i], candidate[j:j+1]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly while the other doesn't worsen too much\n        if ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or\n            (new_cost1 < current_cost1 * 0.9 and new_cost2 <= current_cost2 * 1.1) or\n            (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9)):\n            new_solution = candidate\n\n    # Node relocation heuristic\n    for _ in range(min(3, n//3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try relocating node i after node j\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:j+1], [candidate[i]], candidate[j+1:i], candidate[i+1:]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Dynamic relocation probability based on improvement potential\n        improvement_ratio = (current_cost1 - new_cost1) / current_cost1 + (current_cost2 - new_cost2) / current_cost2\n        prob = min(1.0, 0.5 + 0.5 * improvement_ratio)\n        if np.random.random() < prob:\n            new_solution = candidate\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.2572821231179985,
               6.7334989692074805
          ]
     },
     {
          "algorithm": "{The new algorithm combines the strengths of both provided approaches by first identifying solutions with high potential for improvement through a novel \"objective-aware edge replacement\" strategy, where edges are selectively replaced based on their performance in both objective spaces. It then employs a \"multi-phase neighborhood exploration\" that alternates between a \"coordinate-based segment reversal\" operator, which considers the geometric properties of the nodes in both spaces, and a \"cross-objective path smoothing\" operator that optimizes the tour by iteratively adjusting segments to balance improvements in both objectives. The algorithm dynamically adjusts the exploration focus based on the current Pareto front, ensuring a diverse and high-quality search while maintaining feasibility through strict validation checks.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high improvement potential\n    objectives = np.array([obj for (sol, obj) in archive])\n    costs = objectives.sum(axis=1)\n    norm_costs = (costs - costs.min()) / (costs.max() - costs.min() + 1e-10)\n\n    # Calculate improvement potential (difference from average cost)\n    avg_cost = np.mean(costs)\n    improvement_potential = avg_cost - costs\n    norm_potential = (improvement_potential - improvement_potential.min()) / (improvement_potential.max() - improvement_potential.min() + 1e-10)\n\n    # Combine scores (weighted sum of normalized cost and improvement potential)\n    scores = 0.6 * norm_costs + 0.4 * norm_potential\n    probs = np.exp(-scores) / np.exp(-scores).sum()\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost = archive[selected_idx][1]\n\n    # Step 2: Objective-aware edge replacement\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Identify edges with poor performance in both objectives\n        edges = [(i, (i+1)%n) for i in range(n)]\n        edge_scores = []\n\n        for i, j in edges:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            cost1 = distance_matrix_1[node_i, node_j]\n            cost2 = distance_matrix_2[node_i, node_j]\n\n            # Score based on normalized cost in both objectives\n            norm_cost1 = (cost1 - distance_matrix_1.min()) / (distance_matrix_1.max() - distance_matrix_1.min() + 1e-10)\n            norm_cost2 = (cost2 - distance_matrix_2.min()) / (distance_matrix_2.max() - distance_matrix_2.min() + 1e-10)\n            edge_scores.append((norm_cost1 + norm_cost2, i, j))\n\n        # Sort edges by their combined score (worst first)\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n        # Replace the worst edges with better alternatives\n        for _, i, j in edge_scores[:min(3, len(edge_scores))]:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Find alternative edges that could improve both objectives\n            best_candidate = None\n            best_improvement = 0\n\n            for k in range(n):\n                if k != i and k != j and (k+1)%n != i and (k+1)%n != j:\n                    node_k = new_solution[k]\n                    node_l = new_solution[(k+1)%n]\n\n                    cost1_ik = distance_matrix_1[node_i, node_k]\n                    cost1_lj = distance_matrix_1[node_l, node_j]\n                    cost2_ik = distance_matrix_2[node_i, node_k]\n                    cost2_lj = distance_matrix_2[node_l, node_j]\n\n                    current_cost1 = distance_matrix_1[node_i, node_j]\n                    current_cost2 = distance_matrix_2[node_i, node_j]\n\n                    improvement = (current_cost1 - cost1_ik - cost1_lj) + (current_cost2 - cost2_ik - cost2_lj)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_candidate = (k, (k+1)%n)\n\n            if best_candidate:\n                k, l = best_candidate\n                candidate = new_solution.copy()\n                candidate[i], candidate[k] = candidate[k], candidate[i]\n                candidate[j], candidate[l] = candidate[l], candidate[j]\n\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n\n    # Step 3: Multi-phase neighborhood exploration\n    # Phase 1: Coordinate-based segment reversal\n    if n > 2:\n        # Identify segments that could be reversed based on coordinate properties\n        for _ in range(3):\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n\n            # Calculate centroids of the segment in both spaces\n            seg_coords = instance[segment]\n            centroid1 = np.mean(seg_coords[:, :2], axis=0)\n            centroid2 = np.mean(seg_coords[:, 2:], axis=0)\n\n            # Calculate centroid of the entire solution\n            all_coords = instance[new_solution]\n            global_centroid1 = np.mean(all_coords[:, :2], axis=0)\n            global_centroid2 = np.mean(all_coords[:, 2:], axis=0)\n\n            # Calculate distance from segment centroid to global centroid\n            dist1 = np.linalg.norm(centroid1 - global_centroid1)\n            dist2 = np.linalg.norm(centroid2 - global_centroid2)\n\n            # Reverse segment if it's far from the global centroid in either space\n            if dist1 > 0.5 * np.mean(distance_matrix_1) or dist2 > 0.5 * np.mean(distance_matrix_2):\n                candidate = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n\n    # Phase 2: Cross-objective path smoothing\n    if n > 3:\n        # Iteratively adjust segments to balance improvements\n        for _ in range(5):\n            i, j = sorted(random.sample(range(n), 2))\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Find alternative path that could improve both objectives\n            best_candidate = None\n            best_improvement = 0\n\n            for k in range(n):\n                if k != i and k != j and (k+1)%n != i and (k+1)%n != j:\n                    node_k = new_solution[k]\n                    node_l = new_solution[(k+1)%n]\n\n                    cost1_ik = distance_matrix_1[node_i, node_k]\n                    cost1_lj = distance_matrix_1[node_l, node_j]\n                    cost2_ik = distance_matrix_2[node_i, node_k]\n                    cost2_lj = distance_matrix_2[node_l, node_j]\n\n                    current_cost1 = distance_matrix_1[node_i, node_j]\n                    current_cost2 = distance_matrix_2[node_i, node_j]\n\n                    improvement = (current_cost1 - cost1_ik - cost1_lj) + (current_cost2 - cost2_ik - cost2_lj)\n\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_candidate = (k, (k+1)%n)\n\n            if best_candidate and best_improvement > 0:\n                k, l = best_candidate\n                candidate = new_solution.copy()\n                candidate[i], candidate[k] = candidate[k], candidate[i]\n                candidate[j], candidate[l] = candidate[l], candidate[j]\n\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               7.437746968770199,
               6.562567433454664
          ]
     },
     {
          "algorithm": "{The new algorithm employs a dynamic clustering-based approach to identify promising regions in the solution space, where each cluster represents a distinct segment of the tour that could benefit from coordinated optimization across both objectives. It first partitions the current solution into variable-length segments based on the spatial proximity of nodes in both objective spaces, then applies a guided segment crossover operation where segments are exchanged between clusters while maintaining feasibility, followed by a probabilistic segment inversion that considers the relative improvement potential of each segment in both objectives, and finally refines the solution with a novel edge insertion heuristic that prioritizes edges with balanced contributions to both objectives while preserving the tour's connectivity. The algorithm dynamically adjusts the segment size and selection probability based on the current solution's structure and the distance matrices, ensuring a diverse exploration of the search space while maintaining feasibility throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic clustering-based segment identification\n    cluster_sizes = np.random.randint(2, min(6, n//2), size=np.random.randint(2, min(4, n//3)))\n    cluster_sizes = np.clip(cluster_sizes, 2, n - np.sum(cluster_sizes[:-1]) - 1)\n    cluster_sizes[-1] = n - np.sum(cluster_sizes[:-1])\n\n    clusters = []\n    current_pos = 0\n    for size in cluster_sizes:\n        clusters.append(new_solution[current_pos:current_pos+size])\n        current_pos += size\n\n    # Guided segment crossover\n    if len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        temp = clusters[i].copy()\n        clusters[i] = clusters[j].copy()\n        clusters[j] = temp\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Probabilistic segment inversion\n    for cluster in clusters:\n        if len(cluster) > 2 and np.random.random() < 0.3:\n            cluster_start = np.where(new_solution == cluster[0])[0][0]\n            new_solution[cluster_start:cluster_start+len(cluster)] = cluster[::-1]\n\n    # Novel edge insertion heuristic\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate cost difference\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Try inserting node j between i and i+1\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:i+1], [candidate[j]], candidate[i+1:j], candidate[j+1:]])\n\n        new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, n))\n        new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, n))\n\n        # Weighted decision\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2*1.1) or (new_cost1 <= current_cost1*1.1 and new_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.408399447509758,
               6.971989664069907
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity (uncommon edges) to encourage exploration\n    edge_sets = [set(zip(sol, np.roll(sol, -1))) for sol, _ in archive]\n    diversity_scores = []\n    for i, edges in enumerate(edge_sets):\n        unique_edges = set()\n        for j, other_edges in enumerate(edge_sets):\n            if i != j:\n                unique_edges.update(edges - other_edges)\n        diversity_scores.append(len(unique_edges))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine path reversal with objective-aware edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a path reversal between two random points\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Then, perform objective-aware edge swapping\n    for _ in range(min(3, n // 2)):  # Limit the number of swaps\n        # Select two random edges to consider swapping\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n        # Calculate current and potential costs for both objectives\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_1[new_solution[d], new_solution[(d+1)%n]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[d], new_solution[(d+1)%n]])\n\n        # Create candidate solution with swapped edges\n        candidate = new_solution.copy()\n        candidate[a], candidate[b], candidate[c], candidate[d] = candidate[c], candidate[d], candidate[a], candidate[b]\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[a-1], candidate[a]] +\n                     distance_matrix_1[candidate[b], candidate[(b+1)%n]] +\n                     distance_matrix_1[candidate[c-1], candidate[c]] +\n                     distance_matrix_1[candidate[d], candidate[(d+1)%n]])\n\n        new_cost2 = (distance_matrix_2[candidate[a-1], candidate[a]] +\n                     distance_matrix_2[candidate[b], candidate[(b+1)%n]] +\n                     distance_matrix_2[candidate[c-1], candidate[c]] +\n                     distance_matrix_2[candidate[d], candidate[(d+1)%n]])\n\n        # Accept the swap if it improves both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.585709769064202,
               6.716622097083773
          ]
     }
]