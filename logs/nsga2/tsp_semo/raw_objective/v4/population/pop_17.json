[
    {
        "algorithm": "{This algorithm implements a multi-objective adaptive path reversal and segment insertion strategy that combines probabilistic segment reversal with dynamic segment insertion and intelligent node reinsertion, dynamically balancing improvements across both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(2, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        segments.append(segment)\n\n    reassembled = []\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 if pos == 0 or pos == len(reassembled) else 0.3\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.7 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            9.233414817234918,
            4.259607197121429
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    }
]