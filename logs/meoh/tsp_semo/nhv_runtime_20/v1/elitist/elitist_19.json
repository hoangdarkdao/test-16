[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.993150798200477,
            0.11833864450454712
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment reversal, node insertion, and crossover with a randomly selected solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal, node insertion, and crossover\n    n = len(new_solution)\n\n    # Step 1: Segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion\n    node = new_solution[random.randint(0, n-1)]\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Crossover with another random solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, n-1)\n        new_solution[:crossover_point] = other_solution[:crossover_point]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9366088005416936,
            0.09744668006896973
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a normalized hypervolume score, then applies a hybrid local search combining edge reassignment and a randomized segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1 + 1e-6)\n        norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2 + 1e-6)\n        score = 0.5 * norm_obj1 + 0.5 * norm_obj2  # Equal weighting for both objectives\n        scores.append((score, sol))\n\n    scores.sort(key=lambda x: x[0])\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge reassignment: randomly select two non-adjacent edges and swap them\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-2)\n        while abs(i - j) <= 1:\n            j = random.randint(0, n-2)\n\n        # Swap the edges\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n        # Randomized segment inversion: invert a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9756998337097224,
            0.19906485080718994
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive by prioritizing those with high potential for improvement (e.g., non-dominated or poorly explored regions) and applies a hybrid local search combining edge swaps, insertions, and path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on objective values\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps, insertions, and path relinking\n    n = len(new_solution)\n\n    # Step 1: Edge swap with high potential improvement\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Insertion of a randomly selected node\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path relinking (partial swap between base and new solution)\n    relink_pos = random.randint(0, n-1)\n    relink_length = random.randint(1, min(5, n//2))\n    for p in range(relink_pos, min(relink_pos + relink_length, n)):\n        if random.random() < 0.3:\n            new_solution[p], base_solution[p] = base_solution[p], new_solution[p]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9699668844998457,
            0.1808682680130005
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined objective values, then applies a hybrid local search combining segment rotation, node relocation, and a novel path inversion technique to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = [obj for (sol, obj) in archive]\n    max_obj = max(objectives, key=lambda x: (x[0] + x[1]))\n    selected_idx = [i for i, obj in enumerate(objectives) if obj == max_obj][0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Step 1: Segment rotation\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k-i)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Node relocation\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Path inversion with distance-based selection\n    total_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    avg_dist = (total_dist1 + total_dist2) / (2 * (n-1))\n\n    # Find a segment where average distance is below average\n    found = False\n    for _ in range(10):\n        a, b = sorted(random.sample(range(n), 2))\n        segment_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(a, b+1))\n        segment_avg = (segment_dist1 + segment_dist2) / (2 * (b-a))\n        if segment_avg < avg_dist:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            found = True\n            break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9853124664208053,
            0.3707008957862854
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge relocation with a randomized segment reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized scores for each solution\n    max_obj1 = max(obj[0] for _, obj in archive) if archive else 1.0\n    max_obj2 = max(obj[1] for _, obj in archive) if archive else 1.0\n\n    scored_solutions = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0.0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0.0\n        score = 0.4 * norm_obj1 + 0.6 * norm_obj2  # Different weighting to focus more on the second objective\n        scored_solutions.append((score, sol))\n\n    scored_solutions.sort(key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Hybrid local search: edge relocation with randomized segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Insert the reversed segment at a random position\n        insert_pos = random.randint(0, n - len(reversed_segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Ensure no duplicates\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # If duplicates exist, revert to original solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9568732412501941,
            0.10789024829864502
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a non-linear weighted combination of objectives, then applies a hybrid local search combining segment reversal and random swaps to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-linear weighted objective score\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = objectives * weights\n    combined_scores = np.sqrt(weighted_scores[:, 0]**2 + weighted_scores[:, 1]**2)  # Euclidean distance in objective space\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    c = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n\n    # Option 1: Reverse segments and swap (more complex than simple reversal)\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n    # Option 2: Random swap of segments\n    else:\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c+1:]])\n\n    # Ensure feasibility (no duplicates)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    if len(unique_indices) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        for i, node in enumerate(missing_nodes):\n            new_solution[unique_indices[i]] = node\n\n    return new_solution\n\n",
        "score": [
            -0.9607322286408637,
            0.1317448616027832
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.993150798200477,
            0.11833864450454712
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.993150798200477,
            0.11833864450454712
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.993150798200477,
            0.11833864450454712
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined Pareto dominance and crowding distance metric, then applies a novel local search operator combining a multi-swap operation with a reverse segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            elif obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [x for i, x in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if pareto_front:\n        # Calculate crowding distance for Pareto front solutions\n        sorted_front = sorted(pareto_front, key=lambda x: x[1][0])\n        crowding_distances = [0] * len(sorted_front)\n        for m in range(2):\n            sorted_front.sort(key=lambda x: x[1][m])\n            crowding_distances[0] = float('inf')\n            crowding_distances[-1] = float('inf')\n            for i in range(1, len(sorted_front)-1):\n                crowding_distances[i] += (sorted_front[i+1][1][m] - sorted_front[i-1][1][m]) / (max(obj[m] for _, obj in pareto_front) - min(obj[m] for _, obj in pareto_front) + 1e-6)\n\n        # Select solution with maximum crowding distance\n        max_crowding_idx = np.argmax(crowding_distances)\n        base_solution = sorted_front[max_crowding_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-swap operation: randomly select 3 non-adjacent edges and perform a cyclic permutation\n        indices = random.sample(range(n), 3)\n        i, j, k = sorted(indices)\n\n        # Perform cyclic permutation\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n        # Reverse segment insertion: select a random segment and insert it in reverse order at another position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b][::-1]\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    return new_solution\n\n",
        "score": [
            -0.9168187414785317,
            0.07548391819000244
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining segment reversal, node swapping, and edge insertion with a randomly selected segment from another solution to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for (sol, obj) in archive]\n    weights = [0.6, 0.4]\n    weighted_scores = [w1 * obj[0] + w2 * obj[1] for (w1, w2), obj in zip(zip(weights, [1 - w for w in weights]), objectives)]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = other_solution[a:b]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        for node in missing:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.993150798200477,
            0.11833864450454712
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and tour structure diversity, then applies a hybrid local search combining multi-segment rotation and selective edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: multi-segment rotation and selective edge flipping\n    if n > 6:\n        # Multi-segment rotation\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n        # Selective edge flipping\n        flip_pos = random.randint(1, n-2)\n        if random.random() < 0.3:  # 30% chance to flip\n            new_solution[flip_pos], new_solution[flip_pos+1] = new_solution[flip_pos+1], new_solution[flip_pos]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -1.018785602379097,
            0.4575749635696411
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator combining path relinking with a randomized segment insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weighted_solutions = []\n    for sol, obj in archive:\n        weight = 0.3 * obj[0] + 0.7 * obj[1]  # Different weighting to focus more on the second objective\n        weighted_solutions.append((weight, sol))\n    weighted_solutions.sort(key=lambda x: x[0])\n    base_solution = weighted_solutions[0][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Path relinking: select a segment from the base solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Randomized segment insertion: insert the segment at a random position\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:insert_pos + len(segment)],\n            new_solution[insert_pos + len(segment):]\n        ])\n\n        # Remove duplicates to maintain feasibility\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            new_solution = np.concatenate([unique_nodes, np.setdiff1d(base_solution, unique_nodes)])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9698830890354431,
            0.07554221153259277
        ]
    }
]