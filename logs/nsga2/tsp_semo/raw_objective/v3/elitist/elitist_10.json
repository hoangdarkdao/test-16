[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.033601872808748,
            5.421414242948537
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.842318304956346,
            7.953715747109067
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.842318304956346,
            7.953715747109067
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.564681530529454,
            5.655044504385038
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution structure diversity, then applies a novel local search operator that combines a probabilistic segment inversion with a guided node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and structural diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Calculate structural diversity using Hamming distance\n    diversity_scores = []\n    for sol, _ in archive:\n        hamming_dist = sum(1 for i in range(len(sol)) if sol[i] != archive[0][0][i])\n        diversity_scores.append(hamming_dist)\n    diversity_scores = np.array(diversity_scores)\n\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.5 * (diversity_scores / len(sol))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Novel local search: probabilistic segment inversion with guided node insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment inversion\n        if np.random.random() < 0.6:\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Guided node insertion based on objective improvement\n        if np.random.random() < 0.8:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Try inserting node i after node j\n                temp_sol = new_solution.copy()\n                temp_sol = np.delete(temp_sol, i)\n                temp_sol = np.insert(temp_sol, j, new_solution[i])\n\n                new_cost1 = distance_matrix_1[temp_sol[j-1], temp_sol[j]] + distance_matrix_1[temp_sol[(j+1)%N], temp_sol[j]]\n                new_cost2 = distance_matrix_2[temp_sol[j-1], temp_sol[j]] + distance_matrix_2[temp_sol[(j+1)%N], temp_sol[j]]\n\n                # Accept insertion if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution = temp_sol\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.758819988397105,
            6.041005971354555
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a hybrid local search combining 4-opt with a probabilistic segment insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better diversity-aware objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    diversity_weights = np.array([0.4, 0.6])  # Emphasize second objective for diversity\n    weighted_scores = np.sum(normalized_scores * diversity_weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 4-opt with probabilistic segment insertion\n        a, b, c, d = np.random.choice(N, 4, replace=False)\n        a, b, c, d = sorted([a, b, c, d])\n\n        # 4-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.7:\n            i, j = np.random.choice(N, 2, replace=False)\n            if i < j:\n                segment = new_solution[i:j]\n                new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.033601872808748,
            5.421414242948537
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.252339302702418,
            5.669518134292408
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic path reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n    weights = np.array([0.6, 0.4])  # Different weight for first objective\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 5:\n        # Hybrid local search: 3-opt with probabilistic path reversal\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # 3-opt move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic path reversal\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.842318304956346,
            7.953715747109067
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel local search operator that combines a probabilistic segment rotation with a guided edge swap to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    diversity_scores = np.std(normalized_scores, axis=1)\n    combined_scores = np.sum(normalized_scores, axis=1) - 0.3 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel local search: probabilistic segment rotation with guided edge swap\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Guided edge swap based on objective improvement\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                # Calculate potential improvement\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                # Accept swap if it improves at least one objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.564681530529454,
            5.655044504385038
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel segment-based perturbation that combines partial reversal with probabilistic segment insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.6, 0.4])\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    diversity_scores = [np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))]\n    diversity_score = np.mean(diversity_scores) if diversity_scores else 0\n    combined_scores = weighted_scores + 0.2 * diversity_score\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Segment-based perturbation\n        segment_length = max(2, min(5, np.random.randint(2, N//2)))\n        start = np.random.randint(0, N - segment_length)\n        end = start + segment_length\n\n        # Partial reversal\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Probabilistic segment insertion\n        if np.random.random() < 0.5:\n            insert_pos = np.random.randint(0, N - segment_length)\n            segment = new_solution[start:end]\n            new_solution = np.delete(new_solution, np.s_[start:end])\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.526401963476373,
            6.643883488438379
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.252339302702418,
            5.669518134292408
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novelty-aware selection that prioritizes both objective quality and structural novelty, then applies a hybrid local search combining path inversion with adaptive segment swapping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize novelty and objective quality\n    solutions = [sol for (sol, _) in archive]\n    objectives = np.array([obj for (_, obj) in archive])\n    N = len(solutions[0])\n\n    # Calculate novelty scores (number of unique edges not shared with other solutions)\n    novelty_scores = []\n    all_edges = set()\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        all_edges.update(edges)\n\n    for sol in solutions:\n        edges = set()\n        for j in range(N):\n            edges.add((sol[j], sol[(j+1)%N]))\n        novelty_scores.append(len(edges.intersection(all_edges)) / len(edges))\n\n    # Combine objective and novelty scores\n    weights = np.random.uniform(0.3, 0.7)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(novelty_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Hybrid local search: path inversion with adaptive segment swapping\n        # Select a segment to invert\n        seg_length = np.random.randint(2, min(6, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find best position to insert the inverted segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Adaptive segment swapping\n        if np.random.random() < 0.3:\n            a, b = np.random.choice(N, 2, replace=False)\n            a, b = sorted([a, b])\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.11445590578504,
            5.686677605646184
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a hybrid local search operator that combines a novel \"path inversion\" technique with a probabilistic edge reversal to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    combined_scores = objectives[:, 0] + objectives[:, 1] - 0.3 * np.array(diversity_scores)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: path inversion with probabilistic edge reversal\n    new_solution = base_solution.copy()\n\n    if N > 4:\n        # Path inversion: select a random segment and reverse it\n        start = np.random.randint(0, N)\n        end = np.random.randint(start, N)\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Probabilistic edge reversal\n        if np.random.random() < 0.5:\n            a, b = np.random.choice(N, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.814854000393363,
            5.84931930692752
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.252339302702418,
            5.669518134292408
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and solution quality metrics, then applies a novel hybrid local search combining edge reversal with adaptive segment insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective scores\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / (objectives.max(axis=0) + 1e-8)\n    quality_scores = np.exp(-np.sum(normalized_obj, axis=1))\n    selected_idx = np.argmax(quality_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Novel hybrid local search: edge reversal with adaptive segment insertion\n        # First perform edge reversal\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Then perform adaptive segment insertion\n        seg_length = max(2, min(4, N//3))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that maximizes the improvement in both objectives\n        best_pos = start\n        best_improvement = 0\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate improvement in both objectives\n            original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%N]] for i in range(N))\n            original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%N]] for i in range(N))\n            new_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            new_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n\n            improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.821505219809222,
            5.79928232353381
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining edge reversal with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge reversal with probabilistic node insertion\n        a, b = np.random.choice(N, 2, replace=False)\n        a, b = sorted([a, b])\n\n        # Edge reversal\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.588177056698409,
            6.341186489318877
        ]
    }
]